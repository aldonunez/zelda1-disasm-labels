R:0010:CurLevel
R:0011:IsUpdatingMode
R:0012:GameMode
R:0013:GameSubmode
R:0014:TileBufSelector
R:0015:FrameCounter
R:0016:CurSaveSlot
R:0018-0024:Random
R:0026:StunCycle
R:0027:DoorTimer
R:0028-003B:ObjTimer
R:003C:_FluteTimer
R:003D-004A:ObjStunTimer
R:004B:MonstersFromEdgesLongTimer
R:004C:SwordBlockedLongTimer
R:004D:RedLeeverLongTimer
R:0050:HelpDropCount: When [50] HelpDropCount >= $A, specific items are dropped.\n See [51] HelpDropValue.\n
R:0051:HelpDropValue: Determines which item to drop when [50] HelpDropCount >= $A.\n 0:     5 rupees\n other: bomb\n
R:0052:ProcessedNarrowObj: Indicates whether object drawing routines wrote 1 sprite for\n a narrow / half-width object instead of 2 sprites for a\n wide / full-width one.
R:0053:DoorwayDir: The direction that Link entered a doorway.\n
R:0054:TriggeredDoorCmd: Used together with TriggeredDoorDir [55] to open and close a door.\n\n To close a door, set this variable to 2.\n During world update, it will be turned into 3, Link's timer will\n be set to $30, and the door timer will be set to 8.\n\n To open a door, set this variable to 6.\n During world update, it will be turned into 7, and the\n door timer will be set to 8.\n\n Once the door timer expires, door tiles and state will be changed.\n
R:0055:TriggeredDoorDir: Set TriggeredDoorCmd [54] to animate this door opening or closing.\n
R:0056:Link_GoStraightWhenDiagInput
R:0057:Link_GoStraight
R:0058:VScrollAddrHi
R:0059:EmptyMonsterSlot
R:005A:UndergroundExitType: 0: not at an underground exit\n 1: cave (OW), cellar (UW)\n 2: dungeon level
R:005B:TargetMode
R:005C:SwitchNameTablesReq:TODO: Or call it UseOtherNameTable?
R:005D:_CurScanRoomId
R:005E:SubmenuScrollProgress: SubmenuScrollProgress begins at $2B. Each frame it will be\n decremented. It encodes a submenu row index in bits 1 to 7,\n and a flag in bit 0.\n\n When the flag is 1, a full row of black tiles will be transferred\n at the current row. Otherwise, one of various static visual\n elements will be transferred.\n\n For example:\n 1. In the first frame of scrolling, $2B indicates that a full row\n    of black tiles must be transferred to row $15.\n 2. In the second frame ($2A), submenu row will again be\n    $15, but something else will be transferred.\n 3. In the third frame ($29), a full row of black tiles will be\n    transferred to row $14.\n
R:005F:OddBaseNameTableOverride
R:0060:ChaseOtherTarget
R:0061:ChaseTargetX
R:0062:ChaseTargetY
R:0063:World_IsFillingHearts
R:0064:LadderSlot: The object slot that holds the ladder. 0 if unused.
R:0065:_UndergroundEntranceTile
R:0070-0083:ObjX
R:0084-0097:ObjY
R:0098-00AA:ObjDir
R:00AB:RoomItemId
R:00AC-00BF:ObjState
R:00C0-00CB:ObjShoveDir
R:00D3-00DE:ObjShoveDistance
R:00E0:Paused
R:00E1:MenuState: else start scrolling the menu.
R:00E2:VScrollAddrLo
R:00E3:IsSprite0CheckActive
R:00E5:DeathTurns
R:00E6:VScrollStartFrame
R:00E8:CurColumn
R:00E9:CurRow
R:00EA:WhirlwindPrevRoomId
R:00EB:RoomId
R:00EC:NextRoomId
R:00ED:PrevRow
R:00EE:CurOpenedDoors: Only true doors that have been opened are represented\n in this mask.\n
R:00F3:_Unknown_F3
R:00F4:InitializedGame
R:00F5:TransferredCommonPatterns
R:00F6:TransferredDemoPatterns
R:00F7:ReturnToBank4
R:00F8-00F9:ButtonsPressed
R:00FA-00FB:ButtonsDown
R:00FC:CurVScroll
R:00FD:CurHScroll: Update nametable scrolling.
R:00FE:CurPpuMask_2001
R:00FF:CurPpuControl_2000
R:010E:PositiveGridCellSize
R:010F:NegativeGridCellSize
R:0200-02FF:Sprites
R:0301:DynTileBufLen
R:0302-0334:DynTileBuf:TODO: Not sure if the length is 51.
R:033F:OpenDoorwayMask: Each bit of OpenDoorwayMask corresponds to a direction,\n and holds the walkable state of each doorway:\n 1 = open/walkable, 0 = closed/not walkable.\n\n Built by successive calls to CalcOpenDoorwayMask, which\n looks at doorway type and room flags.\n
R:0340:CurObjIndex
R:0341:RollingSpriteIndex: Cycles from 0 to $27.\n
R:0342:FirstSpriteIndex
R:0343:LeftSpriteOffset
R:0344:RightSpriteOffset
R:0346:RoomBoundLeft
R:0347:RoomBoundRight
R:0348:RoomBoundUp
R:0349:RoomBoundDown
R:034A:ObjectFirstUnwalkableTile
R:034B:ShotCollidesWithLink
R:034C:ActiveMonsterShots
R:034D:_RoomAllDead
R:034E:RoomObjCount
R:034F-035E:ObjType
R:035F:_RoomObjTemplateType: TODO: Or RoomObjTemplate, or RoomMonsterTemplate,\n or RoomTemplateObjType\n
R:0380:_ObjMovingLimit
R:0394-03A7:ObjGridOffset: Used in movement like walking.\n When grid offset = 0, an object is at an intersection point in the tile grid.\n Otherwise, the object is between points along a line.\n
R:03A8-03BB:_ObjPosFrac
R:03BC-03CF:_ObjQSpeedFrac
R:03D0-03E3:ObjAnimCounter
R:03E4-03F7:_ObjMovementFrame
R:03F8-0404:ObjInputDir: At the beginning of a frame, this will be set to 0 to 2 directions.\n
R:0405-0411:_ObjMetaState
R:0412:_Multi_0412: TODO:\n Mode 0: TriforceGlowTimer\n Mode 5: ObjFlyingPosFrac\n Mode 5: Push timer for blocks, rocks, and gravestones (slot $B)\n Mode 5: "wants to shoot" for walkers\n Mode 5: vertical speed high byte for jumpers\n Mode 10: TargetY\n
R:0413:_TriforceGlowCycle: TODO:\n 0: TriforceGlowCycle\n B: CaveFlags\n\n TODO: describe the cave flags\n
R:0415:_ScrolledScreenCount
R:0417:DemoLineAttrVramAddrLo
R:0418:DemoLineAttrVramAddrHi
R:0419:DemoLineIndex
R:041A:DemoPhase0Subphase0Timer
R:041B:ScrolledLineCount
R:041C:DemoLineTileVramAddrLo
R:041D:DemoLineTileVramAddrHi
R:041F:_Multi_041F: TODO:\n Mode 0: InitializedWaterfallAnimation\n Mode 5: ObjFlyingSpeedFrac\n Mode 5: Wanderer: turn rate\n Mode 5: vertical speed low byte for jumpers\n Mode E: CharBoardIndex\n
R:0420-0422:_TitleWaveYs
R:0423:: The VRAM address now points outside name field.\n So, wrap around to the beginning of name field.
R:0426:StillHoldingButton
R:0427:HeldButton
R:0428:SubsequentButtonRepeat
R:0429:ButtonRepeatTimer
R:042A:ModeE_WrappedAroundBoardY
R:042C:_Multi_042C: TODO:\n Mode 0: DemoPhase\n Mode 5: ObjFlyingTurns\n Mode 5: Thrower\n Mode 5: Goriya's boomerang\n Mode 5: Dodongo: bloated substate\n
R:042D:DemoSubphase
R:042E:_DemoLineTextIndex
R:042F:_DemoItemRow
R:0437:_Multi_0437: TODO:\n Mode 0: DemoPhase0Subphase1Cycle\n Mode 5: ObjFlyingDistTraveled\n
R:0438:_DemoPhase0Subphase1Timer
R:0444:_Multi_0444: TODO:\n Mode 0: (Demo) ItemTypes\n Mode 5: ObjFlyingState\n Mode 5: jump target Y\n
R:0451-045D:_ObjShootTimer: ObjShootTimer\n While this variable <> 0, a walking monster will not walk.\n When it reaches $10, it will shoot.\n
R:0485-0491:ObjHP
R:0492-049D:_ObjUninitialized
R:049E-04B1:_ObjCollidedTile
R:04B2-04BE:_ObjInvincibilityMask
R:04BF-04CA:ObjAttr
R:04CC:_EnablePersonFireballs
R:04CD:LevelBlockAttrsByteF: This seems to be used for convenience in accessing it multiple times in a room.
R:04CE:ShutterTrigger
R:04CF:BlockPushComplete
R:04D1:FlyingMaxSpeedFrac
R:04D7:GleeokCurNeck
R:04D8:GleeokSignedRefSegmentDistance
R:04D9-04DA:GleeokPrimarySegmentLimits
R:04DB-04DC:GleeokSecondarySegmentLimits
R:04DD-04DE:GleeokTertiarySegmentLimits
R:04E5:StatusBarMapTrigger
R:04E6:_GleeokAnimationTimer
R:04E7:_GleeokBodyAnimationFrame
R:04F0-04FC:ObjInvincibilityTimer
R:0504:LeftAlignHalfWidthObj
R:0505:ItemTypeToLift
R:0506:ItemLiftTimer
R:0507:ChildDigdoggerCount
R:0508:_SummonedWhirlwind
R:0509:TriforceFanfareActive
R:050F:LamnolaViableDirMask
R:0510:_ActiveRedLeeverCount
R:0511:GleeokDeadNeckMask
R:0512:LinkParalyzed: Put the monster at the same location as Link.\n
R:0513:UsedCandle
R:0514:ZoraActive
R:0515:ActiveBoulders
R:051A:_SecretColorCycle
R:051B:_UsedFlute
R:051C:FadeCycle: This variable takes on values of the form x0 to x3.\n X0 marks the beginning of a cycle, and x3 the end.\n\n The values are mapped to an offset from $6BFA where a\n pair of palette rows (8 bytes) can be found.\n\n In general, a value with hex digits XY maps to offset (X0 + Y*8).\n For example:\n 60 => 60\n 61 => 68\n 62 => 70\n 63 => 78\n\n This works for positive values. To achieve a reverse fade,\n add $80 to forward cycle number. So:\n 20: 20 -> A0: 38\n 21: 28 -> A1: 30\n 22: 30 -> A2: 28\n 23: 38 -> A3: 20\n\n Given this explanation, it can be seen that these are the\n start indexes:\n Forward cycles:  $00, $20, $40, $60\n Backward cycles: $80, $A0, $C0, $E0\n
R:051D:PatternBlockIndex
R:051E:BrighteningRoom
R:051F:CandleState
R:0521:PrevOpenedDoors
R:0522:WhirlwindTeleportingState: 0: not teleporting\n 1: in source room\n 2: in destination room\n
R:0523:TeleportingLevelIndex: This index can take on any value. But there are 8 levels.\n At the point of use, this is AND'ed with 7.\n
R:0524:SpawnCycle
R:0525:_CurEdgeSpawnCell: The previous cell that was checked to try to spawn\n a monster from the edge of the screen.\n\n High nibble specifies the square row, and the low nibble\n the square column.\n
R:0526:CaveEnteredRoomId: The room ID where the player entered a cave.\n When leaving a cave, the room ID will be set to this,\n unless it's set to $FF. In this case StartRoomId will be used.
R:0527:CellarEnteredRoomId
R:0528:SkippedDemo
R:052A:_WorldKillCycle: TODO: 0 to 9\n
R:052B:RoomTileObjType
R:052C:RoomTileObjX
R:052D:RoomTileObjY
R:052E:SwordBlocked
R:052F:MazeStep
R:0530-055F:PlayAreaAttrs
R:0560-05DF:_LevelKillCounts
R:0600:SongRequest
R:0602:EventMusic2Request
R:0604:EventMusic1Request
R:0605:EventMusic1
R:0606:SoundEffect
R:0607:EventMusic2
R:0609:Song
R:0620:CurRoomHistoryIndex
R:0621-0626:RoomHistory
R:0627:WorldKillCount
R:062D-062F:QuestNumbers
R:0630-0632:DeathCounts
R:0633-0635:IsSaveSlotActive
R:0636:IsRegisterSaveFileOptionEnabled
R:0637:IsEliminateSaveFileOptionEnabled
R:0638-064F:Names
R:0650:SaveSlotHearts
R:0656:_CurItemIndex: TODO: Or SelectedItemSlot
R:0657:Items
R:0658:InvBombs
R:0659:InvArrow
R:065A:Bow
R:065D:InvFood
R:065E:Potion
R:0660:InvRaft
R:0661:InvBook
R:0662:InvRing
R:0663:InvLadder
R:0664:InvMagicKey
R:0665:InvBracelet
R:0666:InvLetter
R:0667:InvCompass
R:0668:InvMap
R:0669:InvCompass9
R:066A:InvMap9
R:066C:InvClock
R:066D:InvRupees
R:066E:InvKeys
R:066F:HeartValues
R:0670:HeartPartial
R:0671:InvTriforce
R:0672:_LastBossDefeated
R:0674:InvBoomerang
R:0675:InvMagicBoomerang
R:0676:InvMagicShield
R:067C:MaxBombs
R:067D:RupeesToAdd
R:067E:RupeesToSubtract
R:067F-07FE:WorldFlags
P:1825:DriveAudio
P:4000-404B:PersonTextAddrs
P:404C-45A1:PersonText
P:45A2-45B5:OverworldPersonTextSelectors
P:45B6-45B7:MoneyGameLossAmounts
P:45B8-45C9:MoneyGamePermutations
P:45CA-45CF:MoneyGamePermutationEndIndexes
P:45D0:InitCave: The person goes at location ($78, $80).\n
P:45D7:: If the cave/person does not remember state (give item, door charge),\n then go handle other kinds.\n
P:45EA:: Else the cave/person simply does:\n - taken:     no person, no text\n - not taken: show a person and text\n\n So, if the item was not taken, then go set up the text.\n
P:45EF:: Otherwise destroy the person object, and let Link continue.\n
P:45F4:UnhaltLink
P:45F9:: Get this cave's index (object type - $6A).\n
P:4600:: Get the person text selector by looking up the text selector byte\n for this index, and masking it with $3F.\n
P:4603:: Save the text selector byte before masking.
P:4609:: Pop and mask the text selector byte with $C0 to get the\n "pay" and "pick up" cave flags and store them in [03].\n
P:460E:: At this point, the Y register still has the cave index.\n Multiply it by 3 to get the offset of the first item in a set of 3.\n
P:4617:: Loop over the wares from 0 to 2.\n
P:4619:: Copy 3 item ID bytes from the Cave level block info.\n Item ID's are in the low 6 bits, cave flags are in the high 2 bits.\n
P:461F:: Copy the cave flags (high 2 bits) of the three items to [00] to [02].\n
P:4623:: Copy 3 prices from the Cave level block info.\n
P:4629:: Bottom of the wares copying loop.\n
P:462F:: Get the top 2 bits of text selector byte in [03],\n shift them to the bottom, and combine them with [00].\n
P:4638:: Get the top 2 bits of item descriptor 2, shift them right 4 times,\n and combine them with [00].\n
P:4642:: TODO:\n Get the top 2 bits of item descriptor 1, shift them right twice,\n and combine them with [00] into [0413].\n
P:464B:: The end result is a byte with 8 cave flags.\n\n If cave flag "money game" is missing, then go finish up,\n instead of choosing random amounts for the money game.\n
P:464F:: Determine an index randomly with increasing probability,\n from 6 to 1. Start with the following test:\n\n   If $FF < Random, then go use index 6.\n
P:4657:: If the test fails, then subtract $2B from the reference number.\n
P:465D:: The index chooses the last offset of a permutation of three indexes.\n
P:4660:: Copy the permutation of 3 indexes to [046C] to [046E].\n
P:466C:: With the first bit of another random number, choose 10 or 40\n to put in [046F]. This is a random amount to lose.\n
P:4677:: Put 10 in [0470]. This is a fixed amount to lose.\n
P:467C:: With a different bit of the second random number,\n choose 20 or 50 to put in [0471]. This is an amount to win.\n
P:4689:: TODO:\n The 3 amounts are now in [046F] to [0471].\n Reference these amounts using the permutation of indexes\n in [046C] to [046E]; and copy them to [0448] to [044A].\n
P:4697:: Reset the current character index.\n
P:469C:: Point to the front of the first textbox line.\n
P:46A3:SetUpCommonCaveObjects: Params:\n A: X coordinate\n Y: Y coordinate\n\n Set the person's coordinates, HP, and attributes.\n
P:46B1:: Halt Link.\n
P:46B5:: Set up the two bonfires.\n
P:46CA-46DA:PriceListTemplateTransferBuf
P:46DB:UpdateCavePerson: If in state 4, then every other frame skip drawing the person\n and items; and go straight to the state code for each kind of cave.\n
P:46EA:: If the cave type is not $74 medicine shop,\n or it is but the letter has not been used, then\n go draw items and run the state code.\n
P:46F8:: If the letter is selected, and B is pressed, then go use the letter.\n
P:4705:: If Link is halted, then unhalt him.\n
P:470F:: The letter has been used.\n\n Play the "secret found" tune.\n
P:4714:: Set the letter state to used (2).\n
P:4717:: Change the selected item slot to the potion's.\n
P:4736:DrawCavePerson
P:4739:: If the cave/person type >= $7B, then the visual is a moblin.\n So, go draw not mirrored.\n
P:4740:: Else the old man, old woman, and shopkeeper are all mirrored.\n
P:4746:CaveWareXs
P:4749:DrawCaveItems: If the cave flags do not call for showing items, then\n go see about showing prices.\n
P:474C:: Cave flag: Show items
P:4750:: Loop over the wares to draw, from 2 to 0.\n\n MULTI: [0421]\n
P:4758:: Look up and set the X coordinate for the current item.\n
P:475D:: Set Y coordinate $98 for the item.\n
P:4761:: If the item is nothing ($3F), then loop gain.\n\n MULTI: [0422][X]\n
P:476A:: Switch to the room item object slot, and draw it.\n
P:476F:: Bottom of the item drawing loop. Decrement this index until < 0.\n
P:4774:: If the cave flags do not call for showing prices, then return.\n
P:4777:: Cave flag: Show prices
P:477B:: Show a rupee at ($30, $AB).\n
P:478B:UpdateCavePersonState_TransferPrices: If the cave flags do not call for showing prices, then\n advance the state and return.\n
P:478E:: Cave flag: Show prices
P:4792:WritePricesTransferBuf
P:4795:: "X"
P:4797:WritePricesToDynamicTransferBuf: Params:\n A: price character\n
P:479A:: Reset the index of current price being formatted\n and offset of price string.\n
P:47A2:: Get the price of the current item.\n
P:47A5:: If it's 0, then store a space character in the text field [01], [02], [03].\n
P:47B5:: If the cave flags call for negative amounts, then\n store a dash in prefix byte [04]. Else store a space ($24).\n
P:47BD:: "-"
P:47C1:: Move the dash closer to the number.\n
P:47D9:: Add 4 to the base offset for the next string.\n
P:47E2:: Bottom of the price loop. Increment the index of the item until = 3.\n
P:47EC:: Delay $A frames at the beginning of the next state.\n
P:47F0:: Go to the next state and return.\n
P:47F2:CueTransferBufAndAdvanceState: Params:\n A: selector\n
P:47F7:SwapSpaceAndSign: Params:\n A: a character of the price string\n [04]: prefix character\n\n Returns:\n   If original A is not a space:\n     A:    original character\n     [04]: original prefix character\n   Else:\n     A:    original prefix character\n     [04]: original character\n
P:4801:CopyPriceListTemplate: Copy $11 bytes of the price list template text to the dynamic transfer buf.\n
P:480D-4811:TextboxCharTransferRecTemplate
P:4812-4814:TextboxLineAddrsLo
P:4815:_UpdatePersonState_Textbox
P:4818:: If the person's timer has not expired, then return.\n
P:481C:: Set the timer to wait 6 frames after the next character about\n to be shown.\n
P:4820:: Copy the 5 bytes of the textbox character transfer record template\n to the dynamic transfer buf.\n
P:482B:: Replace the low byte of the VRAM address with the one\n where the next character should be written.\n
P:4831:: Increment the low VRAM address for the next character.\n
P:4834:: Use the person text selector to look up the address of the\n text for the textbox. Store the address in [00:01].\n
P:4842:: Load the person text current character index.\n
P:4845:: Increment the index variable to point to the next character\n for next time.\n
P:4848:: Get the current character.\n
P:484A:: If the character is $25, then it's a special space. It will still\n take up space, but will not take time to show -- meaning that\n we'll go look up the next character to transfer.\n
P:4850:: We have a non-space character. Put it in the transfer record.\n
P:4853:: Play the "heart taken/character" sound effect.\n
P:4858:: If the high 2 bits of character element = 0, then return.\n
P:485E:: Determine an index based on the high 2 bits of the character element:\n   $80: 0\n   $40: 1\n   $C0: 2\n
P:486A:: The index chooses the low VRAM address of the start\n of another line:\n   0: $C4: front of the second line\n   1: $E4: front of the third line\n   2: $A4: front of the first line\n\n Look up the low VRAM address and store it.\n
P:4870:: If index = 2, then we've reached the end of the text,\n and low VRAM address is moved to the front of the first line.\n So, advance the state of the person object, and unhalt Link.\n
P:487A:_UpdateCavePersonState_TalkOrShopOrDoorCharge: If the cave flags call for choosing an item, then\n go handle those kinds of caves.\n
P:487D:: Cave flag: Choose/Pick up (1)
P:4880:: Advance to the end state, where the person is still shown.\n
P:4884:: If this is not the "door charge" old man, then return.\n The person only talks.\n
P:488B:: Post 20 rupees to subtract.\n
P:4894:: Mark this secret taken.\n
P:4898:: This is a cave where the player chooses or touches an item:\n - give item\n - shop\n - hint\n - money game\n\n If rupees are decreasing, then return.\n
P:489D:: Loop over each item from 2 to 0.\n
P:489F:: If this item is nothing, then loop again.\n\n MULTI: [0422][X]\n
P:48A2:: Mask off the cave flags.
P:48A4:: No item
P:48A8:: If Link's X <> item's X, then loop again.\n
P:48AF:: If the vertical distance between Link and the item < 6, then\n go try to take it.\n
P:48BB:: Bottom of the item touch loop.\n
P:48BF:: Store the index of the item chosen.\n
P:48C2:: If hint and money game cave flags are missing, then\n go take an item given away, or buy it.\n
P:48C5:: Cave flags: Hint and Money game
P:48C9:: If have cave flag "money game", then go to state 5 and return.\n
P:48CD:: Else have "hint" cave flag.\n\n If rupees < price, then return.\n
P:48D5:: Pass the price to pay for the hint.\n
P:48DB:: Go to state 5. It runs the hint cave and money game.\n
P:48E0:: This is a shop, or something is being given away.\n\n If "pay" cave flag is missing, then go try to take the item.\n
P:48E7:: If rupees < price, then return.\n
P:48EF:: Pass the price to pay for the item.\n
P:48F5:: If "heart requirement" cave flag is missing, then\n go to take the item without further ado.\n
P:48FC:: Check heart container requirements.\n\n 5 is the minimum for cave type $6C (white sword)\n $C is the minimum otherwise\n
P:490A:: If the minimum of heart containers is met, then\n go take the item without further ado.\n
P:4912:: MULTI: [0422][X]\n
P:4915:: Mask off the cave flags.
P:4917:: Push the item ID
P:4918:: Flag the item taken by setting its ID to $FF.\n
P:491D:: Pop the item ID
P:4921:: Blank textbox lines
P:4926:: Set timer to $40 for when we delay in state 4.\n
P:492A:ClearPricesCaveFlag: Remove the "show prices" cave flag to get rid of the generic rupee.\n
P:4933:_UpdatePersonState_DelayThenHide
P:493B-493D:HintCaveTextSelectors0
P:493E-4940:HintCaveTextSelectors1
P:4941:_UpdateCavePersonState_HintOrMoneyGame: If "hint" cave flag is missing, then go handle the money game.\n
P:4948:: If cave type = $75, then use 0 for base offset of\n the first set of text selectors, else 3 for the second.\n
P:4954:: Add the base offset and the index of the item chosen\n to get the index of a text selector.\n
P:4958:: Look up text selector by the index calculated above.\n
P:495E:: Point to the front of the first line of the textbox.\n
P:4964:: Reset the character index.\n
P:496C:: Blank textbox lines
P:4971:: If cave type < $7B, then go handle the money game.\n\n This is a moblin giving away money.\n
P:497B:: Write a price list into the dynamic transfer buf,\n but with a space instead of "X".\n
P:4980:: "key taken" sound effect
P:4988:: Go to state 8 to do nothing but show the person.\n
P:498C:: Post the middle amount in [0431] to add.\n
P:4992:: Money game\n\n If rupees < $A, then return.\n
P:4999:: "key taken" sound effect
P:499E:: TODO:\n Copy amounts in [0448][Y] for money game to [0430][Y].\n
P:49AC:: Go to state 8 to do nothing but show the person.\n
P:49B0:: Prepend the sign to each money game amount.\n
P:49C8:: If the amount chosen = 20 or 50, then add it;\n else subtract it.\n
P:49D6:PostCredit
P:49DE:PostDebit: Params:\n A: amount\n\n Add the amount paid to the rupees to subtract.\n
P:49E6:PrependSignToPrice: Params:\n A: price\n Y: offset from first character after "X"\n\n If the amount is $14 or $32, then use "+", else "-".\n
P:49F2:: Copy the character to the first element after the "X",\n offset by the parameter.\n
P:49F6:UpdateCavePersonState_DoNothing
P:49F7:_UpdatePersonState_CueTransferBlankPersonWares: Also blanks the third line of text.
P:49FC:InitUnderworldPerson_Full: Point to the front of the first line in VRAM.\n
P:4A1B-4A22:UnderworldPersonTextSelectorsA
P:4A23:InitUnderworldPersonA: The person goes at location ($78, $80).\n
P:4A2A:: Subtract $4B from the object type to get the old man's index.\n
P:4A31:: Look up and store the text selector.\n
P:4A37:: If this is the man that offers more bomb capacity, then\n go see if the offer was flagged as already taken.\n
P:4A40:InitUnderworldPersonLifeOrMoney_Full: The person goes at location ($78, $80).\n
P:4A47:: Set text selector for "life or money".\n
P:4A4C:: Point to the front of the first line in VRAM.\n
P:4A52:: Destroy this object if the secret/item was already taken.\n
P:4A61-4A68:UnderworldPersonTextSelectorsB
P:4A69:InitUnderworldPersonB: The person goes at location ($78, $80).\n
P:4A70:: Subtract $4B from the object type to get the old man's index.\n
P:4A77:: Look up and store the text selector.\n
P:4A80-4A83:UnderworldPersonTextSelectorsC
P:4A84:InitUnderworldPersonC: The person goes at location ($78, $80).\n
P:4A91:: Save the object type.
P:4A92:: Subtract $4B from the object type to get the old man's index.\n
P:4A96:: Look up and store the text selector.\n
P:4A9C:: Restore the object type.
P:4A9D:: Return, if this is not the man at the entrance of Level 9,\n or Link has not gotten all the triforce pieces.\n
P:4AA8:: Otherwise, open the shutters, and destroy this object.\n
P:4AB4:InitGrumble_Full: Grumble Goriya goes at location ($78, $80).\n
P:4ABB:: Store text selector $24.\n
P:4AC0:: Set the low VRAM address of the first character to transfer\n to the front of the first line in NT0. It's at index 2.\n
P:4AC6:: If Grumble already got the food, then\n reset his type and state to get rid of him.\n
P:4AD3:PlayCharacterSfx: "item taken/character" sound effect
P:4AD9:UpdateUnderworldPerson_Full: If level is not one of {3, 4, 6, 8, 9}, then\n go handle people that do more than talk.\n
P:4AEA:: Else simply draw, check collisions, and show the text.\n
P:4AF8:_UpdatePersonState_ResetCharOffset
P:4AFF:_UpdatePersonState_DoNothing
P:4B00:Person_CheckCollisions
P:4B03:: If the person died, then Link hit him. So, start shooting\n fireballs, then reset the metastate, so that he's not dead.\n
P:4B11:UpdateUnderworldComplexPerson: In state 4, the person is shown every other frame.\n
P:4B20:: If this is the "more bombs" man, then show a rupee\n at ($78, $98) using room item object slot $13.\n
P:4B45:UpdateUnderworldComplexPersonState_Begin: If this is the "more bombs" man, then show the price of the offer.\n
P:4B4C:: "-100"
P:4B50:: Set a timer of $A frames before showing characters,\n and go to state 1.\n
P:4B57:UpdateUnderworldComplexPersonState_SenseLink: If this is not the "more bombs" man, then return.\n
P:4B5E:: If Link's X <> $78, then return.\n
P:4B64:: If the distance between Link's Y and the rupee's ($98) < 6,\n then go see if Link can pay for it.\n Else return.\n
P:4B71:: If rupee count < 100, then return.\n
P:4B7A:: Post 100 rupees more to subtract.\n
P:4B81:: Play the "key taken" sound effect.\n
P:4B86:: Increase max bombs by 4, set the amount on hand to the max.\n
P:4B92:: Go mark this offer taken.\n
P:4B95:UpdateUnderworldComplexPersonState_DelayAndQuit: If the object timer has expired, then destroy this object.\n
P:4B9D:Person_DrawAndCheckCollisions
P:4BA6:UpdateUnderworldPersonLifeOrMoney_Full: In state 4, this person and the items are drawn every other frame.\n
P:4BC7-4BC8:LifeOrMoneyItemXs
P:4BC9-4BCA:LifeOrMoneyItemTypes
P:4BCB:_DrawLifeOrMoneyItems: Loop over each item to draw, from 1 to 0.\n
P:4BCD:: Save loop index.
P:4BCF:: Look up and set the X coordinate of the item.\n
P:4BD4:: Set Y=$98, and look up the item type.\n
P:4BDB:: Switch to the room item object slot.\n
P:4BE0:: Restore loop index.
P:4BE6:UpdateUnderworldPersonLifeOrMoneyState_0: Delay in the next state $A frames before showing the first character.\n
P:4BEA:: "-1   -50" text selector
P:4BEF:UpdateUnderworldPersonLifeOrMoneyState_2: Loop over each item to check, from 1 to 0.\n
P:4BF1:: If Link's X doesn't match the item's, then go loop again.\n
P:4BF8:: If the vertical distance between the item and Link < 6, then\n go handle paying appropriately.\n
P:4C08:: If the player chose the heart container, go handle it.\n
P:4C0C:: The player chose the money.\n But if he doesn't have enough, then return.\n
P:4C15:: Post 50 rupees more to subtract, and go flag this offer taken.\n
P:4C1F:: The player chose the heart container.\n\n If the number of heart containers < 4, then\n - leave the number of heart containers alone\n - set HeartPartial to 0, so Link will die with one more hit\n\n Then go flag this offer taken.\n
P:4C33:: Store (HeartValues - 1 heart container) in [00].\n
P:4C3E:: Get (HeartValues - 1 heart)\n
P:4C44:: If the result is negative, then make the full hearts 0.\n
P:4C48:: Combine the heart containers and full hearts, and store it.\n
P:4C4D:: "key taken" sound effect
P:4C5A:UpdateGrumble_Full: If state <> 3, then go check collisions and draw every frame.\n
P:4C60:: In state 3, the person is translucent by drawing\n (and checking object collisions) every other frame.\n
P:4C7C:UpdateGrumble1: If there's no food in object slot $F, then return.\n
P:4C84:: Else halt Link and play the "secret found" tune.\n
P:4C8D:_L_Person_FlagItemTakenAndAdvanceState: Flag the secret/item of this room taken.\n
P:4C90:: Set object timer $40 for when we get to state 3.\n
P:4C94:: Cue transfer record of the blank textbox lines,\n and go to the next state, where a transfer record is cued\n to clear cave/person wares.\n
P:4C99:UpdateGrumble3
P:4C9C:: If the timer has not expired, then return.\n
P:4CA0:: Deactivate the food object in slot $F.\n
P:4CA5:: Get rid of the food from the inventory.\n
P:4CA8:: Make Link idle again, and reset this object's type.\n
P:4D00:CopyCommonCodeToRam: Source address $A500.
P:4D08:: Destination address $6C90.
P:4D12:: Copy 1 byte.
P:4D16:: Increment source address.\n
P:4D23:: Increment destination address.\n
P:4D30:: Once you reach $7F00, you're done.
P:4D47:TransferDemoPatterns
P:4D4A:: Clear address latch.
P:6000:InitWhirlwind: Params:\n A: Y coordinate\n X: object index\n
P:6002:_SetUpWhirlwind: Params:\n X: object index\n\n\n Set the whirlwind's Y to Link's, X to 0, and type $2E.\n
P:6018:UpdateWhirlwind_Full: Get Link's halted state.\n
P:601D:: Add 2 to whirlwind X.\n
P:6024:: If Link is not halted or teleporting state = 0, then\n go check for collision with Link.\n
P:602D:: Else Link is halted (state $40) and teleporting state <> 0.\n\n Set Link's X to whirlwind's.\n
P:602F:: If teleporting state = 1 or whirlwind's X <> $80, go check\n the right screen edge and draw.\n
P:6036:: Teleporting state = 2 and whirlwind's X = $80.\n\n Reset Link's state, teleporting state, and whirlwind object type.\n
P:603F:: Update the player position marker, and draw one last time.\n
P:6049:: Link is not halted or teleporting state = 0.\n Try to pick up Link.\n\n If the whirlwind does not collide with Link, then go check\n for the screen's right edge.\n
P:6050:: Collided with Link.\n\n Make Link face right. Reset shove info and subroom type.\n
P:605B:: Halt Link (state $40), and hide him.\n
P:6067:: Find and set the room that will behave as the previous room\n when scrolling right to the room with the level's entrance.\n
P:6072:: Set teleporting state 1.\n
P:6075:: If whirlwind's X < $F0, go draw.\n
P:607B:: The whirlwind has reached the right edge of the screen.\n\n Destroy the object.\n
P:607E:: If teleporting state <> 0, we picked up Link.\n So, go to the next mode.\n\n Either way, draw one last time.\n
P:608D:DestroyWhirlwind
P:60A8:SummonWhirlwind: If not in mode 5, return.\n
P:60AE:: Advance the teleporting index, and store the mask for its level in [00].\n
P:60B4:: Truncate to wrap the index around.
P:60B7:: Note that this is from element 1 instead of 0.
P:60BC:: If there are no triforce pieces, then return.\n
P:60C1:: If we have gotten this triforce piece, then go try to make a\n whirlwind.\n
P:60C5:: We have not gotten this piece.\n First, advance the teleporting index again.\n
P:60C8:: If the direction Link is facing is an increasing one, then\n rotate the level mask in [00] left to correspond to the higher\n level number. Then go test this new mask.\n
P:60D7:: If instead the direction is a decreasing one, then\n rotate right to correspond to the lower level number.\n Then go test this new mask.\n
P:60E0:: If already summoned or in the middle of teleporting, then\n return and don't summon another one.\n
P:60E8:: Return if we can't find an empty monster slot.\n
P:60ED:: An empty slot was found. Flag that summoned the whirlwind.\n Switch to the empty slot, and go set up a whirlwind object.\n
P:60F5:AdvanceTeleportingLevelIndex: If Link is facing an increasing direction (right or down), then\n increase the index. Otherwise, decrease it.\n
P:6105:_DrawWhirlwind: Frames last 1 screen frame.\n
P:610A:: The whirlwind flashes by using a palette row based on the\n screen frame counter.\n
P:6111:: Flip horizontally based on movement frame, which is\n switched based on animation counter.\n
P:6114:: Whirlwind has only 1 animation frame image.
P:6119-6120:TeleportYs
P:6121:CheckInitWhirlwindAndBeginUpdate
P:6124:: If not teleporting, go start updating the mode.
P:6126:: Since we're already teleporting, the source room was\n already done. Set up the whirlwind object in destination room.\n\n Teleporting state 2 drops off Link.\n
P:6129:: Halt Link (state $40).
P:612D:: Whirlwind object goes in slot 9 in destination room.
P:612F:: Get Y coordinate of whirlwind in this destination.
P:613E:CheckTileObjectsBlocking: Params:\n [0F]: movement direction\n\n Returns:\n [0F]: untouched, or 0\n\n\n Look for a tile object among objects 1 to 12 that can block\n the player's movement.\n
P:6143:: Block
P:6147:: Rock
P:614B:: Gravestone
P:614F:: TODO: Armos1?
P:6151:: If it doesn't match any, go check the next object.
P:6157:: If not active, go check the next object.
P:6159:: If X distance between Link and the object >= $10, skip it.\n
P:6165:: If Y distance between Link and the object >= $10, skip it.\n
P:6168:: First, adjust Link's position.
P:6174:: Link is near the object. Reset movement direction.\n
P:617C:CheckPowerTriforceFanfare: If the fanfare is not active, then return.\n
P:6181:: When Link's timer expires, go finish up the fanfare.\n
P:6185:: While Link's timer is counting down, every 4 frames, switch\n between the level palette and the white palette.\n
P:6187:: Redundant check of Link's timer that won't branch.\n
P:619D:: The fanfare is done.\n
P:61A0:: Play the song for level 9 again.
P:61AB:: Make Link idle and not halted.
P:61AD:: Flag the fanfare not active.
P:61B1:TakePowerTriforce
P:61B4:: Halt Link for $C0 frames.\n
P:61BD-61C4:_UnknownPaletteTransferRecord
P:61C5-61CD:_UnknownColorTriples
P:61D6:_ReplaceAshesPaletteRow
P:61DA:: Get the dynamic transfer buf length, so we write from were we last wrote.\n
P:61DD:: Copy the palette row 7  transfer record to dynamic transfer buf (8 bytes).\n
P:61EB:: Update the dynamic transfer buf length.\n
P:61F0:: TODO:\n Replace the last 3 color bytes (brown shades) that we just\n copied to the dynamic transfer buf with ... (are they colors\n for the pile of ashes?)\n\n Note that here the dynamic transfer buf is being written with\n absolute offsets, instead of relative ones used in copying\n the base palette row transfer record.\n
P:61FC:: Switch back to the current object slot.\n
P:621B-621E:LinkToSquareOffsetsX
P:621F-6222:LinkToSquareOffsetsY
P:6223:_CheckPassiveTileObjects: Returns:\n X: 0\n\n\n If grid offset <> 0 or input direction = 0, return.\n
P:622D:: Compare the collided tile with tiles $BC to $C3.\n These are tiles for gravestone and armos squares.\n
P:622F:: [02] holds the collided tile.
P:6242:: We'll be computing the location of the square.\n Start with Link's location.\n
P:6244:: [00] holds X coordinate
P:6248:: [01] holds Y coordinate
P:6250:: Link is facing vertically.\n\n If Link touched the left side of the square with the right side\n of his body, then add 8 to X.\n\n If Link touched the right side of the square with the left side\n of his body, then bitwise AND'ing with $F0 will align X with the square.\n
P:6265:: Link is facing horizontally.\n\n If Link touched the top of the square with the bottom\n of his body, then add 8 to Y.\n
P:6271:: Look for an empty slot to instantiate a monster in.\n If none was found, then return.\n
P:6276:: When dealing with objects, X usually indicates the slot number\n of the object. Set it to the empty slot found.\n
P:6278:: Offset the coordinates we calculated by a square length\n in the direction Link is facing.\n\n Set the new object's location to them.\n
P:628D:: TODO: ?\n
P:6292:: Because armos and flying ghini fade into existence over a little time,\n see if one is already beginning to appear at that location.\n Don't instantiate another one, if there is.\n
P:6294:: [03] holds the index of the slot to compare to the empty one.
P:6298:: Skip the empty slot we found. So go decrement index [03].
P:629F:: If there's no other object at this X, go try another.
P:62A6:: If there's no other object at this Y, go try another.
P:62AB:: If there's truly an object there, return without instantiating an object.
P:62B0:: If there was an initialized object at that location, return.
P:62B2:: If there was never an object there, go instantiate one.
P:62B7:: Choose the right object type for the tile.\n\n\n Armos
P:62B9:: [02] collided tile
P:62BD:: If tile >= $C0, then instantiate an armos.
P:62BF:: Flying Ghini
P:62C4:: TODO: ?\n
P:62C7:: Fade in for $3F frames.
P:62CB:: Restore player index in X.
P:62CE-62D7:_RupeeStashXs
P:62D8-62E1:_RupeeStashYs
P:62E2:InitRupeeStash_Full: When initializing, this object makes other objects that\n each have the same object attributes and type as this one.\n
P:62E5:: [01] holds object attributes
P:62E9:: [01] holds object type $35 (rupee stash)
P:62EB:: Loop over $A rupee stash objects to make\n -- each one now representing an individual rupee\n
P:62F0:: Look up and set the coordinates for one rupee stash/rupee.\n\n MULTI: A2CE-1\n
P:62F5:: MULTI: A2D8-1\n
P:62FE:InitOneSimpleObject: Params:\n [00]: object type\n [01]: object attributes\n
P:630E-6313:TrapXs
P:6314-6319:TrapYs
P:631A:InitTrap_Full: Copy this parent/generator object's attributes to [01].\n
P:631F:: Assume we're initializing trap object type $49 that makes 6 traps.\n
P:6321:: The individual trap objects to make will be of type $49.\n Store it in [00].\n
P:6325:: If the object type we're initializing is not $49 (as in it's $4A),\n then we'll make 4 traps.\n
P:632C:: Loop over each trap to make, from the last index (5 or 3) to 0.\n
P:632E:: Add the loop index to the current object slot, and switch the X register to it.\n
P:6332:: Look up and set the location for this iteration's individual trap.\n
P:6344-6349:TrapAllowedDirs
P:634A:UpdateTrap_Full
P:634E:: State 0. Sensing.\n\n If the absolute vertical distance between Link and the trap >= $E,\n then go see if the horizontal distance is shorter.\n
P:635A:: Determine the horizontal direction toward Link;\n and if Link and the trap are at the same X, then we can't move\n along this axis. Go see about moving vertically.\n
P:6366:: Remember the original X coordinate.\n
P:636B:: Set facing direction to the horizontal one that we determined.\n
P:636E:: If the direction we determined is not allowed for this trap, then\n go draw and check collisions.\n\n MULTI: A344-1
P:6373:: Advance to state 1 with q-speed $70 (1.75 pixels a frame) (fast).\n
P:637D:: If the horizontal distance between Link and the trap >= $E,\n then this trap definitely wasn't triggered.\n Go draw and check collisions.\n
P:6389:: Determine the vertical direction toward Link;\n and if Link and the trap are at the same Y, then we can't move\n along this axis. Go draw and check object collisions.\n
P:6395:: We'll advance to state 1. Go remember the original Y coordinate,\n set the vertical direction we determined, and other preparations.\n
P:6399:: State 1 and 2.\n\n Move in the direction it's facing.\n
P:63A0:: Truncate the grid offset to square length ($10).\n
P:63AA:: The trap cannot be harmed. So, only check for collision with Link.\n
P:63AD:: If moving horizontally, then set target coordinate in [00] to $78\n and current coordinate to the trap's X.\n
P:63B9:: Else moving vertically. Set target coordinate in [00] to $90\n and current coordinate to the trap's Y.\n
P:63BF:: If in state 2, then go finish handling it.\n
P:63C5:: Finish handling state 1.\n\n Get the distance between the current coordinate and the target.\n
P:63CC:: If distance >= 5, go draw.\n
P:63D0:: Else reverse direction, and advace to state 2\n with q-speed $20 (0.5 pixels a frame) (slow).\n
P:63E1:: Finish handling state 2.\n\n If the current coordinate = original coordinate, then go to state 0.\n
P:63EB:L_Trap_DrawAndCheckCollisions
P:63EE:UpdateRupeeStash_Full: Save the current object slot.
P:63F0:: If Link is not close enough (< 9 pixels in both axes), then\n go draw.\n
P:6408:: Else Link is close enough. Add 1 rupee, and destroy this object.\n
P:640E:: Once you've taken one, it counts as taking them all\n once you leave the room.\n
P:6416:: Draw a rupee.\n
P:6419:: Rupee item slot
P:641B:: Rupee item slot
P:6420:: Restore the current object slot.
P:7FAC:SwitchBank_Local1
P:8012:TransferCommonPatterns
P:8015:: Clear address latch and scroll.
P:8045:: Mark this block copied.
P:8049:: Reset pattern block index.
P:804F:TransferPatternBlock_Bank2
P:9000:InitDemo_RunTasks
P:9020:UpdateMode0Demo
P:9022:: Only animate if submode = 0 and SkippedDemo = 0
P:902C:: If no longer updating,
P:902E:: then return.
P:903B:UpdateMode0Demo_Sub0: If Start is not pressed,
P:903F:: then return.
P:9041::TODO: Else, store $10 in TransferredDemoPatterns. Why?
P:9048:: TODO: ?
P:9050:: Go to next submode.
P:9058:: Queue transfer record for menu palettes.
P:905D:UpdateMode0Demo_Sub2: Copy data from each save file A to save slot info.\n Most of the game will deal with save slot info.\n Format each inactive file A, to make sure it's clear.\n
P:9070:: Save the slot.
P:9072:: Switch to this slot's addresses.
P:907E:: Fetch the address set for slot 0 again,\n so that we can keep referring to its\n IsSaveSlotActive address as a table base.\n\n After this, the slot is still not active, but it will\n definitely be clear.
P:9082:: Restore the slot.
P:9083:: Copy death count from file A to save slot info.
P:9088:: Copy quest number from file A to save slot info.
P:9092:: 0: process hearts value; 1: process heart partial.
P:9094:: Load the hearts value or heart partial from Items block in file A.
P:9096:: Push either value.
P:9099:: If X is even, then the value is a hearts value.\n So, make the hearts equal the heart containers.
P:909B:: Pop what we pushed, because we're going to push\n a modification.
P:90A6:: Push the full hearts value.
P:90A7:: Pop whatever we pushed: heart partial or full hearts value
P:90A8:: Copy to hearts in save slot info.
P:90AB:: Point to the next byte in Items block.\n hearts value -> hearts partial
P:90AC:: Increment the index of the value we check.
P:90AD:: There are 6 values total:\n (hearts value, hearts partial) * 3 slots.
P:90AF:: Once we finish the last value, quit the loop.
P:90B1:: If X is odd, then go process heart partial instead of hearts value.
P:90B5:: The 3 files are consecutive in the set.\n Point to the hearts value in the next slot.
P:90B9:: Go process hearts in the next slot.
P:90BC:: Copy the name from file A to save slot info.
P:90C6:: Go to the next game mode (Menu).
P:90C8:: We're set to initialize the mode.
P:90CF:AnimateDemo
P:90EE-915D:InitialTitleSprites
P:915E:DemoLineAttrs: TODO: How long?
P:9240:DemoLeftItemIds
P:9256:DemoRightItemIds
P:9268:DemoItemColumnX1
P:9269:DemoItemColumnX2
P:926A-9281:DemoStoryFinalSpriteTiles
P:9282-9299:DemoStoryFinalSpriteAttrs
P:929A-94AC:DemoTextFields
P:94AD-94E6:DemoLineTextAddrs
P:94E7:InitDemoSubphaseClearArtifacts
P:94EE-9511:TitlePaletteTransferRecord
P:9512:InitDemoSubphaseQueueTitlePalette: Write a tile buf record for the title palette.
P:9523:: Reset variables used in this phase.
P:9539:: Mark objects 1 to 10 disabled.
P:9542:: Go advance the DemoSubphase and return.
P:9545:InitDemoSubphaseRequestTitleSong: Request the title song.
P:954A:: Select transfer buffer 8 (offset $10 in table):\n title nametables and attributes.
P:954F-9572:StoryPaletteTransferRecord
P:9573:InitDemoSubphaseQueueStoryPalette: Copy the transfer record for the story palette.
P:9584:: Reset variables used in this phase.
P:9597:: Go to the next subphase and return.
P:95A0:: Select transfer buffer 1 (offset 2 in table):\n Story nametables and attributes.
P:95A2:EndInitDemo
P:95AC:AnimateDemoPhase0Subphase0: Animate while we wait about 512 frames.\n
P:95AE:: The timer is incremented every other frame.
P:95BA:: Go advance the demo subphase and return.
P:95C1:AnimateDemoPhase1Subphase0: Increase CurVScroll every odd frame.
P:95C9:: Have we scrolled to the bottom of nametable 2?
P:95CF:: TODO: Set [$0415]
P:95D2:: The bottom of NT 2 is also the top of NT 0.\n So, reset CurVScroll and the base NT.
P:95D8:: Scrolling hasn't ended until we've scrolled to the bottom,\n wrapped around, and scrolled 8 more lines.
P:95EC:AnimateDemoPhase1Subphase1
P:95F4:: Go to the next subphase.
P:95F7:: TODO: Why these values? Why set them every frame?
P:960C:AnimateDemoPhase1Subphase2
P:9619:: Every even frame, just return.
P:961B:: Decrement the Y coordinate of every object.
P:9622:: We scrolled one more line.
P:9628:: Once we've scrolled a whole screen,
P:962A:: Increment the screen count.
P:962D:: Have we scrolled 5 screens?
P:9632:: Scroll the nametable.
P:9634:: Scroll half a screen more.
P:9639:: Scroll the nametable.
P:963B:: Go to the next subphase.
P:963F:: Update vertical scrolling.
P:9645:: If we reached the bottom of the screen,
P:9647:: Switch the base nametable and reset scroll.
P:964D:: 7/8 of the lines,
P:9652:: just return.
P:9654:: But every 8 lines, we have to check for new text and objects.
P:9657:: Queue a request to transfer a line.\n It's blank by default. Change it later.
P:9678:: The next line is 32 bytes farther.
P:967E:: If crossed a page,
P:9680:: then increment high address byte,
P:9683:: and do the next task.
P:9686:: Check if we reached the end of a nametable.\n If we did, then set the address to the top of the other one.\n $2BC0 -> $2000\n $23C0 -> $2800
P:96A7:: Check text and NT attributes.\n
P:96AF:: If attribute $80 isn't set, then leave the line blank.
P:96B8:: Get the address of the current text field.
P:96C2:: The first byte of text field is the offset into the line.
P:96C5:: X is an offset into the destination line.\n Y is an offset into the source tiles of the current record.\n\n Get the next source tile.
P:96CA:: When you reach the end marker, quit.
P:96CC:: Copy to the tile buf.
P:96D6:: Finished processing attribute $80.\n
P:96D9:: Advance to the next line.
P:96DD:ProcessDemoLineAttrs
P:96E5:: If attribute $40 is missing, then return.
P:96E7:: Append a second transfer record.\n This one is for nametable attributes.
P:96F3:: 8 zeroes in VRAM take up 1 byte in record.
P:9702:: TODO: $416?
P:9705:: The next attributes go 8 bytes farther.
P:970E:: Check if we reached the end of nametable attributes.\n If we did, then set the address to the top of the other one.\n $2C00 -> $23C0\n $2400 -> $2BC0
P:972A:DisableFallenObjects: For objects 1..10, indexed by X:\n
P:972C:: Once an object has fallen off the top of the screen,\n disable it.
P:972E:: The Y coordinate where we consider an object\n completely off the screen is $F0.
P:9732:: TODO: Set the corresponding ObjState to $FF.
P:973A:ProcessDemoLineItems
P:9740:: If attribute $20 is present, then instantiate a new object.
P:9745:: Look for the first disabled object.
P:9752:: Allocate an object for the item on the left.
P:9758:: Start at the bottom of the screen.
P:9768:: Link gets a special item ID.
P:976A:: Go center the object horizontally, if it is Link.
P:976C:: Allocate another object for the item on the right.
P:9787:: Special case: The triforce must be centered.\n But it shows up in both column lists.\n Two objects were instantiated, but they'll overlap.
P:978F:: TODO: $430?
P:979D:Demo_AnimateObjects: For each object 1..10, indexed by X:\n
P:97A1:: If the object is disabled, then skip it.
P:97A3:: Save the index.
P:97A5:: Animate the fairy specially.\n
P:97B2:: Animate normal items (type < $30).\n
P:97BC:: At the end of the list of items are special items for Link\n and the sheet of paper.\n
P:97BF:: Restore the index.
P:97D8:AnimateStationaryFairy
P:97DE:: Rely on the fact that 2 represents normal sprite\n attributes with palette 6.\n Shift the value to make it 4.
P:97DF:: Every 4 frames, switch between 2 animation frames.
P:97E3:: Put frame in [$0C].
P:97EA:AnimateDemoStoryFinalItems: The demo story ending objects use special item types.\n The bottom nibble of the item type is an index into two\n tables. Each row has 6 bytes, one for each sprite of the\n item type.
P:97F6:: Y gets offset of each row: (low_nibble & $0F) * 6
P:97F7:: Put ObjY,ObjX in [$00, $01].
P:9801:: For 6 sprites, counted by [$02]:
P:9806:: X gets the offset to the sprite (index * 4).
P:9807:: From this table, get the tile.
P:980A:: If it's zero, skip the sprite.
P:980F:: Write sprite Y.
P:9811:: From this table, get the attributes.
P:981A:: Write sprite X.
P:981F:: Point to the next sprite.
P:9823:: Add 8 to X coordinate.
P:982A:: Increment the sprite index.
P:982B:: Decrement count.
P:9830:AnimateDemoPhase1Subphase3: Delay about 256 frames.
P:983C:AnimateDemoPhase1Subphase4: Delay 56 frames.
P:9846:: Go to phase 0 again, and initialize it.
P:985B:TriforcePaletteTransferRecord
P:9863:TriforceGlowingColors
P:986B:AnimateDemoPhase0Subphase0Artifacts: Set up sprites for the title.\n Copy initial sprite data to Sprites area.
P:9879:: When you reach the end of the glow cycle,\n Queue a transfer record for the trifoce palette.
P:9889:: Patch the palette record with the color\n for the current point in the cycle.
P:9892:: Restart the glow timer.
P:9897:: Advance the glow cycle.
P:989D:: When the glow cycle finishes,
P:98A1:: delay a twice as long for one step of the cycle.
P:98A6:: Restart the glow cycle.
P:98AF-98B2:WaterfallWaveTiles
P:98B3-98B6:WaterfallCrestTiles
P:98B7-98BA:WaterfallSpriteXs
P:98BB-98BD:WaterfallWaveSpriteOffsets
P:98C3:UpdateWaterfallAnimation
P:98C8:: Initialize animation values.
P:98F5:UpdateSpritesForWaterfallWave: Add 2 to current waterfall wave Y.\n But keep it in the range $B2..$E3.
P:9907::Keep a copy of the new value in [$05].
P:9909:: Depending on the Y coordinate of the wave,\n modify the animation state.\n\n < $B9, use tile offset 0\n < $C2, use tile offset 8\n else, use tile offset $10
P:9919:: Keep a copy of the wave index in [$02].
P:991B:: Y gets offset of first sprite in current wave.
P:991E:: For each sprite (4) in current wave, indexed by X:
P:9920:: Get base tile for current sprite.
P:9924:: Modify the tile according to the current state of the wave.
P:9929:: Set sprite X to each part of wave in a row.
P:992F:: Set sprite Y to rolling value.
P:9934:: Set sprite attributes: normal with palette 4.
P:9939:: Advance to the next sprite.
P:9940:: Put the wave index in X again.
P:9943:UpdateSpritesForWaterfallCrest: For each sprite (4) in crest, indexed by X:
P:9947:: Every 16 frames, switch between\n the two frames of animation.
P:9951:: The Y coordinate is fixed in place.
P:9956:: Set sprite X to each part of crest in a row.
P:995C:: Set sprite attributes: normal with palette 4.
P:9961:: Advance to the next sprite.
P:9969-9B28:DemoPhase0Subphase1Palettes
P:9B69:DemoPhase0Subphase1Delays
P:9B79:AnimateDemoPhase0Subphase1: When subphase timer expires,
P:9B7C:: go update animation only.
P:9B7E:: Calculate the address to the palette to transfer.\n Addr = DemoPhase0Subphase1Palettes + (DemoPhase0Subphase1Palettes * $20)
P:9B98:: Set up the header of the transfer record.
P:9BA7:: Put an end marker at the end.
P:9BAE:: Copy the chosen palette into the transfer record.
P:9BB6:: Advance the subphase cycle.
P:9BB9:: Set the timer to the delay for the current point in the cycle.
P:9BC4:: If we reached the end of the cycle,
P:9BC6:: Advance to the next demo phase.
P:9BC9:: Reset the demo subphase.
P:9BCE:: We have to initialize the new demo phase.
P:9D00:SaveFileBAddressSets
P:9D2A:FetchFileBAddressSet: Calculate the end of the address set for current file.
P:9D35:: Copy the file address set (14 bytes) for the current\n save file to [$C0] to make it easier to work with.
P:9D41-9D5D:ModeFTitleTransferBuf
P:9D5E-9D6F:ModeFTitlePatchRegister
P:9D70-9D7A:ModeFSaveSlotTemplatePatchRegister
P:9D7B-9DAE:ModeFSaveSlotTemplateTransferBuf
P:9DAF-9DB2:ModeEandFSlotCursorYs
P:9DB3-9DDE:ModeE_CharMap
P:9DDF-9DE7:SlotToInitialNameCharTransferHeaders
P:9DF7-9E01:ModeEandFCursorSprites
P:9E02-9E07:ModeE_CharBoardYOffsetsAndBounds
P:9E0B-9E0D:SlotToNameOffset
P:9E0E-9E10:SlotToInitialNameCharTransferHeaderEndOffsets
P:9E11:InitModeEandF_Full
P:9E1D:: Go handle submodes 1 and up.
P:9E1F:: Submode 0:\n
P:9E22:: Format all file B's.\n
P:9E30:: Reset CurSaveSlot.
P:9E34:: Copy the title tiles to the dynamic transfer buf.
P:9E43:: If in mode E, overwrite "ELIMINATION MODE" with "REGISTER YOUR NAME".
P:9E52:: Record the length of the transfer buf.
P:9E5E:: Submode 1:\n\n Copy ModeFSaveSlotTemplateTransferBuf to dynamic transfer buf.
P:9E69:: Overwrite payload of a dynamic transfer record with a name.
P:9E6D:: The names are all arranged one after another.
P:9E78:: If copied the whole name,
P:9E7A:: Skip the header for the next transfer record.
P:9E7F:: If there are more names to write, go write the next one.
P:9E85:: If in mode E, overwrite "ELIMINATION" with "REGISTER".
P:9E97:: Go record the length of the transfer buf, and advance the submode.
P:9E9B:: Go handle submode 3 and 4.
P:9E9D:: Submode 2:\n\n Cue a transfer of ModeFCharBoardTransferBuf.
P:9EA4:: Submode 3:\n
P:9EA6:: Go handle submode 4.
P:9EA8:: In mode $E, use $15 for cursor color.
P:9EB0:: In mode $F, use $30 for cursor color.
P:9EB2:: Replace byte 1 of row 3 of sprite palette in transfer buf\n TileBufSelector=$12.
P:9EB7:: Go cue transfer of menu palettes and advance submode.
P:9EB9:: Submode 4:\n
P:9EBD:: If in mode E,
P:9EBF:: Then look for the first slot that's inactive.
P:9ECB:: Found one. Quit the loop.
P:9ECE:: Loop again. If not found, then CurSaveSlot will be 3 (out of bounds).
P:9ED7:: If we're at the "end" option, then hide the char-board cursor.
P:9EDE:: The X of Link objects is $50.
P:9EE2:: The base Y of Link objects is $30.
P:9EEB-9EEF:ZeldaString
P:9EF0:UpdateModeERegister: If didn't press Start,
P:9EF6:: or didn't select "End" option,
P:9EFC:: then go handle idle time.
P:9EFF:: Pressed Start over "End" option.\n\n Silence tune channel 2.
P:9F04:: TODO: Reset [$0425].
P:9F07:: TODO: Reset [$0423].
P:9F0A:: Reset CurSaveSlot.
P:9F0C:: X holds the current slot number
P:9F0F:: Mark save file B committed.
P:9F19:: Reset FileBReadyToSave [$0426].
P:9F1C:: Reset checksum for current save file B.
P:9F23:: Save current save slot number.
P:9F28:: Restore save slot number.
P:9F2A:: Copy next character from save slot info to file B.
P:9F30:: TODO: [$0425] (and [$0423])
P:9F37:: If we copied a space, then go advance offsets and check things.
P:9F3C:: If the save slot is active, then go advance offsets and check things.
P:9F3E:: The save slot is not active.\n\n Initialize file B hearts value to 3 heart containers and 2 hearts.
P:9F44:: Initialize file B heart partial to full.
P:9F49:: Initialize file B's max bombs to 8.
P:9F4F:: Save the current save slot number.
P:9F51:: Multiply it by 8 to get offset to current name in save slot info.
P:9F55:: Compare the name to "ZELDA".
P:9F5D:: If there's any mismatch, then skip the rest.
P:9F63:: Go check the next character until the end of "ZELDA".
P:9F65:: Pop and push the slot number, so we can get it into X.
P:9F68:: Set second quest in file B.
P:9F6E:: Restore save slot number.
P:9F70:: Set FileBReadyToSave [$0426].
P:9F77:: Set IsSaveSlotActive in file B.
P:9F79:: TODO: Point to the next char in save slot info name.
P:9F7C:: TODO: Point to the next char in save file B name.
P:9F7F:: TODO: [$0425]
P:9F84:: If we haven't copied 8 characters from save slot info name, then go copy the next one.
P:9F86:: Make X refer to the next slot.
P:9F87:: Reset the offset to the next save file B char.
P:9F89:: TODO: [$0425]
P:9F8F:: If FileBReadyToSave [$0426] is set, then calculate and store the file B checksum, and mark file B uncommitted.
P:9F94:: Advance the slot number.
P:9F9A:: If haven't processed 3 slots,
P:9F9C:: then go process the next one.
P:9FA1:: Reset FileBReadyToSave [$0426].
P:9FA4:: Reset CurSaveSlot.
P:9FA9:: Make sure we stay updating.
P:9FAD:: Go to mode 0 submode 1.
P:9FB0:: Handle idle time in mode $E.\n
P:9FB4:: If a slot is chosen,
P:9FB6:: then we can check the direction buttons.
P:9FC5:UpdateModeFElimination
P:9FC9:: If Start wasn't pressed,
P:9FCB:: Then go handle other buttons and idle time.
P:9FCE:: Start was pressed.\n
P:9FD2:: If a slot was chosen, then go delete it.
P:9FD4:: "End" was chosen. So, go to mode $E.
P:9FDE:ModeE_ResetVariables: Assumes that zero is passed in A.\n\n Reset CharBoardIndex [$041F].
P:9FE1:: Reset InitializedNameField [$0420].
P:9FE4:: Reset NameCharOffset [$0421].
P:9FEA:: TODO: ?
P:9FF2:: Copy the appropriate transfer buf of a blank name for\n current slot to dynamic transfer buf.
P:A007:: Clear the name in save slot info.
P:A011:ModeE_HandleDirections
P:A013:: Filter and keep direction buttons.
P:A015:: If no button is down, then reset repeat state.
P:A017:ResetButtonRepeatState
P:A025:: If we weren't holding a button last frame,
P:A027:: Store current buttons down.
P:A02A:: Now we definitely are holding a button.
P:A034:: If it's not the same button as before,
P:A036:: then reset repeat state.
P:A03E:: Once the repeat timer reaches zero, handle the direction button again.
P:A040:: Otherwise, only count down the timer.
P:A044:: If this is the first button press, then wait $10 frames\n to repeat; otherwise wait 8 frames.
P:A058:: Pressed Right.\n\n Increase CharBoardIndex [$041F] to put cursor at character to the right.
P:A05B:: Move the char board cursor right one spot.
P:A064:: If still on the board, then go finish.
P:A066:: Otherwise, move the cursor to the left end.
P:A06A:: Cycle down.
P:A072:: If wrapped around to the top,
P:A074:: then reset CharBoardIndex [$041F].
P:A079:: Go finish.
P:A080:: Pressed Left.\n\n Decrease CharBoardIndex [$041F] to put cursor at character to the left.
P:A083:: Move the char board cursor left one spot.
P:A08C:: If still on the board, then go finish.
P:A08E:: Otherwise, move the cursor to the right end.
P:A092:: Cycle up.
P:A09A:: If wrapped around to the bottom,
P:A09C:: then set CharBoardIndex [$041F] to the last index.
P:A0A1:: Go finish.
P:A0A8:: Pressed Down.\n\n Increase CharBoardIndex [$041F] by $B (one row down).
P:A0B1:: Cycle down.
P:A0B9:: If didn't wrap around, then go finish.
P:A0BB:: Wrapped around. So, move CharBoardIndex [$041F] to top row.
P:A0C4:: Go finish.
P:A0C9:: If no single direction was pressed, then return.
P:A0CB:: Pressed Up.\n\n Decrease CharBoardIndex [$041F] by $B (one row up).
P:A0D4:: Cycle up.
P:A0DC:: If didn't wrap around, then go finish.
P:A0DE:: Wrapped around. So, move CharBoardIndex [$041F] to bottom row.
P:A0EC:: Request "selection changed" tune (same as rupee taken).
P:A0F0:CycleCharBoardCursorY: X: 0 for down, 3 for up.\n Return ModeE_WrappedAroundBoardY [$042A]=1 if wrapped arounnd.\n\n Assume we don't wrap around.
P:A0F2:: Move the char board cursor Y one spot in given direction.
P:A0F5:: TODO: Add $10 or -$10 ($F0), depending on X passed in (0 or 3).
P:A0FA:: Look at boundaries.
P:A0FE:: If we didn't reach the boundary, then return Y=0.
P:A100:: Set cursor Y to wrapped around position.
P:A106:: Return ModeE_WrappedAroundBoardY [$042A]=1.
P:A10B:ModeE_HandleAOrB: InitializedNameField [$0420]
P:A10E:: If InitializedNameField [$0420] is set, then skip initializing\n the name field.
P:A114:: If at the "End" option, then return.
P:A116:: Set NameCharOffset [$0421] to the offset of first char\n in the current slot's name.
P:A11C:: Get the offset of the end of the initial name character\n transfer record header for the current slot.
P:A11F:: Each transfer record header is 3 bytes.
P:A124:: Copy a byte of transfer header for current slot to [$0422][Y].
P:A12B:: Set InitializedNameField [$0420] to mark the name field initialized.
P:A12E:: At this point:\n - NameCharOffset [$0421] holds the offset of the first character in the save slot info name for the current slot.\n   - This will be changed as the player inputs characters.\n - [$0422] to [$0424] hold a transfer record header. The VRAM address points to the beginning of the appropriate name field in the nametable.\n   - This will be changed as the player inputs characters.\n - InitializedNameField [$0420] is set to 1.\n
P:A132:: If neither A nor B was pressed, then go finish.
P:A134:: A or B was pressed.\n
P:A136:: If B was pressed, then go move the name cursor only.
P:A138:: A was pressed.\n\n Request to play the character click tune (same as bomb set).
P:A13D:: Copy our char transfer record header (in [$0422-0424]) to dynamic transfer buf.
P:A148:: Write the end marker to dynamic transfer buf.
P:A14B:: Get NameCharOffset at [$0421].
P:A14E:: CharBoardIndex in [$041F] will index into character map.
P:A151:: Get the character that's highlighted.
P:A154:: Write the chosen character to dynamic transfer buf.
P:A157:: Set the character in the name.
P:A15A:: Move name cursor right 8 pixels.
P:A161:: Increment NameCharOffset [$0421].
P:A164:: Increment the low VRAM address where next char will go.
P:A167:: If VRAM address still points inside the name field,\n then go finish.\n\n The idea is that each name field in nametable begins at\n an address ending in $E. For example, slot 0 has a name\n at VRAM addresses $20CE to $20D5.\n\n Once the $E becomes a 6, we've gone past the end of\n the name field.
P:A170:: The VRAM address now points outside the name field.\n So, wrap around to the beginning of the name field.\n\n For example, $20D6 -> $20CE.
P:A179:: It also means that we went past the end of the save slot\n info name. Set the offset to the beginning of the name.
P:A17E:: NameCharOffset [$0421].
P:A181:: If the name cursor has gone past the end of the field,\n then wrap around.
P:A18B:: Go set the name cursor sprite X.
P:A18E:ModeEandF_SetUpCursorSprites: Copy almost 3 sprite records ($B bytes) to byte 1 of\n Sprites block. Only sprite 0 byte 0 is missing.\n These are the cursor sprites.
P:A199:: Set the Y of the slot cursor sprite (#0) according to current save slot.
P:A1A7:: There's more work in mode $E.\n The name cursor position is held in ObjX/ObjY[0].\n The char-board cursor position is held in ObjX/ObjY[1].
P:A1A9:: Use a heart tile for the slot cursor sprite (#0).
P:A1AE:: Because the visible part of the cursor block sprite is\n in the bottom, move the name cursor's sprite 8 pixels\n above its ObjY.
P:A1B6:: The base name cursor X is $70.
P:A1BA:: The base char-board cursor Y is $87.
P:A1BE:: The base char-board cursor X is $30.
P:A1C3:ModeEandF_WriteNameCursorSpritePosition
P:A1C5:: If name cursor Y corresponds to a save slot,
P:A1C7:: then go write the appropriate Y to name cursor sprite.
P:A1C9:: else hide name cursor.
P:A1D1:: This returns the adjusted coordinate or $F8 to hide it.
P:A1D4:: Set name cursor sprite Y.
P:A1D9:: Set name cursor sprite X.
P:A1DD:ModeEandF_WriteCharBoardCursorSpritePosition
P:A1DF:: If name cursor Y corresponds to a save slot,
P:A1E1:: then go write the appropriate Y to char-board sprite.
P:A1E3:: else hide char-board sprite.
P:A1EE:: Set char-board cursor sprite Y.
P:A1F3:: Set char-board cursor sprite X.
P:A1F7:ModifyFlashingCursorY: Adjust the Y coordinate to account for the visible part of\n block cursor being in the bottom half of sprite.\n Also, make the cursor flash.\n
P:A1FB:: Every 8 frames, put the Y off screen.
P:A204:UpdateModeEandF_Idle
P:A208:: If Select was not pressed, then return.
P:A20A:: Request to play the selection tune (same as rupee taken).
P:A20F:: Choose the next slot.
P:A215:: If went out of bounds, then wrap around.
P:A21B:: Set sprite Y for new selection.
P:A225:: If in mode $F, then return.
P:A227:: Move name cursor down $18 pixels.
P:A22E:: If we're past the "End" option,
P:A232:: then wrap around.
P:A236:: It seems that this should be Sprites+4.
P:A239:: Name cursor X is $70.
P:A242:: Reset InitializedNameField [$0420].
P:A245:: Reset NameCharOffset [$0420].
P:A24C:: If selection is "End" option, then return.
P:A251:: If the slot is not active, then cycle again.
P:A254-A273:Mode1SlotLineTransferBuf
P:A274-A286:Mode1DeathCountsTransferBuf
P:A287-A289:LinkColors
P:A28A:InitMode1_Full
P:A2A0:UpdateMode0Demo_Sub1: For each save slot:\n   If file B is uncommitted and valid, then\n     Copy file B to file A (also marks file B committed)\n   If file A's static markers or wrong or file is invalid, then\n     Format file A\n\n TODO: This is also mode 1 submode 0 init.\n
P:A2A3:: Reset CurSaveSlot.
P:A2A5:: For every save file B (3):
P:A2B8:: Does the checksum match?
P:A2C5:: If not, then go check save file A.
P:A2CA:: Go process the next slot.
P:A2CD:: Calculate the checksum of the save file.\n It's only a sum.
P:A2D5:: Are the static markers intact?
P:A2E1:: If not, then go format the file.
P:A2E7:: Does the checksum match?
P:A2F4:: If not, then format the file.
P:A2FC:: Advance to the next save slot.
P:A304:: After checking every file, go to the next submode.
P:A307:CalculateFileAChecksum: Reset the sum.
P:A30D:: Sum the name (8 bytes).
P:A317:: Add the Items block ($28 bytes) to [$0F:0E].
P:A321:: TODO: Put $0180 in [$01:00].
P:A329:: TODO: Add $180 bytes from [[$02:03]] to [$0F:0E].
P:A340:: IsSaveSlotActive
P:A345:: TODO: Add byte at [[$08:09]] to [$0F:0E].
P:A34A:: DeathCount
P:A34F:: QuestNumber
P:A351:_AddATo0F0E
P:A35D:FormatFileA
P:A35F:: Make the name 8 spaces.
P:A366:: Reset the file's Items block.
P:A36F:: TODO: Put $0180 in [$01:00].
P:A377:: TODO: Reset $180 bytes at [[$02:03]].
P:A38F:: Reset the file's IsSaveSlotActive.
P:A391:: TODO: Reset byte at [[$08:09]].
P:A393:: Reset the file's DeathCount.
P:A395:: Reset the file's QuestNumber.
P:A39F:: Be proactive and reset these values in save slot info.\n
P:A3AA:: Since file A is in a good state, we don't care about file B.\n Treat it as committed.
P:A3AF:: Store the static markers in the save file.
P:A3B9:: Store the checksum in the save file.
P:A3C8:CalculateAndStoreFileBChecksumUncommitted
P:A3CD:: Now file B is valid, but uncommitted.
P:A3E1:CalculateFileBChecksum: Reset the sum.
P:A3E7:: Sum the name (8 bytes).
P:A3F1:: Sum the $28 bytes of the file's Items block with [$CF:CE].
P:A3FB:: TODO: Put $0180 in [$C1:C0].
P:A403:: TODO: Add $180 bytes from [[$C2:C3]] to [$CF:CE].
P:A41A:: Add IsSaveSlotActive byte to [$CF:CE].
P:A41F:: Add DeathCount byte to [$CF:CE].
P:A424:: TODO: Add byte at [[$CA:CB]] to [$CF:CE].
P:A429:: Add byte QuestNumber to [$CF:CE].
P:A42B:_AddAToCFCE
P:A437:_InitFileB: Clear the name (to all spaces).
P:A440:: Clear $28 bytes of the Items block in file.
P:A449:: TODO: Put $180 at [$C1:C0].
P:A451:: TODO: Clear $180 bytes at [[$C2:C3]].
P:A467:: Clear individual bytes.
P:A469:: IsSaveSlotActive
P:A46B:: TODO: ?
P:A46D:: DeathCount
P:A46F:: QuestNumber
P:A474:: Leave the checksum at [$CF:CE].
P:A47B:: Mark this file B committed.
P:A47F:InitMode1_Sub1: Reset CurSaveSlot. Doing this is useful for the\n work done here, and for the sequence of submodes\n that generate and transfer save slot graphics.
P:A486:: The ring is at this offset in Items block.
P:A488:: The offset to the byte we want to change in a palette.
P:A48A:: Save ring offset in Items block of current slot.
P:A48C:: Get the ring inventory value.
P:A48F:: Get the color for that ring level.
P:A492:: Put the color in the byte 2 of row for current slot in\n sprite palette that will be transferred.
P:A495:: Restore ring offset.
P:A497:: Point to the ring in the next save slot.
P:A49C:: Point one row down in palette.
P:A4A1:: 3 times.
P:A4A3:: TODO: ?
P:A4A6:: Cue transfer of menu palettes.
P:A4B3:: TODO: $529?
P:A4BD:InitMode1_Sub2
P:A4C4:InitMode1_FillAndTransferSlotTiles: Copy the mode 1 line transfer buf template to\n dynamic transfer buf.
P:A4CF:: The first time, this is reset in a previous submode.
P:A4D1:: Add ($60 * CurSaveSlot) to the PPU address of each record in the buffer.
P:A4F1:: Copy name for current slot to beginning of payload\n of first record in dynamic transfer buf.
P:A505:: Copy heart values from current save slot info\n to [$0E:0F] for formatting.
P:A519:: Next time, process the next slot.
P:A51E:InitMode1_Sub6: Copy the mode 1 death counts transfer buf template to\n dynamic transfer buf.
P:A52B:: The save slot.
P:A52F:: The offset where the string will be written in dynamic transfer record.
P:A53D:: Emit the first character.
P:A542:: Emit the second character.
P:A547:: If the third character isn't '0', then go emit it.
P:A549:: If the first or second characters weren't spaces,\n then go ahead and emit the '0'.
P:A55A:: If this slot isn't active,
P:A55E:: Go emit a space.
P:A560:: Else, emit a '0'.
P:A565:: Advance the offset by 6,
P:A566:: to the starting position in the next transfer record.
P:A56B:: Increment the save slot.
P:A571:: Go process the next slot, if not done.
P:A573:: Find the first save slot that's active.
P:A577:: Use room ID $FF, so that mode 3 "Unfurl" will put the player in the room at StartRoomId.
P:A586:: Start updating.
P:A589-A58B:Mode1CursorSpriteTriplet
P:A58C-A590:Mode1CursorSpriteYs
P:A591:UpdateMode1Menu
P:A59A:UpdateMode1Menu_Sub0
P:A59E:: If Start was pressed, the go to the next submode.
P:A5A4:: If Select was pressed,
P:A5A6:: Request to play the selection change SFX (same as rupee taken).
P:A5AB:: Select the next slot or option.
P:A5B1:: If the index is out of bounds,
P:A5B3:: then wrap around to zero.
P:A5B9:: Since CurSaveSlot is used to index menu choices, which\n includes register and eliminate in addition to save slots;\n the IsSaveSlotActive array includes elements at the end\n for these options.
P:A5BC:: If option or save slot isn't active, then go advance the index.
P:A5BE:: Write the tile, attributes, and X for the sprite record.
P:A5CE:: Set the sprite Y for current option.
P:A5D1:: The base Y of Link sprites is $58.
P:A5D5:: The X coordinate of Link sprites is $30.
P:A5DF:UpdateMode1Menu_Sub1: TODO: Turn off music2.
P:A5E6:: Begin in OW.
P:A5E8:: Reset item index.
P:A5F2:: If not a save slot,
P:A5F4:: Go to the mode for each option (register, eliminate).
P:A5FE:: The player chose a save slot.\n
P:A604:: Copy Items block from file A to profile.
P:A60E:: TODO: ?
P:A613:: Reset player state.
P:A615:: Reset clock item.
P:A618:: Copy WorldFlags block from file A to profile.\n
P:A633:: If not done (destination address < $07FF), then copy more.
P:A638:Mode1_WriteLinkSprites: Put the left tile of Link in [$02].
P:A63C:: Put the right tile of Link in [$03].
P:A640:: [$04] is used as an index and sprite attributes.\n It takes on values 0 to 2.\n As an index, it represents a save slot.\n As attributes, these values represent palettes 4 to 6.
P:A645:: We want to start with sprite 4 (offset $10).\n Begin with 8, so that the loop will add 8 and\n put us at the offset we want.
P:A64E:: Each Link is two sprites (8 bytes).
P:A654:: The right side is the next sprite.
P:A659:: This object has two sides (sprites).
P:A65D:: The two sides are 8 pixels apart.
P:A661:: Save the X coordinate.
P:A664:: We didn't set [$08]. But we don't care if CurSpriteIndex is cycled.
P:A668:: Restore the X coordinate.
P:A66B:: Use [$04] as a save slot number.
P:A670:: If in first quest, then skip the second quest marker.
P:A675:: Put the sword 3 pixels below Link.
P:A67A:: Use sprites $20 to $23 for the swords.
P:A67D:: Use sword tiles.
P:A682:: Use palette 7.
P:A687:: Put the sword $C pixels to the right of Link.
P:A68F:: Move Y down for the next slot.
P:A696:: Look at the next slot, and use the next palette.
P:A69E:: If we're not done, then look at the next slot.
P:A6A1-A6A3:SaveSlotHeartValuesAddrsLo
P:A6A4-A6A6:SaveSlotHeartsValueAddrsHi
P:A6A7-A6A9:ProfileNameAddrsLo
P:A6AA-A6AC:ProfileNameAddrsHi
P:A6AD:UpdateModeDSave
P:A6B8:UpdateModeDSave_Sub0: Initialize file B, and copy profile to it.\n Calculate and store file B checksum.\n Mark file B uncommitted.\n
P:A6C1:: TODO: I think this is called only for $067F put in [$0E:0F].
P:A6C4:: Copy Items block ($28 bytes) from profile to file B.
P:A6D0:: Copy death count from profile to file B.
P:A6D7:: We're saving, so make sure the current slot is active.
P:A6DD:: Also set the slot active in the save slot info.
P:A6E0:: Copy quest number from profile to file B.
P:A6EA:: Copy name from save slot info to file B.
P:A6F3:: Put in [$0A] a full hearts value for the profile's heart containers.
P:A705:: Completely fill the hearts.
P:A70D:: TODO: Copy $180 bytes from profile to file B.
P:A731:: Go to the next submode.
P:A734:UpdateModeDSave_Sub1
P:A754:: The checksum matches, so commit and copy file B to A.
P:A75A:: Discard file B, because it couldn't be validated.\n
P:A764:CopyFileBToFileA
P:A766:: Reset the save file markers.
P:A76E:: Reset the checksum.
P:A77D:: TODO: This puts $067F in [$0E:0F].
P:A780:: Copy Items block ($28 bytes) from file B to file A.
P:A789:: Copy these individual bytes from file B to file A.
P:A78B:: IsSaveSlotActive
P:A78F:: TODO: ?
P:A793:: DeathCount
P:A797:: QuestNumber
P:A79B:: Push IsSaveSlotActive from file A to help copy it to save slot info.
P:A79E:: Push death count from file A to help copy it to save slot info.
P:A7A1:: Push quest number from file A to help copy it to save slot info.
P:A7A6:: Finish copying quest number from file A to save slot info.
P:A7AA:: Finish copying death count from file A to save slot info.
P:A7AE:: Finish copying IsSaveSlotActive  from file A to save slot info.
P:A7B2:: Copy the name from file B to file A.
P:A7BB:: TODO: Copy $180 bytes file B to file A.\n It counts up from what's in [$0E:0F] ($067F) to $07FF.
P:A7E1:: Write the save file markers.
P:A7EB:: Copy the checksum from file B to file A.
P:A7FD:: File B has been committed.
P:A803:UpdateModeDSave_Sub2: Go to mode 0 submode 1. Keep it updating.
P:A80C:FetchProfileNameAddress
P:A819:StoreSaveSlotHearts
P:A825:: TODO: Copy HeartsValue and HeartsPartial to set B.
P:AA10:UpdateMode13WinGame
P:AA23:UpdateMode13WinGame_Sub0
P:AAA9:UpdateMode13WinGame_Sub1
P:AB7F:UpdateMode13WinGame_Sub4
P:ABC4:UpdateMode13WinGame_Sub3
P:BFAC:SwitchBank_Local2
P:C000-C013:LevelPatternBlockSrcAddrs
P:C014-C027:BossPatternBlockSrcAddrs
P:C028-C02B:PatternBlockSrcAddrsUW
P:C02C-C02F:PatternBlockSrcAddrsOW
P:C030-C033:PatternBlockPpuAddrs
P:C034-C037:PatternBlockPpuAddrsExtra
P:C038-C03B:PatternBlockSizesOW
P:C03C-C043:PatternBlockSizesUW
P:C044:TransferLevelPatternBlocks
P:C04F:: Go handle UW levels.
P:C05A:: There are two blocks.
P:C05C:: If we haven't transferred the second, then go do so.
P:C05E:ResetPatterBlockIndex
P:C06F:: If at block index 1, then go transfer the second block.
P:C071:: At this point, we've transferred two common blocks\n (BG and sprites). Now UW, transfer bosses and other\n specialized sprite patterns.\n
P:C080:FetchPatternBlockAddrUW
P:C091:FetchPatternBlockInfoOW: Returns:\n [$00:01]: source address\n [$03:02]: size\n
P:C0AC:FetchPatternBlockAddrUWSpecial
P:C0BC:FetchPatternBlockUWBoss
P:C0CC:FetchPatternBlockSizeUW
P:C0DC:TransferPatternBlock_Bank3: Params:\n [$00:01]: source address\n [$03:02]: size\n\n Look up and transfer destination PPU address by PatternBlockIndex.\n
P:C0EE:: Start copying.
P:C0F0:: Transfer 1 byte from source pattern block in ROM to PPU.
P:C0F5:: Increment source address.\n
P:C102:: Decrement count.\n
P:C10F:: If count is not zero, go copy more.\n
P:C117:: Mark this block finished, and we're ready for the next one.
P:C11B-C93A:PatternBlockUWBG
P:C93B-D15A:PatternBlockOWBG
P:D15B-D87A:PatternBlockOWSP
P:D87B-DA9A:PatternBlockUWSP358
P:DA9B-DCBA:PatternBlockUWSP469
P:DCBB-DDBA:PatternBlockUWSP
P:DDBB-DFDA:PatternBlockUWSP127
P:DFDB-E3DA:PatternBlockUWSPBoss1257
P:E3DB-E7DA:PatternBlockUWSPBoss3468
P:E7DB-EBDA:PatternBlockUWSPBoss9
P:10000:_PlayBossHitCryIfNeeded
P:1000D:_PlayBossDeathCryIfNeeded
P:10015:InitMonsterShot: QSpeed $C0 (3 pixels a second)
P:10019:_InitMonsterShot_Unknown54
P:10025:_InitWalker: If the facing direction was already set, then return.\n
P:10029:: Calculate horizontal distance and direction away from chase target.\n Store the distance in [00].\n
P:10035:: If chase target is to the right of the object, then\n store left (2) in [01], else right (1).\n\n Also, make this the object's facing direction, even though\n it will be clobbered shortly.\n
P:10039:: Calculate vertical distance and direction toward the chase target.\n Make this vertical direction the facing direction.\n
P:10046:: If vertical difference >= horizontal difference, then\n set the facing direction to the horizontal direction in [01].\n\n Note that an unsigned comparison is used, even though\n the values can be considered signed.\n
P:1004F:UpdateStandingFire
P:10052:: Normal sprites and palette row 6 (red)
P:10057:: Up
P:1005E:: If type <> $40, then never use horizontal mirroring. Dead code?\n
P:10069:: Frame image 0
P:1006E:_UpdateCommonWanderer: Params:\n A: turn rate\n\n Set the turn rate. If being shoved, then shove and return.\n
P:10078:: If we have the magic clock or the monster is stunned, then return.\n
P:10094:Wanderer_TargetPlayer: If turn timer <> 0, then decrement it.\n
P:100A4:: If speed = 0, or the object is between squares;\n then go set input direction to facing direction.\n
P:100B0:: Set truncated grid offset.\n
P:100B3:: If turn rate < a random value, or Link's state = $FF;\n then go turn if turn timer has expired.\n
P:100C0:: Get the absolute horizontal distance between\n the monster and the chase target.\n
P:100CC:: If distance >= 9, then go check the vertical distance.\n
P:100D0:: Choose a vertical direction toward the chase target.\n Then go face in this direction, and flag to shoot.\n
P:100DC:: Get the absolute vertical distance between\n the monster and the chase target.\n
P:100E8:: If distance >= 9, then go turn if turn timer has expired.\n
P:100EC:: Choose a horizontal direction toward the chase target.\n
P:100F5:: Set the monster's facing direction to the chosen direction\n toward the chase target.\n
P:100F7:: Set turn timer to a random value.\n
P:100FC:: Set "wants to shoot" flag to 1.\n
P:10101:: Go set input direction to facing direction.\n
P:10104:: Reset "wants to shoot" flag.\n
P:10109:: If turn timer <> 0, then go set input direction to facing direction.\n
P:1010E:: Turn toward the chase target in a direction perpendicular to\n facing direction.\n\n If facing vertically, then go choose a horizontal direction\n toward the chase target.\n\n Else go choose a vertical direction toward the chase target.\n
P:10119:UpdateGoriya
P:1011C:: If not an armos and high bit of state is set, then return.\n This means the monster is delaying after shooting.\n
P:10127:: If not being shoved, then go handle other activities.\n
P:1012C:: If speed = 0 or is between squares, then go try shooting.\n
P:10138:: Store the truncated grid offset.\n
P:1013B:: TODO: Which object gets in this state, and when?\n If state = $FF, go try shooting.\n
P:10141:: Store in [00] the absolute vertical distance between\n the chase target and the walker.\n\n Store in [02] the vertical direction from the walker to\n the chase target.\n
P:1015A:: Store in [01] the absolute horizontal distance between\n the chase target and the walker.\n\n Store in [03] the horizontal direction from the walker to\n the chase target.\n
P:10173:: Whichever distance is longer determines which combination\n of distance and direction will be used.\n\n If the vertical distance is longer, then use index 0.\n Else use index 1 for horizontal distance and direction.\n
P:1017C:: TODO:\n Reset the "wants to shoot" flag.\n
P:10181:: TODO:\n If the distance chosen < $51, then\n set the "wants to shoot" flag to 1,\n and face in the chosen direction.\n
P:10190:_L_SetInputDirectionAndTryShootingBoomerang: Set the input direction to the facing direction.\n
P:10195:: Goriya will throw a boomerang (object type $5C).\n
P:10197:: If the monster is a blue goriya, go check the timer.\n
P:1019E:: If it's not a red goriya either, then return.\n
P:101A2:: If a random value <> $23 nor $77, then return.\n
P:101AC:: Goriya will throw a boomerang (object type $5C).\n
P:101AE:: If object timer <> 0, return.\n
P:101B2:: Store in [00] the type of projectile the monster will throw.\n
P:101B4:: If we have the magic clock, or the monster is stunned, then return.\n
P:101BB:: Try to shoot. Return, if it failed.\n
P:101C2:: Set monster's state to $80 for delaying after shooting.\n
P:101C6:: Reset the "wants to shoot" flag.\n
P:101CB:: Have the shot keep track of the monster.\n
P:101CF:: Have the monster keep track of the shot.\n
P:101D3:: Set the shot's state to $10, which is the flying state for them.\n
P:101D8:: Fly at q-speed $A0 (2.5 pixels a second).\n
P:101DD:: For boomerangs, move up to $51 pixels (horizontally or vertically).\n
P:101E2:: Make it autonomous (ready to update on its own).\n
P:101E7:: The first animation frame lasts 3 screen frames.\n
P:101EC:: Have the monster wait a random amount of time, up to $3F frames.\n
P:101F3-101F6:BlockPushDirections
P:101F7:UpdateBlock
P:10204:UpdateBlock0Idle: If there are monsters in the room, go reset the push timer and return.\n
P:10209:: If Link's X is aligned with the block's, then get the difference\n between Link's (Y + 3) and the block's Y.\n Then go test the difference.\n
P:1021C:: If Link's (Y + 3) is not aligned with the block's Y, then\n go reset the push timer.\n
P:10225:: Link's (Y + 3) is aligned with the block's Y.\n Get the difference in X.\n
P:1022C:: If the difference in coordinates is negative, then Link is\n up or left of the block.\n\n In that case, increase Y register to index the correct opposite\n direction below. Also, negate the difference, so we test\n positive values.\n
P:10232:: If the distance >= $11, then go reset the push timer and return.\n
P:10236:: At this point, Link is aligned with the block.\n\n If the input direction is not the required direction based on\n Link's placement; then go reset the push timer and return.\n
P:1023E:: Link is truly pushing the block.\n\n Increase the push timer.\n
P:10241:: If the push timer still < $10, return.\n
P:10248:: Link has pushed enough.\n Set the block's direction to Link's, set state 1,\n and change tiles at the source to a floor tile.\n
P:1024C:: Switch back to bank 4 when returning from the call below.
P:1024E:: Floor tile tile
P:10253:DrawBlock
P:10256:: Decrement sprite Y, to draw at the object's true Y.
P:10258:: Frame image 0
P:1025D:: Reset the push timer.\n
P:10263:UpdateBlock1Moving: Move in the block's direction, and draw.\n
P:1026D:: If the block has not moved $10 pixels, then return.\n
P:10278:: The block has moved enough.\n Play the "secret revealed" tune.\n Change the tiles at the destination to the block tile.\n Set state 2, and increment BlockPushComplete.\n
P:1027D:: Switch back to bank 4 when returning from the call below.
P:10289:UpdateBlock2Done
P:1028A:HideSpritesOverLink
P:10293:DrawObjectNotMirroredOverLink: Not mirrored
P:10297:DrawObjectMirroredOverLink: Params:\n A: frame image\n\n Mirrored
P:10299:: [0C] holds mirrored flag
P:1029B:: The animation index is (object type + 1) to account for Link\n having two animation indexes.\n
P:1029F:: [0D] holds frame image
P:102A1:: [0E] holds animation index
P:102A3:: [08] holds object index
P:102A5:: Sprite $10: left sprite under Link
P:102AA:: Sprite $11: right sprite under Link
P:102AF:ShootFireball: Params:\n A: object type\n X: shooter's object index\n\n\n [00] holds the object type.
P:102B1:: Return, if there's no empty slot.\n
P:102B6:: Save the shooter's object index.
P:102B8:: Switch to and save the new object's slot.
P:102BF:: Restore the new object's slot.
P:102C1:: Restore the shooter's object index.
P:102C3:: Set the new object's location to the shooter's.\n Offset the new object's X right 4 pixels.\n
P:102D1-102D2:ShotBounceWidths
P:102D3-102D6:ShotBounceHeights
P:102D7:UpdateMonsterShot: Set moving direction to facing direction.\n
P:102DB:: If major state <> 1, go bounce.\n
P:102E3:: If object type < $55 (like flying rock $53), then\n check for tile collision in addition to other checks.\n
P:102EA:: Additionally, if the flying rock is held back by a timer, then\n only check for collision with Link.\n
P:102EE:: If the flying rock hit a tile or room boundary, then go destroy it.\n
P:102F6:: No shots can cross the room boundary.\n
P:102FB:: Move the object, and check for a collision with Link.\n Go destroy the shot object, if there was a harmful collision.\n
P:10301:: Not zero, if collided.
P:10305:_L_DrawShot: If object type = arrow ($5B), then draw an arrow, and return.\n
P:1030F:: If object type = sword shot or magic shot, then go draw, and return.\n
P:1031A:: Prepare to draw other shot types.\n
P:1031D:: [0D] holds frame image 0
P:1031F:: Assume object type >= $55. Prepare sprite attributes that\n make the shot flash.\n
P:10323:: If object type < $55 (flying rock is $53), then\n add 4 to X coordinate, and use sprite attributes 0.\n
P:10336:: [0D] frame image
P:1033B:: Destroy fireballs directly. These are not kept track of.\n
P:10346:DestroyMonsterShot
P:1034C:: Get the reverse direction index for the bounce direction.\n\n TODO: Name: ObjMovingLimit\n
P:10352:: Modify the coordinates according to the displacements for\n the bounce direction.\n
P:10362:: Add 2 to the bounce distance.\n The absolute value of one of the displacements is 2.\n\n TODO: Name: ObjGridOffset\n
P:1036B:: Go destroy the shot, if the bounce counter has reached the limit.\n Otherwise, go draw.\n
P:10371:_CheckShotLinkCollision: Params:\n X: monster object index\n\n Returns:\n [00]: 0 for Link slot\n [06]: 1 if objects collide\n [09]: 0 for Link damage type (none)\n [0C]: 1 if objects collide\n [034B]: ShotCollidesWithLink\n\n TODO: Name: ObjGridOffset\n Reset bounce distance.\n
P:1037E:: If the shot hits Link, then start to bounce off of Link's shield.\n Set the bounce direction to Link's facing direction.\n Set state $30 to bounce.\n\n TODO: Name: ObjMovingLimit\n
P:10388-1038F:FireballQSpeedsX
P:10390-10398:FireballQSpeedsY
P:10399:UpdateFireball
P:1039D:: State 0.\n\n Reset horizontal and vertical position fractions.\n
P:103A3:: Link is the target. So, register A has 0 -- his object slot.\n
P:103A6:: Remember the horizontal and vertical directions toward target.\n
P:103B0:: Set the facing direction to the combination of the two.\n
P:103B9:: Look up and set the horizontal and vertical q-speeds.\n
P:103C5:: Set state to $10: monster shot active.\n Set object timer to $10, so it's seen but delays a little before moving.\n
P:103CC:: State 1.\n\n Fireballs are delayed and visible for a few frames before moving.\n If timer <> 0, go draw.\n
P:103D0:: If the room boundary blocks the fireball, then destroy it.\n
P:103DA:: A movement routine is used that works along one axis.\n So, load its parameters, and call it for each axis individually.\n\n First, load the horizontal direction into [0F].\n
P:103DF:: Load the horizontal q-speed and position fraction,\n move, then save the position fraction.\n
P:103EB:: Second, load the vertical direction into [0F].\n
P:103F0:: Load the vertical q-speed and position fraction,\n move, then save the position fraction.\n
P:103FC:: Check for collision with Link. If hit, then go destroy the fireball.\n
P:10407:Fireball_MoveOneAxis: Params:\n A: q-speed\n Y: position fraction\n [0F]: movement direction\n\n Returns:\n A: position fraction\n\n Load the q-speed and position fraction from the parameters.\n
P:10411:: Return the updated position fraction.\n
P:10415:InitBubble: QSpeed $40 (1 pixel a frame)
P:1041D:InitBlueKeese: Choose one of eight random directions.\n
P:10435:InitRedOrBlackKeese
P:10438:: Red and black keeses are like blue ones, but faster.\n
P:1043E:UpdateBubble: Turn rate $40
P:10446:: If the bubble is not type $2B that temporarily blocks the sword;\n then subtract $2B from the type to get 1 or 2, which\n represent the blue and red palette rows in sprite attributes.\n
P:10450:: Else make it flash by cycling all the palette rows.\n
P:10457:: Animation counter 1 to switch animation frames every screen frame.\n
P:1045F:: If no collision, then return.\n
P:10463:: If not type $2B (flashing), then go block or unblock the sword\n depending on the bubble type.\n
P:1046A:: Else the flashing bubble blocks the sword temporarily.\n Set a long timer to $10 ($A0 frames) for this purpose.\n
P:1046F:: Subtract $2C from the type to get the value for blocking: 0 or 1\n
P:10476:_AnimateAndDrawCommonObject: Params:\n A: new value for animation counter\n X: object index\n
P:10481:UpdateKeese: If the magic clock is missing and Link is not lifting an item,\n then fly.\n
P:10492:: Like peahats, keeses animate as fast as they move.\n But keese beat their wings at half the rate.\n
P:104A1:ControlKeeseFlight
P:104B3:Flyer_KeeseDecideState: Go to the next state randomly:\n Random >= $A0: 2\n Random >= $20: 3\n Else:          4\n\n Set up 6 turns.\n
P:104B9:: If >= $A0, go to state 2.
P:104BE:: If >= $20, go to state 3.
P:104C0:: Else go to state 4.
P:104C1:Flyer_SetStateAndTurns
P:104C5:: Set 6 turns for the next state.
P:104CB:UpdateZol
P:104D4:: Every 8 screen frames, switch between frame image 0 and 1.\n
P:104E1:_UpdateZolState
P:104EC:_UpdateZolState0_Wander: QSpeed $18 (0.375 pixels a second)
P:104F1:_UpdateZolState1_Shove: Move straight and fast until blocked. Then go to state 2.\n
P:104F9:_UpdateZolState2_Split: We'll create two gels, but destroy the zol. So, increase\n the object count by 1 only.\n
P:10502:: If the zol's direction is vertical, then set the first child gel's\n direction to left, else up.\n
P:1050F:: Save the direction of the first gel.
P:10513:: Restore the direction of the first gel.
P:10514:: Set the second child gel's direction to the opposite of the first one's.\n
P:10519:CreateChildGel: Child Gel object type
P:1051B:: Use the shooting operation to create the gel object.\n
P:10520:: Shots start in state $10. But Child Gel needs to start in state 0.\n
P:10525:: Give the child the same grid offset as the parent.\n
P:1052C:_CheckZolCollisions: If not in state 0, then return.\n
P:10530:: Check collisions.\n\n If killed, or got hit but didn't get hurt (invincibility timer = 0),\n then return.\n
P:1053D:: If vertically aligned with the square grid, then\n use a horizontal direction mask (3).\n\n Keep in mind that most objects are aligned vertically when\n the low nibble of their Y is $D.\n
P:1054B:: If horizontally aligned with the square grid, then\n use a vertical direction mask ($C).\n
P:10556:: Combine the two masks. At most one will be 0.\n
P:10558:: The point is to see if the zol is facing in a way that's aligned\n with the grid.\n\n If so, then go to state 1 to do a "big shove".\n Else go to state 2, to immediately split in two.\n\n Examples:\n It would be aligned, if moving left along a tile as usual.\n It would *not* be aligned, if while moving left, it was hit downward.\n - The collision check routines would have made the zol\n   face in the direction of the weapon.\n - See CheckMonsterWeaponCollision.\n
P:10561:InitGel: Gels that aren't split from a Zol begin in state 2.
P:10568:UpdateGel
P:1056E:: Gels are narrow. So, temporarily shift the X coordinate\n 4 pixels to the right.\n
P:10570:: Save the original X coordinate.
P:10579:: Every two screen frames, switch between frame image 0 and 1.\n
P:10582:: Set sprite attributes 3: normal sprite, palette row "level".\n
P:10587:: Pass the frame image in A register.
P:1058B:: Restore the original X coordinate.
P:1058F:_Gel_Move: Go handle state 0 or 2 as appropriate.\n
P:10596:: State 1.\n\n If the timer has not expired, then move.\n
P:1059D:: If not blocked while moving, then return.\n
P:1059F:: Blocked or timer expired.\n\n Set X coordinate to ((X + 8) AND $F0).\n
P:105A8:: Set Y coordinate to (((Y + 8) AND $F0) OR $D).\n
P:105B2:: Reset the grid offset, and go to state 2.\n
P:105BA:: State 0.\n\n Immediately go to state 1 with QSpeed $20 (half a pixel a second),\n and 5 frame timer.\n
P:105C6:: State 2.\n\n Set QSpeed $40 (1 pixel a second).\n
P:105C8:_UpdateNormalZolOrGel: Params:\n A: qspeed\n
P:105CB:: If object timer >= 5, then return.\n
P:105D1:: Turn rate $20
P:105D9:: If the monster is between squares, or timer <> 0; then return.\n
P:105E0:: Choose a random index (0 to 3) to look up an amount of time.\n
P:105E5:: If the monster is Zol, then go use this index as is.\n
P:105EC:: Else it's a gel. Add 4 to the index to look in the set of times\n for Gel.\n
P:105F0:: Set a delay at a tile edge for the next time to move.\n
P:105F6-105FD:_ZolGelDelays
P:105FE:_Gel_MoveSplitting: TODO:\n Or call this BigShove like in Loz?\n\n Returns:\n C: 1 if blocked\n\n Set the speed to maximum.\n
P:10603:: Set moving direction to facing direction.\n
P:10607:: If at a tile boundary, then check for a tile collision.\n
P:1060F:: If blocked by a tile, then return C=1.\n
P:10614:: If blocked by the room boundary, then return C=1.\n
P:1061A:: Move.\n
P:1061D:: Mask the grid offset with $F (to a square length),\n and return C=0.\n
P:10629:_CheckGelCollisions: TODO:\n CheckMonsterCollisions calls GetObjectMiddle which\n overwrites [02] and [03]. So, I don't know why these are set here.\n
P:10634-10635:StatueRoomLayouts
P:10636-10638:StatueFireballCounts
P:10639-1063C:StatueFireballStartTimes
P:1063D-1063F:StatuePatternToBasePositionIndex
P:10640-10647:StatueXs: A list of coordinates divided into sets for each pattern.\n
P:10648-1064F:StatueYs: A list of coordinates divided into sets for each pattern.\n
P:10650:UpdateStatues: If person fireballs are enabled (from the two fires), then\n go make fireballs with pattern 2.\n
P:10657:: Else if the room layout has two or four statues that shoot fireballs,\n then go shoot fireballs with the corresponding pattern in Y register:\n - layout $23: pattern 1: 2 statues\n - layout $24: pattern 0: 4 statues\n
P:10665:: Look for an empty monster slot.\n If none is found, return.\n\n Later, for each fireball, we'll call a routine to make the fireball\n object. This routine takes a shooter object, and instantiates\n a fireball object at the shooter's location.\n\n The object slot we set up here will behave as the shooter.\n For each fireball index, this object slot will have its coordinates\n changed.\n\n Note that this means that:\n 1. The first fireball made will be its own shooter.\n    Practically, there's nothing special about this.\n 2. If there is more than one fireball made in a frame,\n    then two of them will come from the same statue.\n\n\n Save the fireball pattern.
P:1066C:: Restore the fireball pattern.
P:1066F:: If we found a slot, but it < 6, return.\n
P:10673:: Store the object slot in [0A].\n Store fireball pattern in [0B].\n
P:10677:: Look for the number of fireballs to make (minus 1) by pattern number.\n
P:1067B:: For each fireball to make, indexed by X, (1 or 3 down to 0):\n\n Decrement the fireball timer at this index.\n
P:10683:: If it was not 0, then this fireball index has to keep waiting\n to make a fireball. Go loop again.\n
P:10686:: If the random value for this fireball index >= $F0, go loop again.\n This fireball index will wait another $100 frames.\n
P:1068C:: Else choose one of four start times for the fireball based on\n the random value.\n
P:10695:: The coordinate lists are divided into sets for each pattern.\n\n Look up the index of the base of the set for the pattern in use.\n Add it to the fireball index in X register to get the index of\n the coordinate we want within each coordinate list.\n\n\n Pattern
P:1069D:: Save the fireball index.
P:1069F:: Get Link's coordinates into [00] and [01].\n
P:106A4:: Switch to the new fireball's object slot.\n
P:106A6:: Look up and set the X coordinate for the fireball object.\n Also store it in [02].\n
P:106AD:: Look up and set the Y coordinate for the fireball object.\n Also store it in [03].\n
P:106B4:: Set mask value 3 in [04].\n
P:106B8:: Loop to compare each of Link's coordinates to the fireball's.\n Each time the distance < $18, the mask in [04] is shifted right.\n
P:106CE:: If [04] <> 0, then its value is 1 or 3, meaning that it was shifted\n 0 or 1 time, instead of 2.\n\n This, in turn, means that the distance between Link and the\n fireball was >= $18 in at least one axis.\n\n So, we're OK to finish making the fireball.\n
P:106D7:: Restore the fireball index.
P:106D9:: Bottom of the loop.\n Loop while fireball index >= 0.\n
P:106E0:CheckZora: If the zora attribute of this room is off, return.\n
P:106E5:: Zora attribute
P:106E9:: If zora is active, return.\n
P:106EE:: Look for an empty monster slot. If none is found, return.\n
P:106F3:: Loop $D times looking for a water tile to put a zora on.\n Indexed by [0D].\n
P:106F7:: Switch to the new object slot.\n
P:106F9:: Turn the random value at this index into a $10 pixel aligned X coordinate.\n If it = 0 or $F0, go loop again.\n
P:10708:: Turn the random value into a $10 pixel aligned Y coordinate.\n If it < $50 or >= $E0, go loop again.\n
P:10717:: Turn it into a normal object Y coordinate by OR'ing it with $D.\n
P:1071B:: Get the tile at that location.\n If it's not a water tile, then go loop again.\n
P:10726:: Flag the zora active, and set up the object.\n
P:10729:: Zora object type
P:1072E:: Bottom of the loop. Keep going until loop index [0D] = 0.\n
P:10733-10736:_TektiteStartingDirs
P:10737:InitBoulderSet: Reset active boulder count.\n
P:1073C:InitBoulder
P:1073F:InitTektite: Set a random starting direction.\n
P:10749:: Multiply the direction value by 4 to set the object timer.\n
P:1074E:InitLeever: Set red leever long timer to 5, for use in determining when\n to burst out of the ground.\n
P:10755:InitSlowOctorockOrGhini: Assign QSpeed $20 (0.5 pixels a second).\n
P:10759:InitFastOctorock: Assign QSpeed $30 (0.75 pixels a second).\n
P:1075E:: Octorock spawn clouds last longer than other monsters.\n Set object timer to ((object slot + 1) * $10).\n
P:1076A:: Reset movement frame.
P:10775:InitPeahat: Peahats do not use a spawn cloud. Also, go up at first.\n
P:1077C:EndInitFlyer
P:1078A:InitPondFairy: Play "item taken" sound effect.\n
P:1078F:: The fairy goes at location ($78, $7D).\n
P:10798:UpdateZora: If we have the magic clock, then return.\n
P:107A0:: If zora died in the call above, then it happened while in\n states 2, 3, or 4. In the code below, the state won't be 0.\n So, it won't flag the zora inactive. This is why the zora does\n not come back after killing it.\n\n If state <> 3 or timer <> $FD,\n then go see if the object needs to be destroyed.\n
P:107AC:: Shoot a fireball; and set the timer so that it expires faster.\n
P:107B5:: If state = 0, then destroy zora object.\n Also flag it inactive, so that the object update loop will try\n to make another one.\n
P:107BF:UpdateMoblin: Set turn rate to $A0.\n
P:107C7:: Arrow object type
P:107CC:UpdateLynel
P:107CF:: Sword shot object type
P:107D1:: QSpeed $20 (.5 pixels a second)
P:107D3:_TryShooting: Params:\n A: q-speed of the monster\n Y: shot object type\n\n [01] holds the q-speed of the monster
P:107D5:: If the monster is not a blue walking OW monster, and shoot timer = 0,\n
P:107D8:: Blue moblin
P:107DC:: Blue lynel
P:107E0:: Blue slow octorock
P:107E4:: Blue fast octorock
P:107ED:: and a random value < $F8, then return.\n
P:107F3:: Summary\n\n if temporarily invincible then\n   shoot timer := 0\n elif shoot timer > 0 then\n   decrement shoot timer\n elif wants to shoot then\n   shoot timer := $30\n\n qspeed := [01]\n\n if shoot timer <> 0 then\n   if shoot timer = $10 and no clock and not stunned then\n     shoot\n     if succeeded then\n       shoot timer := 0\n       qspeed := 0\n   else\n     qspeed := 0\n\n Push a 0 q-speed, in case the monster is in shooting time.
P:107F5:: Store shot object type in [00] to pass to shooting routine.
P:107FA:: If not temporarily invincible,\n
P:107FF:: then Y := shoot timer - 1\n
P:10803:: If Y register < 0, then shoot timer is 0.\n So, if "wants to shoot" flag is set, then set shoot timer to $30.\n Else go set a non-zero speed and return.\n
P:1080C:: shoot timer := Y\n
P:10810:: If new shoot timer = 0, go set a non-zero speed.\n
P:10812:: shoot timer <> 0\n If shoot timer <> $10, then go set a zero speed.\n
P:10816:: If we have the magic clock, or the monster is stunned, then\n go set a zero speed.\n
P:1081D:: Shoot.\n
P:10822:: If it failed, go set a non-zero speed.\n
P:10824:: It succeeded, so reset "wants to shoot" flag and the speed.\n
P:10829:: Replace the speed that was pushed with 0.
P:1082D:: Set the speed to whatever was determined: 0 or the value passed in [01].\n
P:10832:_ShootIfWanted2: Params:\n A: shot object type\n X: shooter object index\n\n Returns:\n C: 1 if succeeded\n Y: shot slot\n
P:10835:: TODO:\n If succeeded, then set object timer to $80, and decrement [0437][X].\n\n TODO:\n What are object timer and [0437] used for?\n
P:1083F:UpdateMonsterArrow: Set q-speed $80 (2 pixels a frame).\n
P:10844:: If the timer has not expired, then go draw,\n and see if the shooter's still alive.\n
P:10848:: If the arrow is sparking, then go update the base arrow.\n
P:10851:: If the arrow is not flying, then\n go handle it bouncing off of Link's shield.\n
P:10855:: TODO: But is this necessary?\n Set the moving direction in [0F].\n Then go update the base arrow.\n
P:1085C:: If the shooter is gone, then reset the arrow's object timer;\n so that it flies right away.\n
P:1086C:: If the arrow is no longer flying, then\n go handle it sparking or bouncing.\n
P:10878:: If [06] = 0, then there was no collision with Link that harmed him\n Either there was no collision at all, or it bounced off of the shield.\n So, return.\n
P:1087C:: Else there was a collision with Link that harmed him.\n So, destroy the arrow.\n
P:10886:UpdateBoulderSet: If the object timer has not expired, then return.\n
P:1088A:: If the maximum number (3) of boulders are active, then\n go set the timer to wait a random amount of time.\n
P:10891:: If no empty monster slot is found, then return.\n
P:10896:: Set the boulder monster type, and increase the number\n of active boulders.\n
P:108A0:: Give the boulder a random X coordinate in the same half\n of the screen as the chase target.\n
P:108A4:: If chase target X < $80, mask Random with $7F.
P:108AD:: Else make it >= $80.
P:108B1:: Start at the top edge of the screen ($40).\n
P:108B5:: Set the boulder set's timer to ((Random + 8) AND $1F).\n
P:108C2:: Randomize the object timer.\n
P:108CA-108D4:_JumperYOffsets
P:108D5-108F1:_JumperYAccelerations: Logically, this array would be 33 bytes: 3 sets of 11 bytes,\n 1 byte for each 8-way direction\n\n But because Boulder does not need the upward accelerations,\n the elements for those are used for the starting speeds\n at 04:88F2.\n
P:108F2-108F4:_JumperStartSpeedsHi
P:108F5-108F7:_JumperYAccelerationBaseOffsets
P:108F8:UpdateTektiteOrBoulder: If the monster is shoved, then keep shoving it.\n
P:10902:: If we have the magic clock, or the monster is stunned; \n then go animate, draw, and check collisions.\n
P:10909:: If state <> 0, go update the jump.\n
P:1090D:: State 0. On the ground.\n\n If timer <> 0, then go animate, draw, and check collisions.\n
P:10911:: State = 0 and object timer expired. Time to jump.\n\n First, turn 1 step toward the chase target.\n
P:10914:: If the facing direction has no horizontal component, then\n find the horizontal direction toward the chase target.\n\n Then combine it with the facing direction.\n
P:10928:: Set state 1 to jump.\n
P:1092A:_L_SetUpJump: If reversal count >= 2, then\n 1. invert the horizontal component of facing direction,\n    to face away from the chase target\n 2. reset the reversal count to 0.\n\n This prevents a jumper from getting stuck in a corner.\n\n For example, if a tektite's direction is down and right,\n and jumps into the top right corner of the room:\n 1. The right room boundary is hit. So the direction is\n    automatically reversed to up and left.\n 2. The next frame, the top room boundary is hit.\n    The direction is reversed to down and right.\n\n As you can see, an endless loop has been made.\n
P:1093C:: If the object is a boulder, then make sure its facing direction\n has a down vertical component.\n
P:1093F:: For the given direction, get the Y offset of the destination\n of the jump.\n\n Add it to the object's Y, and store this destination Y.\n
P:1094A:: Set the starting speed, depending on the object type.\n
P:10953:: Reset the vertical speed low byte.\n Then go animate, draw, and check collisions.\n
P:10959:: State 1. Jumping.\n\n Keep the object inside the bounds of the room.\n
P:1095C:: If the object was blocked at the room boundary, then\n increase boundary reversal count, and go set up another jump.\n
P:10969:: This step in the jump succeeded. So, reset the reversal count.\n
P:1096E:: Get the base offset for the kind of jumper the object is.\n
P:10974:: Get the acceleration by indexing with (base offset + direction).\n\n Note that the set of accelerations of Boulder (the third set)\n does not have $B elements like the tektites' sets.\n\n Boulder does not need the upward accelerations.\n So, the elements for those are used for the starting speeds\n at 04:88F2.\n
P:1097B:: Max speed 2 pixels going down
P:10980:: If the facing direction has a left component, then\n subtract 1 from the object's X.\n\n Else add 1.\n
P:10990:: If going up (negative v-speed high byte), then\n go animate, draw, and check collisions.\n
P:10995:: Going down. We have to consider the target Y.\n\n If the absolute vertical distance to the target position >= 3,\n then go animate, draw, and check collisions.\n
P:10998:: Target Y
P:109A2:: Distance < 3. Go to state 0.\n\n If the object is a boulder, then go reset timer, animate, draw.\n
P:109AC:: Else calculate a timer value.\n\n t := (Random + $10)\n if t < $20 then\n   t := t - $40\n
P:109B8:: If the object is a blue tektite, then go use this t.\n
P:109BF:: t := t AND $7F\n
P:109C1:: If Random < $A0, then go use this t.\n
P:109C7:: t := t AND $F\n
P:109CB:_L_AnimateDrawTektiteAndCheckCollisions
P:109CE:: TODO: [0D] ?\n [0D] doesn't seem to be used.\n
P:109D0:: If the monster is a boulder, then go animate, draw, check collision.\n
P:109D7:: Draw a tektite.\n\n If state = 1, then go draw frame image 1, and check collisions.\n
P:109DB:: If object timer < $21, go draw frame image 0, and check collisions.\n
P:109E1:: Else cycle the animation counter, draw, and check collisions.\n\n TODO: name: movement frame\n The movement frame determines the frame image.\n
P:109EC:: Draw a boulder.\n
P:109F1:: TODO: The movement frame determines the frame image.
P:109F7:: If the boulder's Y < $F0, return.\n
P:109FD:: Else the boulder is close enough to the bottom of the screen\n to destroy it.\n
P:10A03:_GetJumperKind: Returns:\n Y: 0: blue tektite\n    1: red tektite\n    2: boulder\n
P:10A11:_PointBoulderDownward
P:10A21:_Jumper_MoveY: Params:\n A: acceleration\n Y: max speed high byte\n\n [00] holds the acceleration
P:10A23:: [02] holds the max speed high byte
P:10A25:: Add the high speed byte to the Y coordinate.\n
P:10A2C:: Add the acceleration to the speed fraction (low byte).\n
P:10A30:: [00] acceleration
P:10A35:: Carry over to the high speed byte.\n
P:10A3D:: *Signed comparison*:\n If the high speed byte < high max speed byte, then return.\n\n Note that this is not a general purpose signed comparison,\n which would be more complicated. But it works because\n the deviation from 0 of both values is small.\n
P:10A41:: Limit the speed to the max speed.\n
P:10A4D:_Jumper_ResetVSpeedFrac
P:10A53-10A58:_BlueLeeverStateQSpeeds
P:10A59-10A5E:_BlueLeeverStateTimes
P:10A5F-10A64:_BlueLeeverStateAnimTimes
P:10A65:UpdateBlueLeever: Turn rate $A0
P:10A6D:UpdateBurrower: If object timer <> 0, then go animate, draw, and check for collisions.\n
P:10A71:: If not zora or state <> 1, go cycle the state.\n
P:10A7D:: Else is zora and state = 1.\n\n If zora's Y >= Link's Y, then set zora's frame image to\n 3 (back), else 2 (front).\n\n The frame image number is being assigned to ObjDir.\n
P:10A88:: Cycle the state between 0 and 5.\n
P:10A95:: Look up and set the speed and timer for the current state.\n
P:10AA1:: Advance the animation counter; possibly setting a new\n value according to the new state.\n
P:10AA6:_AnimateDrawBurrowerAndCheckCollisions: Params:\n A: new value for animation counter, in case it rolls over\n X: object index\n\n Note:\n Advances the animation counter first.\n
P:10AA9:: If state = 0, return.\n
P:10AAD:: If is zora, and state >= 2 and < 5, then use frame image 2 or 3\n (front or back), which was stored in ObjDir above.\n
P:10AC2:: Or else if is zora in state 1 or 5, then use one of\n the mound frame images:\n\n TODO: name: movement frame\n frame image := ((state - 1) * 2) + movement frame\n\n This yields 0/1 or 8/9, depending on the state.\n\n This formula is used for states 1 to 5 of non-zora burrowers.\n
P:10ACD:: If not zora and state <> 3, \n or zora and state <> 2, 3, 4;\n then return.\n
P:10AE7:: If not dying, then return.\n
P:10AEC:: If monster is a red leever, then decrement the red leever count.\n
P:10AF7-10AFC:RedLeeverStateQSpeeds
P:10AFD-10B02:RedLeeverStateTimes
P:10B03-10B08:RedLeeverStateAnimTimes
P:10B09:UpdateRedLeever
P:10B10:: State 0.\n\n In state we determine whether to burst out of the ground.\n If the long timer has not expired, then return.\n
P:10B14:: Only allow two red leevers at a time.\n
P:10B1B:: Face in the same direction as Link.\n
P:10B1F:: Randomly (>= $C0) face the opposite direction -- toward Link.\n
P:10B28:: If facing horizontally, go place the leever to the left or right of Link.\n
P:10B2E:: Begin with the leever's X set to Link's X.\n
P:10B32:: If facing down, then use Y offset $28.\n Else store Y offset -$28 in [00].\n
P:10B3E:: Add Link's Y and the vertical offset.\n
P:10B43:: Sanitize the Y coordinate:\n (Y AND $F0) OR $D\n
P:10B49:: If Y coordinate >= $5D (top of the third square row), then\n go see if the tile is valid to come out of.\n\n Else it's too close to the top edge of the screen. So, return.\n
P:10B4E:: Begin with the leever's Y set to Link's Y.\n
P:10B52:: If Y coordinate < $5D (top of the third square row), then\n it's too close to the top edge of the screen. So, return.\n
P:10B56:: If facing right, then use X offset $28.\n Else store X offset -$28 in [00].\n
P:10B62:: [01] holds Link's X coordinate.\n
P:10B66:: Add Link's X and the horizontal offset.\n
P:10B69:: AND the result with $F8, so it's aligned with a tile horizontally.\n
P:10B6B:: Assign that result to the leever's X coordinate and [02].\n
P:10B6F:: If the leever's X [02] >= Link's X [01], then swap [02] and [01].\n
P:10B7B:: The point is to get the absolute distance between the two.\n
P:10B80:: If the absolute distance >= $30, then return.\n It means that the leever's X coordinate wrapped around\n the left or right edge of the screen.\n
P:10B84:: The leever can't come out of an unwalkable tile. So, return.\n
P:10B8F:: Set animation counter to 1, so that it will roll over this frame\n and pick up whatever the new value is for state 1.\n
P:10B94:: Set the long timer to 2, meaning 20 frames.\n
P:10B9A:: The leever has to face Link in order to move toward him.\n
P:10B9D:: If not in state 3, go check the object timer in order to draw and such.\n
P:10BA3:: State 3.\n\n If beign shoved, go shove, animate, and draw the leever.\n
P:10BAD:: If we have the magic clock or the leever is stunned, then\n go animate, draw, and check for collisions.\n
P:10BB4:: If the leever is blocked by a tile or the room boundary,\n then go to the next state, in addition to animating, drawing,\n and checking for collisions.\n
P:10BC5:: Move.\n
P:10BC8:: Truncate the grid offset.\n
P:10BD2:: Set timer to $FF.\n
P:10BD6:: If object timer has not expired, then\n go animate, draw, and check for collisions.\n
P:10BDA:_RedLeever_CycleStateDrawAndCheckCollisions: Cycle the state between 0 and 5.\n\n If a cycle was completed (wrapped around to 0),\n then decrease the active red leever count.\n
P:10BEA:: Look up and set the speed, timer, and animation counter\n for the current state.\n
P:10BFF:UpdateOctorock: If the monster is a fast octorock, use turn rate $A0.\n Else use turn rate $70.\n
P:10C04:: Blue octorock (fast and slow)
P:10C10:: If the octorock is slow, then use q-speed $20.\n Else double it.\n
P:10C1E:: Shoot a flying rock (object type $53).\n
P:10C26:: If facing down, then use frame image offset 2.\n
P:10C33:: Else facing up. Use frame image offset 1.\n
P:10C37:: If facing right, then set horizontal flipping, and use frame image offset 0.\n
P:10C3D:: Else facing left. Use frame image offset 0, but no horizontal flipping.\n
P:10C3F:: Save frame image offset for the direction.
P:10C40:: Decrement the animation counter, and roll over if needed.\n
P:10C4A:: There are actually 6 frame images divided into 2 sets.\n Each set depicts one animation frame. In each set there are\n 3 frame images: 1 for each direction (left, up, down).\n\n TODO: name: movement frame\n\n The movement frame will keep track of the base offset of\n the current set for the current animation frame: 0 or 3.\n\n So, XOR the movement frame with 3.\n
P:10C51:: Add the base offset and the directional offset, and save the result.\n
P:10C57:: If facing vertically, go draw mirrored.\n
P:10C5D:: Else draw not mirrored.\n
P:10C64:: Restore the frame image.
P:10C65:_DrawObjectMirroredAndCheckCollisions: Params:\n A: frame image\n X: object index\n [00]: object X\n [01]: object Y\n
P:10C6B:UpdateGhini: Pass in turn rate $FF to turn as often as possible.
P:10C76:: If the monster is still alive, then return.\n
P:10C7B:: For each object slot from $B to 1:\n If the object is a flying ghini ($22),\n then kill it by setting metastate to $11.\n
P:10C8D:DrawGhiniAndCheckCollisions
P:10C90:: Reset [0D]: frame image number. "Back" frame for up.
P:10C92:: If the direction has an "up" component, then keep the\n frame image 0, and go figure out horizontal flipping.\n
P:10C98:: Else make the frame image 1 for the "down" frame.\n Note that this is the frame image to use, even if there's no\n down component in the direction.\n
P:10C9A:: If right is a component of the direction, then go set horizontal\n flipping. Else leave horizontal flipping = 0.\n
P:10CA2:: Set horizontal flipping if right is a direction component.\n This essentially the same test as above, but for when we jump\n from the "up" test.\n
P:10CAC:_DrawObjectNotMirroredAndCheckLinkCollision: Params:\n A: frame image\n X: object index\n [00]: object X\n [01]: object Y\n [0F]: flip horizontally\n\n Returns:\n [00]: 0 for Link slot\n [06]: 1 if objects collide\n [09]: 0 for Link damage type (none)\n [0C]: 1 if objects collide\n [034B]: ShotCollidesWithLink\n
P:10CB2-10CB8:SecretArmosRoomIds
P:10CB9-10CBF:SecretArmosXs
P:10CC0:InitArmosOrFlyingGhini: In UpdateObject, this object was flagged "initialized".\n But if it's still fading in (timer > 0), then flag it "uninitialized".\n
P:10CC5:: If it's still fading in, then go finish some initialization needed\n for fading in.\n
P:10CC7:: Once the object timer reaches 0; if the object is flying ghini,\n go finish initializing it.\n
P:10CCA:: Flying Ghini
P:10CCE:: Else we have an armos.\n\n Store stairs tile $70 in [00] for use later.\n
P:10CD2:: Look for the current room ID in an array of room ID's that\n have armos secrets.\n
P:10CD6:: If this element does not match the current room ID, go loop again.\n
P:10CDB:: The secret (usually stairs) is under one of the armoses.\n\n If the armos's X coordinate does not match the one needed\n for the current room in the list, then go loop again.\n
P:10CE2:: If the armos's Y coordinate <> $80, go loop again.\n
P:10CE8:: If the loop index <> 0, go use the stairs tile to patch the floor.\n
P:10CEC:: The room ID at index 0 is $24. Instead of stairs, this room\n has the power bracelet.\n\n Set up the room item with the armos's coordinates.\n
P:10CF2:: This resets the room item's state, which activates it.\n
P:10CF4:: Set the room item ID.\n
P:10CF8:: If the bracelet has not been taken, then play the "secret found" tune.\n\n Either way, quit the loop, and replace the tile with a floor tile.\n\n Note that, if the item was already taken, then the room item\n object will stay activated. But in E6EA (MoveAndDrawRoomItem),\n it will be ignored, because that routine checks whether\n the item was taken.\n
P:10D02:: Bottom of the loop.\n
P:10D05:: Not found, or found the power bracelet.\n Use a floor tile $26 to replace the armos.\n
P:10D0B:: If the replacement tile is a stairs tile, then play the "secret found" tune.\n
P:10D13:: Replace the tile where the armos was.\n
P:10D19:: Because the armos object is aligned to the square grid\n (because it was made from a square),\n set its grid offset to 3 to compensate.\n\n Most objects are aligned to the grid vertically when the\n low nibble is $D.\n
P:10D1E:: Set a speed (q-speed fraction) randomly:\n $20 if random value < $80\n $60 otherwise\n
P:10D2B:: Facing and input directions down.\n
P:10D32:: Every other frame, return without drawing.\n
P:10D37:: Finish initializing based on type.\n
P:10D3A:: Flying Ghini
P:10D42:L_EndInitFlyingGhini
P:10D45:: If we're finally leaving the object flagged "initialized",\n then reset metastate and initialize this as a flyer.\n
P:10D50:UpdateArmos
P:10D53:: If it's still shoved, then don't animate. Only go draw.\n
P:10D57:: Animate.\n\n Decrement the animation counter. But if it hasn't reached 0,\n then only go draw.\n
P:10D5C:: Armos animation frames last 6 screen frames.\n
P:10D61:: Armos doesn't simply flip horizontally to animate. That would\n change the position of the shield. To keep fixed it in place,\n there are separate frame images for each animation frame.\n\n Frame images 0 and 1 depict the first animation frame, facing front and back.\n Frame images 2 and 3 depict the second animation frame, facing front and back.\n\n Here flip between the two sets by XOR'ing with 2.\n Then choose the direction at the point of drawing below.\n
P:10D69:DrawArmosAndCheckCollisions
P:10D6E:: If facing up, then use the second frame image in the set ("back").\n Else use the second.\n
P:10D7B:: If the armos is still fading in, then go for check collision with Link,\n but not with weapons.\n
P:10D7F:: Else check for all collisions.\n
P:10D82:: TODO: Why?\n If the armos has died, then set object type to $5D.\n
P:10D90:UpdatePondFairy
P:10D93:: If not in state 0, then go handle states 1 to 3.\n
P:10D97:: State 0.\n\n If Link is not at the edge of the pond (Y=$AD), then return.\n
P:10D9D:: If Link's X < $70 or >= $81, then return.\n
P:10DA7:: Link is at the edge of the pond. Advance to state 1,\n halt Link, and start filling hearts.\n
P:10DB4:: State 1. Flying and filling hearts.\n\n If still filling hearts, then go draw Link and hearts.\n
P:10DB8:: If not filling hearts anymore, then go to state 2,\n and set Link's object timer to $50, to keep showing hearts\n a little while after we finish filling hearts.\n
P:10DBE:: If state <> 2 (so, it's 3), then return.\n\n Note that the first time here is when we fall thru from 8DBC.\n In this case, A has $50 -- the value that Link's object timer\n was set to, and we'll return.\n
P:10DC2:: State = 2.\n\n If Link's timer <> 0, then go draw Link and hearts.\n
P:10DC6:: Else go to state 3, and unhalt Link.\n
P:10DCC:: TODO: but why, since Link is halted?\n\n Reset the input direction, so that Link doesn't animate\n when drawing him.
P:10DD1:: Save and reset Link's state.\n\n TODO: but why, since Link is halted?\n
P:10DD9:: Restore Link's state.\n
P:10DDF:: Restore the object slot.\n
P:10DE3-10DE9:PondHeartStartAngles
P:10DEA:PondFairy_MoveHearts: Loop over each heart from object slot 2 to 9.\n\n Even though they are not standalone objects, their info\n is stored in those object slots.\n
P:10DEC:: If the current heart's state <> 0, then go move it.\n Else we have to wait for it come out at the right time.\n
P:10DF0:: The current heart's state = 0.\n\n If object slot = 2, then go make it appear. This is the first\n heart to show up.\n
P:10DF4:: Object slot <> 2. If the state of the heart in slot 2 = 0, then\n go start over.\n\n TODO:\n Is it possible to jump here? This looks like an infinite loop.\n
P:10DF8:: Look up the starting angle of this heart with the index\n (object slot - 3). If the first heart has not reached this angle,\n then loop again.\n
P:10E05:: Set up this heart. Set its state to 1.\n
P:10E07:: TODO: ?\n
P:10E0B:: Starting angle $18 (N).\n
P:10E10:: This heart is right above the fairy. Set its X the same as the fairy's.\n
P:10E14:: This heart is right above the fairy. Set its Y $1C pixels above the fairy.\n
P:10E1B:: Decrease the angle by $00.60.\n
P:10E24:: Rotate the heart's location by the change in angle.\n Use 6 for the number of bits of sine/cosine to use\n for a large ring.\n
P:10E2C:: Save the loop index.
P:10E34:: The variable for the currently updating object slot has to be\n set to the heart's object slot for this drawing routine to work.\n
P:10E3A:: Restore the loop index.
P:10E3C:: Bottom of the loop.\n Increase the object slot.\n
P:10E42-10E43:RockPushDirections: Also used for the gravestone.
P:10E44:UpdateRockOrGravestone
P:10E48:: State 0.\n\n If this is not a gravestone (but it's a rock), and there is no\n bracelet, then return.\n
P:10E54:: If there is a mismatch between the current quest and the quest\n needed for the secret in this room, then return.\n
P:10E59:: The gravestone and rocks can only be pushed vertically.\n Return, if X's don't match.\n
P:10E5F:: If the difference between Link's (Y + 3) and the block's Y\n is positive; then go use it along with a flag that indicates that\n Link is "down" from the object.\n
P:10E6B:: Else negate it, and indicate Link is "up" from the object.\n
P:10E71:: If the distance >= $11, return.\n
P:10E75:: If the input direction has no vertical component, then return.\n
P:10E7C:: If this vertical input direction does not match the one needed\n to push the rock or gravestone, then return.\n
P:10E81:: Set it to the object's direction. Go to the next state.\n
P:10E85:: TODO: ?\n Store current room ID.\n
P:10E8A:: Change from a gravestone tile to the gray floor tile.\n The gravestone object will be drawn above it.\n
P:10E8C:: Gray floor tile
P:10E92:: State 1.\n\n Move in the object's direction.\n
P:10E99:: Draw the sprites one pixel above the object's location.\n
P:10EA1:: If the object's grid offset (distance moved) <> $10 nor -$10,\n then return.\n
P:10EAC:: Flag the room visited.\n
P:10EBA:: If object is a rock ($62), go use a rock tile ($C8).\n
P:10EC3:: If the object is a gravestone ($65), go use a gravestone tile ($BC).\n
P:10EC9:: Else use an armos tile ($C0). Dead code?\n
P:10ECB:: Change the tiles at the end location.\n
P:10ED0:: Store the stairs tile in [00] for use in revealing the secret.\n
P:10ED4:: Get the position of the stairs in this room, and set it for the object.\n
P:10EE0:_RevealSecretTileObj: Params:\n A: the first tile of tile object\n X: object index\n
P:10EEB:UpdateRockWall: If the secret in this room does not apply to the current quest,\n then return.\n
P:10EF0:: If there is no detonating bomb (state $13) in slots $10 and $11,\n then return.\n
P:10EF9:: Point to slot $11.
P:10F01:: Store the bomb's object slot in [00].\n
P:10F03:: If the tile object and weapon collide, then reveal the secret.\n
P:10F08:: Black tile
P:10F0E:UpdateTree: If the secret in this room does not apply to the current quest,\n then return.\n
P:10F13:: If there is no standing fire (state $22) in slots $10 and $11,\n then return.\n
P:10F24:: Store the fire's object slot in [00].\n
P:10F26:: If the standing fire's timer >= 2, return.\n
P:10F2D:: If the tile object and weapon collide, then reveal the secret.\n
P:10F32:_RevealAndFlagSecretStairsObj: Params:\n X: object index of the tile object\n\n\n First tile of stairs
P:10F34:_RevealAndFlagSecretTileObj: Params:\n A: the first tile of tile object\n X: object index\n
P:10F37:: Flag the secret found in this room.\n
P:10F3A:: Secret found/taken
P:10F3F:_CheckTileObjCollisionWithWeapon: Params:\n X: object index\n Y: weapon object index\n [00]: weapon object index\n\n Returns:\n A: 1 if objects collide\n\n Put the midpoint coordinate of the weapon in [04] and [05].\n
P:10F4F:: Put the tile object's midpoint coordinates in [02] and [03].\n
P:10F52:: 10 pixel collision threshold
P:10F57-10F59:SecretQuestNumbers
P:10F5A:_IsQuestSecretMismatch: Returns:\n C: 1 if there is a mismatch between current quest\n    and quest number for the secret in the room\n\n\n The quest secret is in the high two bits.\n
P:10F63:: If it's 0, then return C=0.\n
P:10F65:: Look up a quest number (0 or 1) indexed by quest secret (0 or 1).\n
P:10F69:: If the save slot's quest number matches the room's\n secret quest number, then return C=0.\n
P:10F70:: Else return C=1. There is a mismatch in quest numbers.\n
P:10F73-10F75:RaftStateToDirection
P:10F76:UpdateDock: If missing the raft, then return.\n
P:10F7F:: State 0\n\n Choose an X coordinate for the dock:\n $80 in room $55\n $60 in the other room ($3F)\n
P:10F89:: If the player is not aligned with the dock, return.\n
P:10F8D:: Set the dock object's X.\n
P:10F8F:: Determine whether Link is coming or going.\n If Y = $3D, then he's at the top edge of the screen. Use state 1.\n
P:10F97:: But if Y = $7D, then he's at the dock. Use state 2.\n Otherwise, return.\n
P:10F9E:: Show the raft beneath Link: 6 pixels down.\n
P:10FA3:: Play the "secret found" tune, and halt Link.\n
P:10FAA:: Set Link's direction based on the raft's state.\n
P:10FB0:: Is state = 1?\n
P:10FB5:: State 2. Up\n
P:10FB9:: If Link's Y = $3D, then leave the room.\n Else go draw.\n
P:10FC9:: State 1. Down\n
P:10FCD:: If Link's Y <> $7F, go draw.\n Note that Y is below $7D, which would trigger going up.\n
P:10FD3:: Link's grid offset at $7F must be 2 ($7F - $7D).\n
P:10FD8:_L_ResetLinkAndRaftStateAndDraw
P:10FDE:: Save raft object slot.
P:10FE3:: Restore raft object slot.
P:10FE5:: TODO: Why animate the raft?\n
P:10FE8:: Normal sprites, palette row 4 (Link).
P:10FEA:: Raft item slot
P:10FEF:UpdateFlyingGhini: If we have the magic clock, then don't move.\n
P:10FFD:: Get the low bit of the flying distance traveled.\n But this doesn't seem to be used.\n The following call clobbers the A register.\n
P:11005:ControlFlyingGhiniFlight
P:11017:Flyer_GhiniDecideState: Go to the next state randomly:\n Random >= $A0: 2\n Random >= $08: 3\n Else:          4\n\n Set up 6 turns.\n
P:1101D:: If >= $A0, go to state 2.
P:11022:: If >= 8, go to state 3.
P:11024:: Else go to state 4.
P:11025:: Go set the state we determined.
P:11028:UpdatePeahat: If the object is begin shoved, then shove it and go draw\n and check for collisions.\n
P:11032:: If we have the clock or the object is stunned, go draw\n and check for collisions.\n
P:11039:: Else move around.\n
P:11042:: Take low bit of the flying distance traveled as the frame image.\n So, the faster it moves, the faster it animates.\n
P:1104A:: In flying state 5, check for all collisions (so it can get hurt).\n In all other states, only check for collisions with Link.\n
P:11057:ControlPeahatFlight
P:11069:Flyer_PeahatDecideState: Go to the next state randomly:\n Random >= $B0: 2\n Random >= $20: 3\n Else:          4\n\n Set up 6 turns.\n
P:1106F:: If >= $B0, go to state 2.
P:11074:: If >= $20, go to state 3.
P:11076:: Else go to state 4.
P:1107B:: Set 6 turns for the next state.
P:11081:_PlaySecretFoundTune
P:110A0-110AF:WallmasterDirsAndAttrsLeft
P:110B0-110BF:WallmasterDirsAndAttrsRight
P:110C0-110CF:WallmasterDirsAndAttrsTop
P:110D0-110DF:WallmasterDirsAndAttrsBottom
P:110E0-110E1:WallmasterInitialXs
P:110E2-110E3:WallmasterInitialYs
P:110E4:UpdateWallmaster
P:110EB:: State 0.\n\n If Link's object timer is active, then return.\n
P:110EF:: If Link is halted, then return.\n
P:110F6:: State 0. Idle/Waiting inside wall\n\n If  (Link's X < $29 or >= $C8)\n and (Link's Y < $6D or >= $B5),\n then return.\n
P:1110A:: Check whether Wallmaster should come out of the left or right wall.\n\n If Link's X <> $20 nor $D0, then go check the top and bottom walls.\n
P:11114:: Store Link's X as the major coordinate in [01],\n and Link's Y as the minor coordinate [00].\n
P:1111C:: Pass "up" as decreasing direction along wall in [02].\n
P:11120:: Link's minimum major coordinate (X at left wall)
P:11122:: Offset 0 for first horizontal wall element in instruction block
P:11127:: Set Y coordinate to initial minor value returned.\n
P:1112B:: Look up and set X coordinate according to the index returned.\n
P:11131:: Check whether Wallmaster should come out of the top or bottom wall.\n\n If Link's Y <> $5D nor $BD, then return.\n
P:1113B:: Store Link's Y as the major coordinate in [01],\n and Link's X as the minor coordinate [00].\n
P:11143:: Pass "left" as decreasing direction along wall in [02].\n
P:11147:: Link's minimum major coordinate (Y at top wall)
P:11149:: Offset $20 for first vertical wall element in instruction block
P:1114E:: Look up and set Y coordinate according to the index returned.\n
P:11153:: Set X coordinate to initial minor value returned.\n
P:11157:: Look up and set the facing direction for the first step.\n
P:11161:: TODO: why object 1 timer?\n\n Set object slot 1's timer to $60, this monster's QSpeed to $18,\n and animation counter to 8.\n
P:1116F:: Reset grid offset, tiles crossed, and movement frame.\n
P:1117A:: Start Wallmaster state 1.\n
P:1117D:L_Wallmaster_State1: If the monster has been shoved, then shove it and go draw.\n
P:11187:: If we have the magic clock or the monster is stunned, then\n go draw and check collisions.\n
P:11190:: [0F] moving direction
P:11195:: If grid offset <> $10 nor $F0 (so not square aligned), then\n go draw and check collisions.\n
P:111A0:: Truncate grid offset.\n
P:111A5:: Advance the step.\n
P:111A8:: Set facing direction to the one for this new step.\n
P:111B2:: Increase the count of tiles crossed.\n
P:111B5:: If the monster has crossed less than 7 tiles, then\n go draw and check collisions.\n
P:111BC:: It has reached the end of a trip.\n\n If Wallmaster did not capture Link, then go set state to 0 and return.\n
P:111C1:: At the end of a trip where Link was captured:\n 1. hide the special sprites used by Wallmaster\n 2. go to mode 3 "unfurl" to go the level's entrance\n 3. reset Link's state, so he's idle\n
P:111D3:L_Wallmaster_DrawAndCheckCollisions: If Link was captured, then go draw Link and Wallmaster specially.\n
P:111DB:: If after checking object collisions, Link was captured, then\n halt Link and keep him from being shoved.\n
P:111E8:: Remember the index of the first sprite that will be used to draw,\n because the drawing routine will cycle the sprites.\n
P:111EB:: Save the sprite index
P:111F5:: Restore the sprite index
P:111F6:: Store the offset of the left sprite record in [00],\n and the right one in [01].\n
P:11204:: The default image is the hand open.\n If animation frame = 0, then return.\n
P:1120C:: Animation frame 1 uses Wallmaster frame image 1, which\n uses tiles $9C/$9D on the left and $9E/$9F on the right.\n The right side is correctly the right side of a closed hand.\n But the left side is Keese. So, we have to patch the left\n side to use the common left side of the hand -- $AC/$AD.\n\n Keep in mind that left and right sprites might be flipped.\n
P:1121D:: Draw Wallmaster with captured Link.\n\n First, put Link right where the monster is.\n
P:11231:: Force animation frame 1: hand closed.\n
P:11239:: Store the offsets of the sprites to show over Link\n ($10 and $11) in [00] and [01] for use in patching the right sprite.\n
P:1123F:: Go patch up the sprites.\n
P:11242:Wallmaster_PrepareToDraw: 8 screen frames an animation frame
P:11247:: For the current step, look up the sprite flipping attributes.\n
P:1124F:: Combine them with palette row 5 (blue)
P:11254:: If the sprite attributes for this step have horizontal flipping ($40),\n then mask it off, and turn on horizontal flipping with [0F].\n
P:11262:Wallmaster_CalcStartPosition: Params:\n A: offset of first instruction for left wall (0)\n    or top wall ($20)\n Y: Link's minimum major coordinate\n [00]: Link's coordinate along minor axis\n [01]: Link's coordinate along major axis\n [02]: a decreasing direction along the wall (left or up)\n\n Returns:\n Y: index of initial major coordinate of Wallmaster\n [04]: initial minor coordinate of Wallmaster\n\n Store the initial offset for this axis.\n
P:11265:: [03] holds the Link's minimum major coordinate.
P:11267:: If Link is still (input dir = 0), then use distance $24, else $32.\n
P:11270:: If Link is facing in the direction passed in (which decreases), then:\n 1. negate the distance\n 2. add 8 to the instruction offset to access\n    the opposite direction for the same wall\n
P:11272:: [02] reference decreasing direction
P:11286:: Add the distance and Link's minor coordinate to calculate\n Wallmaster's initial minor coordinate to store in [04].\n In general, the monster will be put in front of Link.\n
P:11287:: [00] Link's minor coordinate
P:11289:: [04] Wallmaster's initial minor coordinate
P:1128B:: By default, will return index 0 to choose the minimum value\n for Wallmaster's initial major coordinate. This will be returned,\n if Link is at the wall with a smaller major coordinate.\n
P:1128D:: If Link's major coordinate <> the minimum major coordinate, then\n he's on the farther wall. Add $10 to the instruction offset \n to access the block for the other direction along the same axis,\n and increment the index for the Wallmaster's initial major coordinate.\n
P:1128F:: [03] Link's minimum major coordinate
P:1129E:Wallmaster_PutSpritesBehindBgIfNeeded
P:112A5:Wallmaster_PutSpriteBehindBgIfNeeded: Loop twice, from 1 to 0, in order to check the left and right\n extents of the sprite (X and X+8).\n
P:112A7:: If sprite X + extent >= $E9 or < $18, then\n add priority attribute to show this sprite behind the background.\n
P:112C2:InitRope: Rope has $10 HP in quest 1, $40 HP in quest 2.\n
P:112D6:UpdateRope: Set the input direction to the facing direction.\n
P:112DB:: Save the original facing direction
P:112DC:: If we have the clock, or the monster is stunned, then don't move.\n
P:112E6:: Truncate the grid offset at $10.\n
P:112F0:: If not rushing (qspeed <> $60) and timer = 0, then\n set timer to a random value up to $3F, and turn to face\n an unblocked direction.\n
P:11304:: Pop the original facing direction
P:11305:: If the facing direction has changed, then set qspeed to $20 (slow).\n
P:1130E:: If qspeed <> $20 or grid offset <> 0, then go draw.\n
P:1131A:: If the absolute horizontal distance between Link and the monster >= 8,\n then go see if the vertical distance is smaller.\n
P:11326:: Face up.\n
P:1132A:: But, if Link is down of the monster, then face down.\n
P:11332:: Make the rope rush (qspeed $60).\n
P:11337:: Animation counter $A
P:1133C:: If facing left, then flip horizontally.\n
P:11341:: [0F] horizontal flipping
P:11343:: Red sprite palette
P:11348:: In the second quest, ropes always flash.\n So, set sprite attributes to all the cycled palette rows.\n
P:11356:: TODO: name: movement frame\n The frame image is based on the movement frame.\n
P:1135F:: If the absolute vertical distance between Link and the monster >= 8,\n then go draw.\n
P:1136B:: Face left.\n
P:1136F:: But, if Link is right of the monster, then face right.\n Either way, go increase speed and draw.\n
P:11377:UpdateStalfos: Turn rate $80
P:1137F:: Animation counter 8
P:11384:: QSpeed $20
P:11386:: [01] holds qspeed $20
P:11388:: If in the first quest, return. Stalfos can't shoot in this quest.\n
P:1138F:: Second quest.\n\n If shoot timer = 0 and Random < $F8, then return.\n
P:1139A:: Save the qspeed.
P:1139D:: If temporarily invincible, then go reset shoot timer.\n
P:113A4:: If shoot timer >= 1, then decrement and go set shoot timer.\n
P:113AA:: If stalfos does not want to shoot, then go set the qspeed.\n
P:113AF:: Else not temporarily invincible, and shoot timer = 0,\n and wants to shoot.\n\n Set shoot timer to $30.\n
P:113B5:: If shoot timer = 0, then we're not shooting.\n Go set the qspeed.\n
P:113B7:: If shoot timer <> $10, or we have the magic clock, or stunned;\n then go reset qspeed.\n
P:113C2:: Try to shoot a sword shot.\n
P:113C9:: If failed, then go set the qspeed.\n
P:113CB:: TODO:\n Else set timer to $80, and decrement [0437][X].\n
P:113D2:: We jump here if shooting failed. Jump again to set the qspeed.\n
P:113D4:: Shooting succeeded.\n Reset "wants to shoot" flag and the speed.\n
P:113D9:: Replace qspeed on the stack with 0.
P:113DD:: Pop and set the qspeed (0 or the speed for stalfos).
P:113E2:InitMoldorm: Loop to make 10 moldrom segments, from 9 to 0, indexed by Y register.\n Object slots $A to 1 will be used.\n
P:113E4:: Start at position ($80, $70).\n
P:113EE:: Start with no direction, no deferred bounce direction,\n and ready to update.\n
P:113FC:: Copy object attributes from the first monster slot.\n
P:11402:: Copy HP from the first monster slot.\n
P:11408:: Start with flying speed $80, and in flying state 2.\n
P:11412:: All segments are considered Moldorm.
P:11417:: Bottom of the loop.\n
P:1141A:: Choose a random 8-way direction for the head segments\n in slots 4 and 9.\n
P:11424:: Also store the current direction as the old direction.
P:11431:: Also store the current direction as the old direction.
P:11434:: Set minimum number of turns 1 for flying states.\n\n By setting this, the first time that a flight control routine\n (Flyer_Chase, Flyer_Wander) is called and returns;\n that flying state will immediately end, and object timer\n will be left 0: ready for moldorm to decide a flying state\n randomly and set timer to $10.\n
P:11436:: TODO: [042C][5]
P:11439:: TODO: [042C][$A]
P:1143C:: The maximum speed for Moldorm is $80.
P:11441:: TODO: Why 8 instead of 10?
P:11447:InitAquamentus: Aquamentus is invincible to boomerang and fire.\n
P:1144C:: TODO: ?\n
P:11451:: The monster goes at ($B0, $80).\n
P:1145A:_InitDigdogger1: TODO: ?\n
P:1145F:: Set a random 8-way direction.\n
P:11469:: Set low speed byte to $3F.\n This assumes that the high byte is 0 from when the room\n was reset; or will bet set during digdogger split-up.\n
P:1146E:: Set low target speed byte to $80.\n This assumes that the high byte is 0 from when the room\n was reset; or will bet set during digdogger split-up.\n
P:11473:: Set child count of 3.\n
P:11479:_InitDigdogger2
P:1147C:: TODO:\n Change object type to $38 (Digdogger1).\n\n Probably to simplify a test.\n
P:11481:: Set child count of 1.\n
P:11487:InitDodongo: TODO: ?\n
P:1148C:: Randomly face left or right.\n
P:11498:UpdateMoldorm: If facing direction = 0, return.\n
P:1149C:: If the magic clock is missing, then move around (using the flying mechanism).\n
P:114A7:: Draw with sprite attributes: normal, red palette row\n
P:114AB:: Fireball tile
P:114B0:: Check collisions, but never let them interfere with movement.\n
P:114B2:: Save the direction
P:114B5:: Save the timer
P:114B9:: Restore the timer
P:114BC:: Restore the direction
P:114BF:: If this segment is still alive, then return.\n
P:114C4:: This segment is dead. We'll swap the tail segment with this\n dead segment. This way, moldorm heads are always rooted\n in slots 5 and $A; and the segments are continguous.\n\n Start by setting the HP for this dead segment's slot to $20.\n\n Note that this is not a true swap, because the tail's HP\n might be less than $20.\n
P:114CC:: Look for the tail segment, starting from the low end\n of the chain that this dead segment belongs to.\n
P:114DC:: I don't know why the object timer of the tail segment that will\n be made dead is set to $11. By setting its object type to $5D\n below, its metastate will become $10 -- dying/dead. From\n there, the object timer is set to 6.\n
P:114E1:: Copy the invincibility timer, X, and Y from the original dead\n segment to the tail segment.\n
P:114F1:: If the tail segment found is also a head, then\n the last segment has died. Return.\n
P:114F9:: Else finish swapping the segments.\n Set the tail segment's type to the dead dummy object.\n
P:114FE:: Reset the metastate of the current segment, so that it comes\n back to life.\n
P:11502:ControlMoldormFlight
P:11510:Moldorm_Chase: If the segment is not a head (slot 5 or $A), then return.\n Only the head controls the movement direction.\n
P:11518:: Chase while flying, as usual.\n
P:1151B:: If timer has not expired, then\n go see if it's time to propagate direction changes down the chain.\n
P:1151F:: Timer = 0. Choose a new flying state, and arm the timer.\n
P:11522:: $10 screen frames
P:11526:: If the next lower slot's direction <> 0, then\n go propagate direction changes down the chain.\n\n But you had to have propagated directions once for the\n next lower direction to be set. How does it happen?\n\n Within a flyer state, the flying routines turn the flyer\n and set the object timer to $10 several times. After any of\n those times will the test succeed.\n\n When a flying state ends, timer will be 0, triggering the code\n in this block to set the timer to $10, and try to propagate\n directions.\n\n But this is also the case the first time here.\n\n So, I believe that the point of this test is to delay moving\n the lower (not head) segments when starting out.\n\n TODO: Base operand is ObjDir-1
P:1152B:_Moldorm_Wander: If the segment is not a head (slot 5 or $A), then return.\n Only the head controls the movement direction.\n
P:11533:: Turn randomly while flying, as usual.\n
P:11536:: After every turn, the common flyer routines set timer to $10.\n This can be used as a signal for moldorm to propagate\n direction changes down the chain.\n\n Between each turn, timer <> $10.\n\n At the end of the delay after the last turn, timer = 0.\n This is a signal that that flying state ended, and a new one\n must be chosen. Also, because a flying interval ended ($10 frames),\n we can propagate direction changes again; and start\n a new flying interval by setting timer to $10. This will make\n the next flying state delay that amount of time before turning\n the first time.\n\n Here and now, if timer has expired, then go decide a new flying state,\n arm the timer again, and shift directions down the chain.\n
P:1153A:: If timer <> $10 (rearmed in this frame), then return.\n
P:11540:: Timer = $10.\n\n If deferred bounce direction <> 0, then\n assign it to facing direction, and reset deferred bounce direction.\n
P:1154C:: Will loop 4 times, indexed by [00], once for each segment.\n
P:11550:: Starting from the last slot of this moldorm chain (0 or 5):\n
P:11558:: Copy old direction from a higher slot to the lower one;\n and to the lower one's facing direction.\n
P:11561:: Bottom of the loop.\n Increment segment index.\n Decrement loop counter.\n
P:11566:: Copy current direction to old direction.\n
P:1156C:Flyer_MoldormDecideState: If Random >= $40, go to flying state 2, else 3.\n\n Set up 8 turns.\n
P:11579:: Set 8 turns for the next flying state.
P:1157F-11582:DigdoggerCornerOffsetsX
P:11583-11586:DigdoggerCornerOffsetsY
P:11587:: Params:\n Y: flute state\n\n If flute state = 2, go switch between big and little appearance.\n
P:1158A:: Flute state = 1.\n\n If this is a child digdogger, then go turn and move as usual.\n
P:1158F:: Set object timer to $40, and increase flute state to 2.\n Then go check collisions as a big digdogger.\n
P:11599:: If the timer = 0, then skip the block below, and go split up.\n
P:1159D:: Every 8 frames, switch between behaving as a big and little digdogger.\n\n TODO:\n But is this possible, given the following?\n a. all object timers run concurrently\n b. all object updates are paused until the flute timer expires\n c. the flute timer lasts longer\n
P:115AE:: Decrement flute state to 1.\n
P:115B1:: Loop to make a number of child digdoggers.\n
P:115B4:: [00] is the loop counter
P:115B6:: Replace the object count with the number of children.
P:115B9:: Save the current object index in X register.
P:115BB:: Initialize a child digdogger (type $18) in the next object slot.\n
P:115C4:: Start with a target speed of $0100.\n The low byte is still 0 from when room data was reset.\n
P:115C7:: Flag this a child digdogger.\n
P:115CC:: The speed will increase.\n
P:115D1:: Copy the parent's coordinates to the child.\n
P:115D9:: Bottom of the loop.\n Decrement [00] until 0.\n
P:115DD:: Restore the current object index in X register.
P:115E2:: Destroy the big digdogger by resetting the object type.\n
P:115E7:: Don't let the digdogger disappear until the next frame when\n the children can draw themselves. Go draw the big digdogger\n as a little one.\n\n This will work, even though the object type was reset. No\n other object data has not been touched. Also, the code block\n we'll jump to temporarily sets the object type.\n
P:115F0:UpdateDigdogger: If we have the magic clock, or the monster is stunned,\n then go check room boundaries and object collisions, and draw.\n
P:115F7:: If the flute was used, then go start splitting up,\n or handling a child digdogger.\n
P:115FF:: If the object timer has expired, then set it to $10,\n and randomly choose to turn toward Link or randomly.\n
P:11610:_L_Digdogger_Move
P:11613:: If this is a child, then finish updating this little digdogger.\n
P:11621:: Save the original coordinates.\n
P:11627:: TODO:\n Reset [0478][X].\n
P:1162C:: Digdogger is big, but room boundary checks and\n object collision checks assume a 16x16 monster or smaller.\n Therefore, we have to check these things four times,\n in different corners of the boss.\n\n TODO:\n Loop 4 times, from 0 to 3, indexed by [0478][X].\n
P:1162F:: Change the coordinates to one corner.\n
P:1163F:: Check the room boundary and object collisions in this temporary location.\n
P:11645:: Increase the loop index, and loop again until it = 4.\n
P:1164F:: Restore the original coordinates.\n
P:11658:_L_DrawAsLittleDigdogger: Save the original coordinates.\n
P:1165E:: Add 8 to Y and X.\n
P:1166A:: Save the child flag and object type.\n
P:11672:: Change object type to $18 (Little Digdogger),\n and child flag to 1, in order to draw as a little digdogger.\n
P:1167F:: Restore the child flag and object type.\n
P:11687:: Restore the original coordinates.\n
P:1168E:Digdogger_ChangeSpeed
P:11698:Digdogger_SpeedUp: Add 1 to 16-bit speed.\n
P:116A0:: If the 16-bit speed has not reached the 16-bit target speed, then return.\n
P:116B0:: Set speed flag to 1 meaning decelerate.\n
P:116B3:: Go set target speed to $0040 (or $0140 if this is a child).\n
P:116B8:Digdogger_SlowDown: Subtract 1 from 16-bit speed.\n
P:116C5:: If the 16-bit speed has not reached the 16-bit target speed, then return.\n
P:116D5:: Set speed flag to 0 meaning accelerate.\n
P:116D8:: Set target speed to $0080.\n
P:116E2:: But if this is a child, then make the target speed $0180.\n
P:116EB:Digdogger_Move: This calculation is the same one used in Manhandla to\n manifest the fractional speed over several frames.\n\n To summarize, the formula is:\n\n   (SA=speed accumulator, SH=speed high, SL=speed low)\n\n   SA := SA + (SL AND $E0)\n   [03] := SH + carry\n\n See 04:A28E Manhandla_Move.\n
P:116F0:: Add the low speed byte to speed accumulator.
P:116F7:: Assign (high speed byte + carry) to [03].\n
P:116FE:: Change coordinates by the speed amount/offset in [03]\n according to the direction.\n\n Start with a mask of $A1 in [02]:\n - low nibble represents the right direction\n - high nibble is used to set or clear carry as we go along\n
P:11702:: If direction has a right component (1), then add offset to X coordinate.\n
P:1170F:: If direction has a left component (2), then subtract offset from X coordinate.\n
P:11711:: Bit 7 of mask $A1 sets Carry now.
P:1171D:: If direction has a down component (4), then add offset to Y coordinate.\n
P:1171F:: Bit 6 of mask $A1 clears Carry now.
P:1172B:: If direction has an up component (8), then subtract offset from Y coordinate.\n
P:1172D:: Bit 5 of mask $A1 sets Carry now.
P:1173C-1173F:DigdoggerSpriteOffsetsX
P:11740-11743:DigdoggerSpriteOffsetsY
P:11744-11747:DigdoggerSpriteAttrs
P:11748:Digdogger_Draw: 6 animation frames a screen frame
P:1174D:: If this is a child digdogger, then go draw it.\n
P:11752:: For each part of the big digdogger, from 0 to 3,\n indexed by Y register:\n
P:11754:: Store in [00] the X coordinate offset for the current corner.\n
P:1175C:: Store in [01] the Y coordinate offset for the current corner.\n
P:11764:: Load and set the sprite attributes for this part.\n Vertical flipping is set appropriately here.\n
P:1176A:: Save the loop index.
P:1176C:: Parts at odd indexes are flipped horizontally.\n
P:11770:: There's only 1 frame image.
P:11775:: Restore the loop index.
P:11777:: Bottom of the loop.\n Increment Y register until = 4.\n
P:1177D:: A little digdogger is easy to draw.\n
P:11786:UpdateAquamentus
P:1179A:_CheckBossDeathReaction: TODO: was _InhibitCommonHitReaction,\n  but should it still be something else?\n
P:117A0-117A1:AquamentusSpeeds
P:117A2:Aquamentus_Move: The monster uses grid offset to mean distance remaining.\n If there's more distance to cover, then go move.\n
P:117A7:: Set a random distance to move of 7 or $F pixels.\n
P:117B2:: Randomly head left or right.\n
P:117B9:: 7 of 8 screen frames return without moving.\n
P:117BF:: If the boss crossed the left limit, then\n put it back at the left limit ($88), and face right.\n
P:117CF:: If the boss crossed the right limit, then\n put it back at the right limit ($C7), and face left.\n
P:117DB:: Set the distance remaining to 7 pixels.\n
P:117E0:: Use (direction - 1) to index the speeds.\n This yields 0 for right, 1 for left.\n
P:117E3:: Add the speed to the X coordinate.\n
P:117EB:: Decrement the distance remaining.\n
P:117EF:Aquamentus_Shoot: If the object timer <> 0, then\n go modify fireballs that might still be flying.\n
P:117F3:: The boss's object timer has expired. Time to shoot fireballs.\n\n Set the timer to a random time, at least $70 frames.\n
P:117F9:: Shoot the middle fireball. Its vertical displacement is 0.\n
P:11801:: Shoot the lower fireball. Its vertical displacement is 1.\n
P:11809:: Shoot the upper fireball. Its vertical displacement is -1.\n
P:11812:: Make the fireballs spread out.\n\n For each object slot from $B to 1:\n
P:11814:: If type <> $55, loop again.\n
P:1181B:: Every other screen frame, loop again.\n
P:11820:: Add the displacement for this fireball to its Y coordinate.\n
P:11828:: Bottom of the loop.\n
P:1182B:: Restore the boss's slot number.\n
P:1182F:_ShootFireball55: Params:\n X: object index\n
P:11834:AquamentusTiles
P:11840-11845:AquamentusSpriteOffsetsY
P:11846-1184B:AquamentusSpriteOffsetsX
P:1184C:Aquamentus_Draw: Every $10 screen frames, switch animation frames.\n Each frame has 6 tiles (representing the top of 6 sprites).\n The last tile of frame 0 is at index 5.\n The last tile of frame 1 is at index $B.\n
P:11856:: [0A] holds the current tile index in frame tile list.
P:11858:: For each sprite, from 5 to 0, indexed by [0B]:\n
P:1185C:: Get current loop index from [0B].
P:1185E:: Add the current sprite's offset to the boss's X coordinate.\n Store it in [00].\n
P:11866:: Add the current sprite's offset to the boss's Y coordinate.\n Store it in [01].\n
P:1186E:: Calculate sprite attributes:\n [03] := (invincibility timer AND 3) XOR 3\n\n If the boss is temporarily invincible, then\n this makes it flash by cycling all the palette rows.\n\n Otherwise invincibility timer = 0. So [03] becomes 3:\n the attribute value for a normal sprite with palette row 7 (level).\n
P:11879:: Look up the tile for this sprite.\n If it's not the first one (face), then go write the sprite record.\n
P:11881:: Else it's the first one (the face tile).\n For timer >= $20, use it as is ($CC). Otherwise, use tile $C0.\n\n $CC/CD shows the closed mouth face.\n $C0/C1 shows the open mouth face.\n
P:11887:: Open mouth tile
P:1188C:: Bottom of the loop.\n Decrement tile index and loop index.\n
P:11893:_WriteBossSprite: Params:\n A: tile\n [00]: X\n [01]: Y\n [03]: sprite attributes\n\n Save the tile
P:1189B:: Restore the tile
P:118A9:UpdateDodongo
P:118BA-118BC:DodongoBloatedWaitTimes
P:118BD:_UpdateDodongoState
P:118C8:_UpdateDodongoState0_Move: If facing left, then push X offset 0 on the stack.\n Else push X offset -$10, and add $10 to X coordinate.\n\n We would like to use one set of coordinates only.\n But movement would break down, if we did; because\n Dodongo is so long.\n\n So, when not facing left, we temporarily shift the\n X coordinate to be closer to the other side of the monster.\n
P:118DB:: Turn rate $20
P:118E3:: Pop the offset and add it to the X coordinate.\n\n This brings the X coordinate back to the unique value\n that represents the position.\n
P:118E9:: If X coordinate < $20, then face right.\n
P:118F2:_UpdateDodongoState2_Stunned: Take action depending on the value of stun timer:\n 0:     set stun timer to $20 \n 1:     go back to state 0\n other: return\n
P:11900:_UpdateDodongoState1_Bloated
P:11910:_UpdateDodongoState1_Bloated_Sub_Wait: Bloated timer =>\n 0:     fall thru to set a new timer and check bomb hits\n 1:     go advance the substate\n other: go decrement Bloated timer\n
P:11918:: Set the bloated timer according to the substate.\n
P:11921:: If substate <> 0, go decrement bloated timer.\n
P:11925:: Deactivate the bomb in the first bomb slot ($10).\n
P:1192C:: Increment the number of bomb hits.\n
P:11938:: Advance the substate.\n
P:1193B:: If new bloated substate < 2, then go decrement the bloated timer.\n
P:11942:: New bloated substate >= 2.\n\n If bomb hits < 2, then set bloated substate 4,\n which will transition to state 0 (moving).\n\n Note that if the bomb hits >= 2, then:\n - If new substate = 2, then substate 2 will wait,\n   and then transition to substate 3.\n - If new substate = 3, then the next frame the monster will die.\n
P:1194E:_L_Dodongo_DecrementBloatedTimer: Either way, decrement the bloated timer.\n
P:11952:_UpdateDodongoState1_Bloated_Sub_Die
P:11958:_UpdateDodongoState1_Bloated_Sub_End: Go to state 0.
P:1195B:: Reset bloated substate.
P:1195F:_CheckDodongoCollisions: Check for collisions using a regular monster size.\n
P:11962:: If harmed, then go die.\n
P:11967:: If facing vertically, then return.\n
P:1196D:: Save the X coordinate.\n Then add $10 to check the right-hand side.\n
P:11978:: Restore the X coordinate.\n
P:1197B:: If not harmed, then return.\n
P:11983:: Drop a bomb from this fight.\n
P:1198A:_CheckDodongoCollisionsStandardSize
P:11992:: If state <> 2 (stunned), then return.\n
P:11998:: Take out the bit for the sword in the invincibility mask.\n Check for collision with Link's sword.\n
P:119A5-119A9:DodongoMouthNegativeLimits0
P:119AA-119AE:DodongoMouthPositiveLimits0
P:119B9:_CheckBombHit: If state <> 0 (not moving), then return.\n
P:119BD:: If facing vertically, then store (X + 8) in [00].\n Else store (X + $10).\n
P:119CC:: Store (Y + 8) in [01].\n
P:119D2:: Only check the first bomb slot ($10).\n\n Store the bomb's (X + 8) in [02].\n
P:119DB:: Store the bomb's (Y + 8) in [03].\n
P:119E2:: But, if there's no bomb, then return.\n
P:119E7:: If the bomb has not exploded (state $12), then\n go see if Dodongo will eat it.\n
P:119EB:: If the object in the slot is actually a fire, then return.\n
P:119EF:: The bomb already blew up.\n If the dust cloud is in range of the monster,\n then set stunned state (2).\n
P:119FB:: Try to eat the bomb.\n\n If the bomb is not in range of the monster, then return.\n\n This is a coarse test, to see if the bomb is over any part of the monster.\n
P:11A02:: Will loop from 1 to 0, indexed by [00].\n
P:11A06:: Shift facing direction right 1 to make an index. Value 3 is unused.\n
P:11A0A:: Now we have to see if it's near the mouth. But the mouth\n position depends on the orientation of the monster.\n\n Start with the horizontal distance.\n
P:11A0C:: Look up the limits for the given direction.\n\n If the distance from the bomb < negative limit,\n or >= positive limit, then return.\n\n Note that these are simple signed comparisons that work,\n because the operands are in a small range.\n
P:11A16:: Add $A to the index to look into the second set for vertical limits.\n
P:11A1B:: Bottom of the loop.\n\n Load the vertical distance for the next iteration.\n Decrement loop counter.\n
P:11A21:: If we get here, then the bomb was within range of the mouth.\n Go to state 1 (bloated).\n
P:11A23:: Deactivate the bomb, and reset the bloated substate.\n
P:11A2E-11A2F:DodongoBombPositiveLimits
P:11A30-11A31:DodongoBombNegativeLimits
P:11A32:_Dodongo_IsBombInRange: Params:\n Y: limit index (0 for dust cloud, 1 for the bomb)\n [00]: monster hotspot X\n [01]: monster hotspot Y\n [02]: bomb hotspot X\n [03]: bomb hotspot Y\n\n Returns:\n A: 0 if the bomb is in range of the monster\n Z: 1 if the bomb is in range of the monster\n [04]: horizontal distance\n [05]: vertical distance\n\n Store the positive limit in [06], and the negative one in [07].\n
P:11A3C:: Set [08] to 3. It will be shifted right once for each axis that\n the bomb is near enough the monster.\n
P:11A40:: For each coordinate (Y/X), from 1 to 0, indexed by Y register:\n
P:11A42:: Subtract the bomb's coordinate from the boss's,\n The loop index determines the coordinate.\n
P:11A49:: If the distance >= positive offset, or < negative offset;\n then loop again.\n
P:11A4D:: [07] negative offset
P:11A51:: The distance is close enough in this axis.\n\n Store the distance in this axis in [05] or [04],\n depending on the loop index.\n
P:11A54:: Shift [08] right, because we're in range in this axis.\n
P:11A59:: If close enough in both axes, then [08] will be 0.\n
P:11A5C-11A65:DodongoFrameImages: Two sets of frame image numbers: 1 set for each animation frame.\n Each set contains 5 frame image numbers, indexed by direction.\n\n But these are not typical direction indexes. Instead a\n 5-way index is used.\n A direction shifted right once becomes a 5-way index.\n The fourth element is unused.\n
P:11A66-11A6F:DodongoFrameHFlips
P:11A70-11A79:DodongoFrameImagesBloated
P:11A7A-11A83:DodongoFrameHFlipsBloated
P:11A84:_DrawDodongo
P:11A87:: Make a 5-way direction index out of the facing direction\n by shifting right once, and store it in [00].\n
P:11A8C:: If state = 0, go handle animating the two frames of this state.\n
P:11A90:: If state > 1, then the monster is stunned (state 2).\n So, go switch frames every $20 screen frames.\n
P:11A95:: State = 1. Bloated.\n\n In substate 0, go animate and as usual for walking.\n
P:11A9A:: If in bloated substates 2 or 3 (last wait or die), then\n go fade the boss; so that some frames are not drawn.\n
P:11AA2:: State 1, substate 1\n\n Add $14 to the frame image index to index into the bloated\n frame images and H-flips.\n
P:11AAB:: In bloated substates 2 and 3:\n Every two screen frames, don't draw for two frames. Return.\n
P:11AB6:: Every 8 screen frames, switch between 2 animation frames.\n
P:11ABE:: For animation frame 1, add 5 to the index in Y register,\n in order to index into the second set of frame image numbers.\n
P:11AC3:: Start preparing sprites.\n
P:11AC6:: Save the frame image index (not frame image number).
P:11AC8:: Get the horizontal flipping and frame image number for this frame image.\n
P:11ACB:: [0F] horizontal flipping
P:11AD0:: Frame image numbers 7 and 9 are vertical bloated frame images.\n They are drawn mirrored.\n
P:11ADE:: No other frame images are mirrored.\n
P:11AE1:: Restore the frame image index
P:11AE3:: If facing vertically, then return. There's no other side to draw.\n
P:11AE9:: Else draw the right side.\n\n Keep the Y coordinate in [01].\n But, store (X + $10) in [00].\n
P:11AF3:: XOR'ing the low bit swaps the left and right frame numbers.\n\n So, if we had animation frame 1, direction left:\n - 5-way direction index = 1 (2 >> 1)\n - frame image index = 6 (1 + 5)\n   (dodongo/walk/right/right half/anim frame 1)\n - frame number = 3 (look up element 6 in frame image array)\n - horizontal flip = true (loop up element 6 in H-flip array)\n\n So, 3 would have been the frame number used above for\n the left side.\n\n Here, the frame number is 2 (3 XOR 1), meaning\n (dodongo/walk/right/left half/anim frame 1). The horizontal\n flipping flag is unchanged. So, this left half frame is shown correctly\n on the right.\n
P:11AFB:Anim_SetSpriteDescriptorLevelPaletteRow: Returns:\n A: 3\n [04]: left sprite attributes\n [05]: right sprite attributes\n
P:11B20:InitDarknut: Invincible to everything but sword and bomb.
P:11B25:: If the darknut is red, then move at q-speed $20 (0.5 pixels a second).\n
P:11B2E:: Else move a blue darknut at q-speed $28 (0.625 pixels a second).\n
P:11B36:UpdateGibdo: Turn rate $80
P:11B3E:: 8 screen frames an animation frame
P:11B46:: Frame image 0
P:11B4B:UpdateDarknut: Turn rate $80
P:11B53:: Darknuts are never stunned.\n
P:11B57:: 8 screen frames an animation frame
P:11B5C:: If facing left, then enable horizontal flipping.\n
P:11B64:: Shift right 2, yielding: 2 up, 1 down, 0 horizontal\n This is the base frame image.\n
P:11B66:: TODO: name: movement frame\n If movement frame = 1, add 3 to frame image to access\n the second animation frame's images.\n
P:11B6E:: TODO: name: movement frame\n Also if movement frame = 1, and facing up, then flip horizontally.\n\n Down has two frame images, but up only has one. By flipping\n horizontally, you get two frame images.\n
P:11B7A-11B83:PolsVoiceWalkSpeedsX
P:11B84-11B8D:PolsVoiceWalkSpeedsY
P:11B8E-11B95:PolsVoiceInitialJumpSpeeds
P:11B96-11B9D:PolsVoiceDestinationYOffsets
P:11B9E-11BA1:PolsVoiceDirections
P:11BA2:UpdatePolsVoice
P:11BA6:: If we have the magic clock, or is stunned, then\n go draw and check collisions.\n
P:11BAD:: Every odd screen frame, go straight to drawing\n and checking collisions.\n
P:11BB2:: Otherwise move horizontally.\n
P:11BB5:: If state <> 0, then the monster is jumping.\n Go handle vertical movement.\n
P:11BBF:: State 0. Walking.\n\n If grid offset = 0, then no more distance to cover.\n So, go change to state 1 -- jumping.\n\n MULTI: [0394]\n
P:11BC4:: Decrement grid offset / distance remaining.\n\n MULTI: [0394]\n
P:11BC7:: Move vertically.\n Add the Y offset for the current direction to the Y coordinate.\n
P:11BCF:: If the square the monster is over is walkable, then\n go draw and check object collisions.\n
P:11BD4:: If the unwalkable tile is a block, or >= $F4 (water, screen edge bricks),\n then go change to state 1.\n
P:11BE1:: Else blocked by something else.\n\n If facing horizontally, then go flip the direction, move, and draw.\n
P:11BE7:: Else facing vertically. Flip the direction.\n Go draw.\n
P:11BF0:: Facing horizontally. Flip the direction.\n Move two pixels, and go draw.\n
P:11BFD:: If already in state 1, then go draw and check collisions.\n
P:11C01:: Go to state 1.\n
P:11C03:: Subtract 1 from facing direction to make an index.\n
P:11C06:: If Y coordinate < $78, make the index 3 for down.\n
P:11C0E:: If Y coordinate >= $A8, make the index 7 for up.\n
P:11C14:: Set the vertical speed for the beginning of the jump.\n
P:11C1A:: Look up the Y offset for the current direction.\n Add it to object Y to set the destination Y of the jump.\n
P:11C23:: Turn the index into a direction again by adding 1.\n Store the facing direction.\n
P:11C26:_L_DrawPolsVoiceAndCheckCollisions: Animation counter 8
P:11C31:: Pols Voice is invincible to everything but the sword,\n during normal collision detection.\n\n The arrow is a special case.\n
P:11C3A:_UpdatePolsVoiceState1_Jumping: Add acceleration $38 to low speed byte (vertical).\n
P:11C43:: Add Carry to high speed byte (vertical).\n
P:11C4B:: Add high speed byte to Y coordinate.\n
P:11C50:: If the speed is still negative, then return.\n
P:11C55:: If Y coordinate still < target Y, then return.\n
P:11C5C:: Else reached the destination. Go to state 0.\n
P:11C60:: Reset 16-bit vertical speed.\n
P:11C66:: Choose a random direction to face in.\n
P:11C70:: Randomly set distance-to-move to $30 or $70.\n
P:11C76:: MULTI: [0394]
P:11C79:: Align the monster with a square horizontally.\n\n If in the left half of a square, align with that square.\n If in the right half, align with the next square.\n
P:11C82:: Align the monster with a square vertically.\n\n If in the top half of a square, align with that square.\n If in the bottom half, align with the next square.\n
P:11C89:: Make sure the lower nibble of Y is $D as usual.\n
P:11C8F:PolsVoice_IsSquareWalkable: Returns:\n C: 0 if walkable\n [041F][X]: tile\n
P:11C92:: If there's an unwalkable tile at the usual hotspot, then return.\n
P:11C94:: Save the original object X, and temporarily add $E to it.\n
P:11C9C:: Save the original Y, and temporarily add 6 to it.\n
P:11CA4:: Check again at relative hotspot ($E, $E).\n
P:11CA7:: Restore the original coordinates.\n
P:11CAE:PolsVoice_GetCollidingTile: Returns:\n C: 0 if walkable\n [041F][X]: tile\n\n Use offset 0 from the hotspot.\n\n TODO: But where is [0F] set?\n
P:11CB6:: Return C=0 if walkable.\n
P:11CB9:: Remember the tile that the monster is over.\n
P:11CBD:PolsVoice_MoveX: Returns:\n Y: facing direction - 1 (so, 0 to 7)\n\n Add the X offset for the current direction to the X coordinate.\n
P:11CC9:UpdateLikeLike: If the monster captured Link, then go handle it.\n
P:11CCE:: Turn rate $80
P:11CD3:: Like-like has a 4 animation frame cycle unlike most monsters\n which have 2.\n
P:11CE7:: Draw.\n
P:11CF0:: Check collisions. If Link was not captured, then return.\n
P:11CF8:: The monster captured Link.\n Put the monster at the same location as him.\n
P:11D00:: TODO:\n Reset Link's timer, metastate? , and shove info.\n
P:11D0B:: Restart the monster's movement frame cycle: frame 0, counter 4\n
P:11D13:: Now Link can't move.\n
P:11D17:: Animate up to frame 3. Then stay there.\n
P:11D2A:: Increment capture time.\n
P:11D2D:: Once capture time >= $60 screen frames, remove the magic shield.\n
P:11D39:: Set a value above $60 over and over.\n
P:11D3E:: In this state, we have to draw Like-like over Link.\n So, don't use the usual sprite writing code that cycles sprites.\n
P:11D47:: Check object collisions.\n If this monster hasn't died, then return.\n
P:11D4F:: But once it has died, then let Link move again.\n
P:11D57:UpdateVire
P:11D5A:: If state >= 2, then go split up into 2 keeses.\n
P:11D66:: As with Zol, we'll destroy one monster, and make two.\n So, increase object count by 1.\n
P:11D6C:: Two times, look for an empty monster slot.\n If one is found, then use the "shoot" operation to create a red keese.\n
P:11D6E:: Save loop counter.
P:11D75:: Red Keese object type
P:11D7C:: Restore loop counter.
P:11D82:UpdateVireState
P:11D8B-11D9A:VireJumpOffsets
P:11D9B:UpdateVireState0: Turn rate $80
P:11DA0:: If we have the clock, or monster is stunned; then return.\n
P:11DA7:: If going vertically, then return.\n
P:11DAD:: Get the absolute value of the grid offset (0 to $F);\n so it becomes an index into the jump offset array.\n
P:11DB4:: Add the vertical offset; so that as the vire moves left or right,\n it jumps.\n
P:11DBD:CheckVireCollisions: If state <> 0, then the vire's going to split up.\n So, no need to check collisions. Return.\n
P:11DC4:: If it was killed, then return.\n
P:11DC9:: If temporarily invincible, then it was harmed.\n Advance the state to split up.\n
P:11DD1:DrawVire: Animation counter $A
P:11DD6:: TODO: name: movement frame\n\n The movement frame is the fram image number, unless facing up.\n In this case, add 2 to the frame image.\n
P:11DE3:UpdateBlueWizzrobe: Description:\n Blue Wizzrobe has two states: walking and teleporting.\n When walking, the object timer is set. When teleporting,\n the teleporting distance remaining is set.\n\n If we have the magic clock, then only go draw and check collisions.\n
P:11DEE:_DrawWizzrobeAndCheckCollisionsIntermittently: If the teleporting distance remaining is even, then draw\n and check collisions, else return.\n\n This means that when 0, the monster is walking.\n So, draw and check collisions every frame.\n\n When not 0, the monster is teleporting, and must be drawn\n translucently -- every other frame.\n
P:11DF7:BlueWizzrobe_WalkOrTeleport: If timer has not expired, then go walk.\n
P:11DFB:: Timer = 0. Only teleporting now.\n\n If there is still distance to go while translucent, then\n decrement the distance remaining, and move.\n
P:11E06:: Distance remaining = 0. Still teleporting.\n
P:11E0C:: Timer:\n   >= $10: Turn if needed and move every other frame\n   > 1:    Do nothing\n   = 1:    Choose a place to teleport to.\n\n Notice that walking is slower than teleporting; and there is\n a pause of $10 frames at the end.\n
P:11E18:: Every other frame, advance the turn counter, turn if needed,\n and move.\n
P:11E1D:_BlueWizzrobe_TurnSometimesAndMoveAndCheckTile
P:11E20:BlueWizzrobe_MoveAndCheckTile
P:11E26:: If walkable, then return.\n
P:11E28:: Go handle a wall, if the tile is not a block nor water.\n
P:11E35:: If the monster was already teleporting, then return,\n so that it moves again next frame.\n
P:11E3A:: Else go start teleporting thru this obstacle.\n
P:11E3D:: The monster hit a wall.\n If facing direction has a vertical component, then flip it.\n
P:11E4A:: If facing direction has a horizontal component, then flip it.\n
P:11E58:_BlueWizzrobe_AdvanceCounterAndTurnTowardLinkIfNeeded: Description:\n Increment the turn counter. Then turn toward Link\n when the turn counter is a multiple of $40.\n\n Increment the turn counter.\n
P:11E5B:_L_BlueWizzrobe_TurnTowardLinkIfNeeded: Description:\n When the counter is a multiple of $40, switch between facing\n toward Link horizontally or vertically. All other times, return.\n
P:11E62:_BlueWizzrobe_TurnTowardLink: If the multiple of $40 is even, then turn horizontally,\n else vertically.\n
P:11E69:: If the monster's X >= Link's X, then choose left, else right.\n
P:11E75:: If the monster's Y >= Link's Y, then choose up, else down.\n
P:11E7E:: If the direction chosen = facing direction, then return.\n
P:11E82:: Else face toward Link.\n
P:11E87-11E91:BlueWizzrobeTeleportOffsetsX
P:11E92-11E9C:BlueWizzrobeTeleportOffsetsY
P:11E9D:BlueWizzrobe_Move: TODO:\n Consider calling this function something like MoveSimple8.\n Also, consider deleting the references to BlueWizzrobe in\n teleport offsets above.\n\n Index the offsets using the direction value directly.\n
P:11EB0-11EB3:BlueWizzrobeTeleportMaxOffsetsX
P:11EB4-11EB7:BlueWizzrobeTeleportMaxOffsetsY
P:11EB8-11EBB:BlueWizzrobeTeleportDirs
P:11EBC:BlueWizzrobe_ChooseTeleportTarget: Choose a random value between 0 and 3 that will be used\n to test and set a direction to move in.\n
P:11EC1:: The random value implies a random direction.\n Save the original X coordinate; and add to it the offset for\n the random direction.\n
P:11ECA:: Save the original Y coordinate; and add to it the offset for\n the random direction.\n
P:11ED3:: Save the random index.
P:11ED5:: Test the walkability in the random direction chosen.\n
P:11EDC:: Restore the random index.
P:11EDE:: Restore the original Y.
P:11EE1:: Restore the original X.
P:11EE4:: If not walkable, then all we can do is align with the nearest square.\n
P:11EE6:: Set the random diagonal direction.\n
P:11EEB:: Will move $20 pixels horizontally and vertically.\n
P:11EF0:: Flip bit 6 of turn counter; so that we change the axis to turn toward.\n
P:11EF8:: Reset the timer to note that the monster is teleporting.\n Align with the nearest square.\n
P:11EFC:_BlueWizzrobe_AlignWithNearestSquareAndRandomizeTimer: Set a random timer >= $70.\n
P:11F02:_BlueWizzrobe_AlignWithNearestSquare: If in the left half of a square, jump to the left edge.\n Else jump to the next square.\n
P:11F0B:: If in the top half of a square, jump to the top edge.\n Else jump to the next square.\n
P:11F10:_AlignAndSetRedWizzrobeY: Params:\n A: Y coordinate, square ($10) aligned\n
P:11F18-11F21:WizzrobeCollisionOffsetsX
P:11F22-11F2B:WizzrobeCollisionOffsetsY
P:11F2C:_GetWizzrobeCollidableTile: Params:\n X: object index\n\n Returns:\n C: 0 if walkable\n
P:11F2E:_GetWizzrobeCollidableTileForDir: Params:\n X: object index\n Y: 8-way direction\n\n Returns:\n C: 0 if walkable\n\n Subtract 1 from direction to make an 8-way direction index.\n
P:11F2F:: Look up and add the collision offset to the monster's X coordinate.\n
P:11F31:: Save the original X.
P:11F38:: Look up and add the collision offset to the monster's Y coordinate.\n
P:11F3A:: Save the original Y.
P:11F44:: Restore the original Y.
P:11F47:: Restore the original X.
P:11F4B:_GetWizzrobeBaseCollidableTile: Params:\n X: object index\n\n Returns:\n C: 0 if walkable\n
P:11F51:: Return C=0 if walkable.\n
P:11F54:: Store the last collided tile.\n
P:11F58:BlueWizzrobe_TryShooting: Once every $20 frames, and when not fading, we'll try to shoot.\n Otherwise, return.\n
P:11F63:: If Link and the monster are not within the same square row,\n then go see about the same square column.\n
P:11F71:: If the monster is to the right of Link, then choose left.\n Else choose right.\n
P:11F7A:: If the direction chosen = the monster's facing direction,\n then go shoot.\n
P:11F7F:: If Link and the monster are not within the same square column,\n then return.\n
P:11F8B:: If the monster is down from Link, then choose up.\n Else choose down.\n
P:11F94:: If the direction chosen <> the monster's facing direction,\n then return.\n
P:11F9A:ShootMagicShot: Params:\n A: shot object type\n
P:11F9C:: If we have the magic clock, then return.\n
P:11FA1:: Else play the magic sound, shoot, and return.\n
P:11FA9:UpdateRedWizzrobe: If we have the magic clock, then go check collisions and draw.\n
P:11FB1:: Else increase animation counter and decrease state every frame.\n
P:11FB6:: Shift the state right 6 times to get the index (0 to 3) of a state routine.\n
P:11FC9-11FD8:RedWizzrobeOffsetsX
P:11FD9-11FE8:RedWizzrobeOffsetsY
P:11FE9-11FEC:RedWizzrobeDirections
P:11FED:_UpdateRedWizzrobe_1: Handle state group 1 ($40 to $7F).\n\n If state = $7F, make it $4F.\n $7F is the first frame of state group ($40 to $7F).\n By doing this, we skip $30 frames.\n
P:11FF7:: Increment the fade counter. Depending on the low bit,\n the monster will be drawn every other frame.\n
P:11FFD:_UpdateRedWizzrobe_3: Handle state group 3 ($C0 to $FF).\n\n If state <> $FF, go fade as in state group 1.\n
P:12002:: State $FF.\n\n Face in a random direction.\n
P:12004:: Save the random value.
P:1200D:: Restore the random value.
P:1200E:: Use a random value from 0 to $F to index into an array of offsets.\n
P:12013:: Add the X offset and Link's X to set the monster's position.\n
P:12016:: Align with a square.
P:1201A:: Add the Y offset and Link's Y to set the monster's position.\n
P:1201D:: Add 3 to help with the alignment calculation below.
P:12025:: If Y coordinate >= $5D and < $C4, then the monster\n is not in a wall. So, check tile collision.\n
P:12030:: If walkable, then return.\n Else increase state to 0, in order to check again next frame.\n
P:12034:_UpdateRedWizzrobe_0
P:12035:_UpdateRedWizzrobe_2: Handle state group 2 ($80 to $BF).\n\n If state = $B0, then shoot a magic shot $59.\n
P:12040:_DrawWizzrobeAndCheckCollisions: Invincible to everything but sword and bomb.\n
P:12048:: If invincibility timer = 0, then check collisions with weapons.\n
P:12061:: In this state, the monster can always harm Link,\n even if it can't be harmed.\n
P:12064:: Every 4 frames switch between two frame images.\n
P:1206B:: Save the frame image number.
P:1206F:: If facing up, then go add 2 to frame image number, and draw mirrored.\n
P:12075:: If facing left, then flip horizontally.\n
P:1207C:: Restore the frame image number.
P:12082:: Up facing frame image numbers are 2 and 3.
P:12087-1208C:GleeokSegmentYs
P:1208D:InitGleeok: TODO: ?\n
P:12092:: Loop 6 times to initialize each segment of 4 necks.\n
P:12094:: Set the X of the current segment of each neck to $7C.\n
P:120A2:: I don't think this one is needed.
P:120A4:: Look up and set the Y of the current segment of each neck.\n
P:120B3:: I don't think this one is needed.
P:120B5:: Set HP of each neck to $A0.\n\n Because there's only one HP value for each neck,\n it's stored right in the object slot -- unlike coordinates.\n\n Also, note that even though these aren't independent objects\n in the object slots -- because object type = 0 -- the values in\n these object slots will be useful during collision detection.\n
P:120BA:: Reset metastate and unintialized flag, so that this neck is ready to go.\n
P:120BF:: TODO: Is this a mistake? (+2)
P:120C2:: Invincible to everything but the sword.\n
P:120C7:: Bottom of the loop.\n
P:120CA:: Set speed flags to $FF (non-0/decelerate):\n * neck 0 X\n * neck 1 Y\n * neck 2 X\n * neck 3 Y\n\n Leave the other other speed flags 0 (accelerate).\n
P:120D6:: Set the V-direction counter of all necks to 3.\n
P:120E4:: Set the H-direction counter of all necks to 6.\n
P:120F1:: Set neck 1 head delay timer to 12.\n
P:120F5:: Set neck 2 head delay timer to 24.\n
P:120F9:: Set neck 3 head delay timer to 36.\n
P:120FF:: Leave neck 0 head delay timer as 0.\n
P:12100-12104:ManhandlaBaseFrameImagesAndAttrs
P:12105-12106:ManhandlaSegmentOffsetsX
P:12107-1210B:ManhandlaSegmentOffsetsY
P:1210C:InitManhandla: TODO: ?\n
P:12111:: Choose a random 8-way direction.\n
P:1211B:: For 5 segments, from 4 to 0, indexed by Y register:\n Object slots 5 to 1 are accessed.\n
P:1211D:: Copy the direction from the base segment.\n
P:12122:: All segments are considered Manhandla.\n
P:12127:: Set the segment invincible to fire and boomerang.\n
P:1212C:: Look up and store the base frame image and sprite attributes byte.\n\n While updating, the low bit will be flipped on and off\n for each animation frame.\n
P:12132:: All segments start out autonomous, and can update immediately.\n
P:1213A:: Copy object attributes and HP from the base segment.\n
P:12146:: Look up the offset of this segment. Add it to the position of\n the base segment.\n\n The position of the base segment in slot 5 is calculated first.\n Its base position is the spawn position.\n
P:12158:: Set low speed byte $80.\n
P:12161:InitGohma: TODO: ?\n
P:12166:: Invincible to everything but arrows.\n
P:1216B:: Set shoot timer to 1, so that Gohma doesn't shoot right away.\n
P:1216E:: Start at location ($80, $70).\n
P:12179:InitGleeokHead
P:1217C:: Set flying speed $BF and maximum $E0.\n
P:12187:UpdateManhandla: If this segment is not the base, then skip turning and speeding up.\n
P:1218B:: If no segment just died, then skip increasing the speed.\n
P:12190:: For each segment from 4 to 0, indexed by Y register:\n
P:12192:: Add $80 to the low speed byte of this segment.\n\n MULTI: 041F+1\n
P:1219B:: Carry to the high speed byte of this segment.\n\n MULTI: 042C+1\n
P:121A6:: Reset the "a segment just died" flag.\n
P:121AB:: If there's a bounce direction, then assign it to the facing\n direction of all segments.\n
P:121B3:: If object timer = 0, then\n 1. set timer to $10\n 2. randomly choose to turn toward Link or turn randomly\n 3. assign the base's direction to all segments and bounce direction\n
P:121CC:: If this segment is the base, then remember the\n facing direction before moving.\n\n This is a continuation of the code above,\n which is also only for the base.\n
P:121DB:: If the direction changed after moving, then\n copy it to the bounce direction.\n
P:121E5:: Store in [00] the animation frame that you get from the frame accumulator:\n frame := ((accumulator AND $10) >> 4\n
P:121F0:: Copy the animation frame bit into the "frame image and\n sprite attributes" byte.\n
P:121FA:: If this segment is the base, then go draw.\n
P:121FE:: If the old and new "frame image and sprite attributes" variables\n are the same, then go draw.\n
P:12201:: This begins with value 0, because all room data was reset on entry.
P:12206:: Copy the new value to the old variable, so that they're the same.\n
P:12209:: If animation frame = 1, then go draw.\n\n The low bit of "frame image and sprite attributes" byte\n represents the animation frame.\n
P:1220C:: If the random value for the next slot up < $E0,\n or there's an object in slot 7; then go draw.\n\n The second condition keeps the number of fireballs <= 4.\n
P:12217:: TODO: Fireball object type $56
P:12225:_CheckManhandlaCollisions: Check collisions, but never let them interfere with movement.\n
P:12227:: Save the direction
P:1222A:: Save the timer
P:1222E:: Restore the timer
P:12231:: Restore the direction
P:12234:: Don't let the base segment be temporarily invincible.\n
P:12240:: If still alive, then return.\n
P:12248:: Don't let the base die on its own.\n If this is the base, then reset metastate, and return.\n\n The base only dies once the last hand dies.\n
P:12252:: At this point, we have a hand that just died.\n\n For each hand, from 3 to 0, indexed by 0:\n
P:12254:: Count how many are allocated.\n This includes the current dead one, and the other living ones.\n Store the count in [00].\n
P:12264:: Decrease by 1, to account for the current dead one.\n
P:12266:: If the count >= 0 (signed comparison), then\n go change this hand object to the dead dummy.\n
P:1226A:: The last hand died. So, kill the base.\n\n Change the base segment's object type to the dead dummy.\n Immediately set metastate to $10, instead of waiting for\n the dead dummy object's update routine to do it.\n Also set its timer to $10.\n
P:12279:: Set the "segment just died" flag.\n
P:1227D:: Dead dummy object type
P:12285:Manhandla_SetAllSegmentsDirection: Params:\n A: direction\n
P:1228E:Manhandla_Move: Implement a way of manifesting the fractional part of the speed\n in the movement.\n\n Let's say the 16-bit speed is $0140. If we only took the high\n byte to add to the coordinates, then the effective speed would\n be 1 pixel a second instead of 1.25.\n\n By keeping a speed accumulator, we can turn speed $0140\n into 1.25 pixels a frame over four frames, using this calculation:\n\n   (SA=speed accumulator, SH=speed high, SL=speed low)\n\n   SA := SA + (SL AND $E0)\n   [03] := SH + carry\n\n AND'ing the low speed byte with $E0 isn't strictly needed.\n
P:12293:: Add the low speed byte to speed accumulator.
P:1229A:: Assign (high speed byte + carry) to [03].\n
P:122A1:: Change coordinates by the speed amount/offset in [03]\n according to the direction.\n\n Start with a mask of $A1 in [02]:\n - low nibble represents the right direction\n - high nibble is used to set or clear carry as we go along\n
P:122A5:: If direction has a right component (1), then add offset to X coordinate.\n
P:122B2:: If direction has a left component (2), then subtract offset from X coordinate.\n
P:122B4:: Bit 7 of mask $A1 sets Carry now.
P:122C0:: If direction has a down component (4), then add offset to Y coordinate.\n
P:122C2:: Bit 6 of mask $A1 clears Carry now.
P:122CE:: If direction has an up component (8), then subtract offset from Y coordinate.\n
P:122D0:: Bit 5 of mask $A1 sets Carry now.
P:122DC:: To the frame accumulator, add:\n - a random value between 0 and 3\n - [03] the effective high speed byte calculated for this screen frame\n
P:122EC:: TODO:\n I don't see why this is needed.\n
P:122EF:DrawManhandla
P:122F2:: Push the "frame image and sprite attributes" value.\n
P:122F6:: Bit 7 is the sprite attribute for vertical flipping, and can be\n passed along as is.\n
P:122F8:: Use blue palette row.
P:122FD:: Get the "frame image and sprite attributes" value again.
P:122FF:: If bit 6 is set, then enable horizontal flipping in [0F].\n
P:12305:: Pop the "frame image and sprite attributes" value.
P:12306:: If the low nibble = 2 or 3, then go draw not mirrored.\n These are the 2 frame images of the horizontal hands.\n\n Else draw the base and vertical hands mirrored.\n
P:12316:UpdateGohma: If flagged not to continue straight, then choose a random facing direction.\n
P:1231B:: If Random:\n   >= $B0: right\n   >= $60: left\n   Else:   down\n
P:1232B:: Now we can go straight without changing direction for some time.\n
P:1232E:: Go animate the eye.\n
P:12331:: Add $80 to the movement accumulator.\n
P:1233A:: If movement accumulator didn't overflow, then go animate the eye.\n
P:1233C:: Increase the distance traveled, and move 1.\n
P:1233F:: Set a direction mask in [02], starting with right (1).\n
P:12343:: If Gohma's facing direction has a right component, then add 1 to X.\n
P:1234B:: If Gohma's facing direction has a left component, then subtract 1 from X.\n
P:12353:: If Gohma's facing direction has a down component, then add 1 to Y.\n
P:1235B:: If Gohma's facing direction has an up component, then subtract 1 from Y.\n
P:12363:: If Gohma has not traveled $20 pixels, then go animate the eye.\n
P:1236A:: Gohma has traveled $20 pixels. Reset the distance traveled.\n Reverse the facing direction, and increase the number of sprints.\n
P:12378:: If the previous number of sprints was odd, then flag that Gohma\n should randomly change direction.\n
P:12380:: Animate the eye.\n\n First, if the counter for when to open the eye next = 0, then\n set it to a random value at least $C0; and set the timer for\n keeping the eye open to $80.\n\n Note that $C0 is not a number of frames, because it's changed\n every other frame.\n
P:12391:: Decrement the next open eye counter.\n
P:12399:: If open eye timer = 0, then the eye is closed.\n Go animate it differently.\n
P:1239E:: Else decrement the open eye timer.\n
P:123A1:: If open eye timer >= $70 and < $10, then the eye is fully open.\n So, set its frame image to 2. Else use 3 for a half open eye.\n
P:123B0:: Decrement the shoot timer.\n
P:123B3:: If it became 0, then set it to $41, and shoot fireball $56.\n
P:123BF:: Pass the frame image for the eye.\n
P:123C8:: Here the eye is closed. So animate it this way.\n Increment the animation counter, and if <> 8, then\n go shoot, draw, and check collisions.\n
P:123D2:: Roll over the eye animation counter to 0.\n Clear bit 1 and invert bit 0 to switch between frame images 0 and 1.\n
P:123DE:: Go shoot, draw, and check collisions\n
P:123E1-123E2:GohmaLegOffsetsX
P:123E3:_AnimateAndDrawGohma: Params:\n A: eye frame image\n\n Draw the eye with the frame image passed in.\n
P:123F3:: Draw the right legs.\n
P:123F8:: Draw the left legs.\n
P:123FA:_Gohma_DrawLegsOneSide: Params:\n Y: side: 0 for left, 1 for right\n\n Add the horizontal offset for the current side to Gohma's X to\n store the sprite's X in [00].\n
P:12402:: The object's Y is the sprite's.\n
P:12409:: There are only two frame images for legs: left and right.\n There are two animation frames. They are animated as follows:\n\n Frame 0:\n ((leg index + frame number) AND 1) = 0 or 1\n horizontal flipping = frame number = 0\n \n Frame 1:\n ((leg index + frame number) AND 1) = 1 or 0\n horizontal flipping = frame number = 1\n
P:12411:: There are only two images.
P:12414:: Leg frame images start at 4.
P:12419:Gohma_SetSpriteAttributes: Returns:\n [04]: left side sprite attributes\n [05]: right side sprite attributes\n
P:12422:Gohma_CheckCollisions: Save the boss's X coordinate.\n
P:12425:: Subtract $10 from the X coordinate, so we start checking collisions\n on the left side.\n
P:1242A:: Check object collisions in 5 parts, 8 pixels apart,\n from left to right, indexed by [0F].\n
P:1242C:: Loop counter
P:12431:: Add 8 to the X coordinate for the next part.\n
P:12438:: Loop counter
P:1243C:: Restore the boss's X coordinate.\n
P:12440:Gohma_HandleWeaponCollision: TODO:\n If hit by an arrow, then set the arrow to spark\n
P:1244E:: If it did not hit part 3 nor 4, then go play the parry sound effect.\n
P:12458:: If the state of the eye is not 3, then go parry.\n
P:1245F:: If the direction of the arrow is not up, then go parry.\n
P:12466:: TODO:\n
P:1246B:: Deal damage and cry out.\n
P:12477:UpdateGleeokHead
P:1247D:: If the low bit of the distance traveled is clear,\n and Random < $20,\n and there's no object (fireball) in slot $B,\n then shoot a fireball $56.\n
P:12494:: Switch animation frames every screen frame.
P:124A2:: Reset object state, shove info, and invincibility timer,\n because this monster can't get hurt nor die.\n
P:124AC:ControlGleeokHeadFlight
P:124BA:_Flyer_GleeokHeadDecideState: Go to the next flying state randomly:\n Random < $D0: 2\n Else:         3\n\n Set up 6 turns.\n
P:124C6-124C9:GleeokNeckXAddrsLo
P:124CA-124CD:GleeokNeckXAddrsHi
P:124CE-124D1:GleeokNeckYAddrsLo
P:124D2-124D5:GleeokNeckYAddrsHi
P:124D6-124D9:GleeokNeckMiscAddrsLo
P:124DA-124DD:GleeokNeckMiscAddrsHi
P:124DE:UpdateGleeok
P:124E1:: Calculate the index of the last neck of this kind of gleeok.\n Subtract $42 (Gleeok1) from ObjType[1].\n
P:124E7:: TODO:\n For each neck, counting down, indexed by [04D7]:\n
P:124EA:: If the bit for this neck is in the dead neck mask,\n then go loop again.\n
P:124F8:: Get the addresses of this neck's segment data arrays.\n
P:124FB:: Load neck data.\n\n For each segment from 5 to 0, indexed by Y register:\n - load coordinates into object slots 6 to 1\n - load miscellany into an array at [0413]\n
P:1250D:: Each screen frame, one neck is chosen to move and try to shoot.\n
P:1251D:: The head is in object slot 5. Set it for when we want to shoot,\n so that it looks like the fireball came from the head.\n
P:1251F:: If Random < $20, and there's no object (fireball) in slot $B,\n then shoot fireball $56.\n
P:1252F:: This is run for all necks.\n
P:12532:: Store the neck data.\n
P:12547:: Bottom of the neck loop.\n Decrement the neck index until it < 0.\n
P:1254D:Gleeok_FetchNeckAddrs: Returns:\n X: neck index\n Y: 5 -- the last segment index\n [00:01]: address of segment X array\n [02:03]: address of segment Y array\n [04:05]: address of segment miscellaneous array\n
P:1256E:: Start loading data from segment 5.
P:12576:Gleeok_MoveNeck: Get the H-distance from the head to the base.\n
P:1257B:: If the difference is positive, then go divide by 4 unsigned.\n
P:1257D:: Else divide by 4 signed.\n
P:12585:: Store the signed reference segment distance.\n
P:12588:: Get the absolute horizontal reference segment distance.\n This is the first tier of reference distances.\n\n Pass the value here to calculate and store the\n second and third tier horizontal distances.\n
P:1258B:: 0 for horizontal distances.
P:12590:: Get the absolute V-distance from the head to the base,\n and divide it be 4.\n
P:1259A:: Calculate and store the second and third tier vertical distances.\n
P:1259E:: Keep segments within the third tier distance of each other.\n Any segment that is too far from the previous one is moved\n 2 pixels toward it.\n\n Loop over the 4 segments above the base, from 0 to 3,\n accessing slots 2 to 5.\n
P:125A0:: Get the absolute H-distance between the current segment\n and the previous one.\n
P:125A8:: If H-distance < third tier H-distance, then this distance is OK.\n Go look at the vertical distance.\n
P:125AD:: Otherwise, generally, bring this segment closer to\n the previous one by 2 pixels.\n
P:125BC:: Get the absolute V-distance between the current segment\n and the previous one.\n
P:125C4:: If V-distance < third tier V-distance, then this distance is OK.\n Go loop again.\n
P:125C9:: Otherwise, generally, bring this segment closer to\n the previous one by 2 pixels.\n
P:125D8:: Bottom of the loop keeping segments from getting too far apart.\n
P:125DD:: Stretch or contract depending on the distance of one segment to the next.\n
P:125E7:: TODO:\n\n [04D8] is the quarter horizontal distance from the head to the base.\n It represents the reference distance from each segment to the base.\n Multiples of it are used to mark the reference point of each segment.\n Move every segment one pixel closer to its reference point.\n\n Loop over each middle segment, from 2 to 0 in X register.\n Access object slots 4 to 2.\n
P:125E9:: Calculate the reference X coordinate:\n   base X + ([04D8] * (loop index + 1))\n
P:125F4:: If current segment X < reference X, add 1 to it.\n Else subtract 1.\n
P:125FD:: Store the new segment X, and loop again.\n
P:12602:: Keep the segments in slots 4 and 3 between their neighbors vertically.\n So if they're not, then move them 1 pixel toward that goal.\n
P:12621:_Gleeok_CalcSegmentLimits: Params:\n A: primary reference segment distance\n X: 0 for horizontal, 1 for vertical\n\n Store primary distance, capped at 4.\n
P:1262A:: Add 4 and store secondary distance, capped at 8.\n
P:12636:: Add 4 and store tertiary distance, capped at $B.\n
P:12643:Gleeok_StretchNeck: Params:\n X: segment index (0 to 2, corresponding to slots 2 to 4)\n\n Choose the index of a routine that will move the segment\n based on which boundaries are crossed.\n\n 0 will be used, if X and Y are within primary distances of\n the next segment.\n
P:12645:: If the absolute H-distance >= primary reference segment distance,\n then increment the routine index.\n
P:12648:: TODO: seems to be a mistake. shout probably be ObjX+2,X
P:12653:: If the absolute H-distance >= secondary reference segment distance,\n then increment the routine index.\n
P:12659:: If the absolute V-distance >= primary reference segment distance,\n then add 3 to the routine index.\n
P:12669:: If the absolute V-distance >= secondary reference segment distance,\n then add 3 to the routine index.\n
P:12687:Gleeok_ExpandSegment: Randomly, 50% of the time, go move away from the next segment horizontally.\n
P:1268B:: Else move away vertically.\n
P:1269C:Gleeok_IgnoreSegment
P:1269D:Gleeok_ContractSegmentY: Move toward the next segment vertically.\n
P:126AA:: Move away from the next segment horizontally.\n
P:126B5:Gleeok_ContractSegmentX: Move toward the next segment horizontally.\n
P:126C5:Gleeok_ContractSegment: Randomly, 50% of the time, go move toward the next segment horizontally.\n Else go move vertically.\n
P:126CB:: Description:\n This block applies to heads and the bottom segment of a neck.\n These are drawn with sprites that come first in order, so that\n they are drawn above all other sprites, including Link.\n\n Params:\n A: tile number\n\n Normal sprite with level palette row
P:126CD:: [03] holds sprite attributes
P:126CF:: Save the tile number.
P:126D0:: To calculate the base offset of the sprite record:\n offset := neck index * 8\n\n This ends up pointing to one of the first 8 eight sprites,\n at an even index.\n
P:126D6:: But if the segment is not a head (not at object slot 5), then\n add $20. This moves the offset to the second set of 8 sprites.\n
P:126DE:: Restore the tile number.
P:126E5:Gleeok_DrawHeadAndCheckCollisions: Head object slot
P:126E7:Gleeok_DrawSegmentAndCheckCollisions: Neck segment tile
P:126ED:: Head tile
P:126F7:: The segment is not a head nor bottom. So, we can use a\n standard routine to draw. It uses one of the rolling sprites\n that is drawn under Link and the heads.\n
P:126FA:Gleeok_CheckCollisions: If this segment is not the head nor the bottom of the neck,\n then loop again to process the next segment.\n\n This kind of segment is only drawn, and is not checked\n for object collisions.\n
P:12708:: If this segment was harmed, then set the writhing counter,\n and the animation counter to its lower value.\n
P:12718:: If this is the bottom segment, then go reset metastate and loop again.\n Gleeok can writhe when it's hit here, but it can't die.\n
P:1271F:: If this neck has not died, then go loop again.\n
P:12724:: This neck died. So, prepare to make a flying head.\n
P:12726:: TODO: I don't see why this is needed, since it won't go in this obj slot.
P:12729:: Save the segment object slot in X.
P:1272B:: If the segment is not a head, then skip making a flying head.\n\n TODO:\n But how can we get here in this case, since earlier branches\n would have been taken to skip all this for all other segments?\n
P:1272F:: The flying head will go in slot (neck index + 7).\n Switch the X register to it.\n
P:12736:: Flag it uninitialized, so that it will be initialized next frame.\n
P:1273B:: Copy the original head's coordinates to it.\n
P:12743:: Set object type $46 (flying head).\n
P:12748:: Restore the segment object slot in X.
P:1274A:: Hide the original head's sprite, and the base segment's sprite.\n
P:12759:: Add the bit for this neck to the dead neck mask.\n Copy it to [00].\n
P:12767:: Loop over the four bits in the copy of the dead neck mask.\n Count them up, and store the amount in [00].\n
P:12774:: Compare the number of dead necks to the original number\n (object type - $41).\n
P:1277C:: If they're equal, then go handle the whole boss dying.\n
P:1277E:: TODO:\n Else reset object metastate of the segment, and return.\n
P:12784:: Bottom of the segment loop.\n Decrement segment object slot.\n\n If >= 1, then go draw the next segment and check collisions.\n Else return.\n
P:1278C:: The whole gleeok died, because the last neck died.\n\n First, hide the first $10 sprites: the attached heads.\n
P:12792:: We want a death spark. So, set the metastate of the first\n monster slot to $11.\n
P:12797:: Reset the object type of slots 2 to $A.\n\n Beware a left over fireball in slot $B!\n
P:127A4:Gleeok_MoveHead: Don't do anything until the head's initial timer expires.\n
P:127A9:: Add 1 or -1 to X as needed.\n
P:127B3:: Add 1 or -1 to Y as needed.\n
P:127BD:: Increment the counter to change directions.\n If it's still < 4, then return.\n
P:127C7:: The counter reached 4. So, reset it.\n Then check the individual direction counters.\n
P:127CC:: Increment the horizontal direction counter.\n If >= $C, then reset the counter, and flip direction.\n
P:127E3:: Increment the vertical direction counter.\n If >= 6, then reset the counter, and flip direction.\n
P:127FF:_Gleeok_ChangeCoordinateBySpeedFlag: Params:\n A: a value to change\n Y: 0 => increment, 1 => decrement\n\n Returns:\n A: original value +/- 1\n
P:12809-1280E:GleeokBodyTiles0
P:1280F-12814:GleeokBodyTiles1
P:12815-1281A:GleeokBodyTiles2
P:1281B-1281E:GleeokBodyBaseTileOffsets
P:1281F:: Decrement animation timer, and go draw.\n
P:12825:Gleeok_DrawBody: The animation timer controls when the animation frame changes.\n If it has not expired, then go decrement it and draw.\n
P:1282A:: The animation timer has expired. There are two choices for arming it.\n\n When writhing after a hit, Gleeok animates faster.\n So, when the writhing counter <> 0, set a shorter time (6).\n Otherwise, set a longer time ($10).\n
P:12839:: Cycle the animation frame from 0 to 3.\n
P:12844:: For each row, from 0 to 1, indexed by [06]:\n
P:12848:: Get the base tile offset for the current animation frame.\n
P:1284E:: For each column from 0 to 2, indexed by [07]:\n
P:12852:: Point to the next rolling sprite record.\n
P:12859:: Set sprite's Y to ($57 + row * $10).\n
P:12864:: Look up and set the tile for this spot.\n
P:1286A:: If temporarily invincible, then set sprite attributes to\n cycled palette rows.\n\n Else use level palette row 7.\n
P:12876:: Set sprite's X to ($74 + column * 8).\n
P:12880:: Increment the index for fetching tiles.\n
P:12884:: Bottom of the column loop.\n Increment the column until it = 3.\n
P:1288C:: Bottom of the row loop.\n Increment the row until it = 2.\n
P:128C0-128C4:GuardFireXs
P:128C5-128C9:GuardFireYs
P:128CA:InitZelda: Make Zelda and 4 flames that guard her, in object slots 5 to 1.\n
P:128CC:: Look up and set the location of each object.\n\n MULTI: A8C0-1\n
P:128D1:: MULTI: A8C5-1\n
P:128D6:: Guard fire object type
P:128DE:: Replace the type of the object in slot 1 with $37: Zelda.\n
P:128E4:InitLamnola: Make $A segments.\n
P:128E6:: Starting location is ($40, $8D) and direction is 0.\n
P:128F5:: Each segment is flagged initialized and ready to update.\n
P:128FB:: This Lamnola that's making additional segments is in slot 1.\n Copy its object attributes, HP, and type to the others.\n
P:12910:: TODO:\n Only the heads in slots 5 and $A have a direction and [0380][X] set.\n
P:1291C:: Remember the object type, and set speed to (object type - $39):\n 1 or 2.\n
P:12928:: TODO:\n Do the heads not count?\n
P:1292E:InitPatra: Invincible to everything but sword.\n
P:12933:: Start at location ($80, $70) and facing up.\n
P:1293F:: Set flying speed $1F, and maximum $40.\n
P:12949:: TODO: set [0601] to $40\n
P:1294C:: Set object timer to $FF. When it runs out, the maneuver will be switched.\n
P:12950:: Patra type $47 goes with Patra Child type $25.\n Patra type $48 goes with Patra Child type $26.\n
P:1295B:: Loop over object slots 2 to 9, making patra children.\n
P:1295D:: [00] holds the patra child type.
P:12964:: Patra children are also only weak to the sword.
P:1296F:InitGanon: Invincible to everything but sword and arrow.
P:12974:: Halt Link.\n
P:12978:: Set Link's timer to $40 for scene phase 0.\n
P:1297A:: TODO: ?\n
P:12987:UpdateZelda
P:1298E:: State 0.\n\n If Link's X < $70 or >= $81, or Link's Y <> $95, then return.\n
P:1299E:: Else Link is near enough to Zelda.\n Go to state 1, and halt Link.\n
P:129A4:: Put Link at location ($88, $88) and facing left.\n
P:129AE:: TODO: ?\n
P:129B3:: Set a delay of $80 frames at the beginning of the next state.\n
P:129B8:: State 1.\n\n Draw Link, then return if the object timer <> 0.\n
P:129BF:: Go to mode $13.\n
P:129C9:: Mode $13 will start with a curtain furling effect.\n Set up the decreasing column ($20), and the increasing column (1).\n Prepare the background by filling the tile map with blank tile $24.\n
P:129D3:: [0A] tile to fill with
P:129D8:UpdateGuardFire: Animation counter 6
P:129E0:: If the object has not been killed, then return.\n Else change the object type to dead dummy.\n
P:129E5:_SetDeadDummyObjType
P:129EB:UpdateLamnola: If the direction of this segment is not set, then it has not started\n moving yet. So, return.\n
P:129EF:: If we have the magic clock, then go draw and check collisions.\n
P:129F7:: If the current segment is a head, then update the direction it's facing.\n
P:12A04:: Save the X coordinate.
P:12A05:: Each segment is a full 16x16 object. But, it's drawn as a narrow,\n half-width object. So, center it by temporarily adding 4 to X.\n
P:12A0A:: The speed is 1 or 2. By swapping them, you get sprite attributes\n to store in [03].\n
P:12A11:: If the segment is a head, then use tile $9E, else $A0.\n
P:12A20:: Restore the X coordinate.
P:12A23:: Save the facing direction.
P:12A29:: Restore the facing direction.
P:12A2C:: If still alive, then return.\n
P:12A31:: Otherwise, the segment is dead.\n
P:12A34:: Set the current segment's HP to the initial value in anticipation\n of bringing this segment back to life.\n
P:12A39:: Find the tail of the lamnola that the current segment belongs to.\n\n From the lowest slot, look for one that has the original lamnola\n object type.\n\n The goal is to swap the current dead segment with the tail segment.\n
P:12A4A:: Set the timer for the dead dummy object that will replace the tail.\n
P:12A4F:: Copy the current dead segment's invincibility timer, X, and Y\n to the tail segment.\n
P:12A5F:: If the tail segment found is a head, then the whole lamnola died.\n So, return and leave it dead.\n
P:12A67:: Change the tail segment to the dead dummy object, and\n bring the current segment back to life.\n
P:12A70:Lamnola_UpdateHead: If X coordinate is not a multiple of 8, then return.\n
P:12A76:: If (Y + 3) is not a multiple of 8, then return.\n We had to account for the usual offset of 3.\n
P:12A7F:: Will loop 4 times, propagating directions down the chain,\n by pulling from the bottom.\n
P:12A83:: Choose the tail index of the lamnola that the current segment belongs to.\n
P:12A8B:: Loop over every segment under the head, starting from the tail.\n Copy the next segment's direction to the current one in this loop.\n
P:12A96:: If this head segment is not aligned with a square, then return.\n
P:12A9C:: If (Y + 3) is not a multiple of $10, then return.\n We had to account for the usual offset of 3.\n
P:12AA5:: Store the opposite of the facing direction in [00].\n
P:12AB3:: Make a mask of the inverted bits of the opposite direction.\n
P:12AB8:: There's a 50% chance of going to try to turn toward Link.\n
P:12ABE:: Otherwise, we randomly choose a perpendicular direction.\n Load the monster's facing direction.\n
P:12AC0:: Load the next random number into Y register.\n
P:12AC2:: Based on it, there's a 50% chance of skipping the loop,\n to keep moving straight.\n
P:12AC6:: Loop to rotate the direction bit over the mask.\n The goal is to calculate a direction perpendicular to the monster's\n facing direction.\n\n Shift right the copy of the direction.\n If the direction bit rolled off the low end, then roll it onto the high end.\n
P:12ACB:: If the current direction bit is masked off, then we've reached\n the opposite direction. Loop again.\n
P:12AD0:: If Y register >= $40, then break out of the loop.\n So, 75% of the time, if horizontal, then turn up, else left.\n
P:12AD4:: Set Y register to $40 in order to break out of the loop next time;\n and loop again now.\n So, 25% of the time, if horizontal, then turn down, else right.\n
P:12AD8:: Change the facing direction to the direction found.\n
P:12ADA:: Set moving direction [0F] for boundary and tile checks.\n
P:12ADF:: If not blocked by the room boundary, then go check tile collision.\n
P:12AE3:: Else it was blocked. So, load the facing direction in preparation\n for looking for any non-opposite direction that is not blocked.\n
P:12AE5:: Shift right the copy of the direction.\n If the direction bit rolled off the low end, then roll it onto the high end.\n
P:12AEA:: If the current direction bit is not masked off, then go check the\n room boundary in this direction.\n Else we've reached the opposite direction. Loop again.\n
P:12AF1:: We found a direction that was not blocked by the room boundary.\n Check tile collision. If blocked by a tile, then go look for another direction.\n
P:12AF9:: TODO: confirm this\n\n If there were a room that had lamnolas, and they could get\n surrounded on 3 sides, then the loop above would get stuck in\n an infinite loop.\n\n But, the only room with that configuration has those blocks\n blocked off with a push block, which can only be pushed after\n all monsters are killed.\n
P:12AFA:: Find the horizontal direction toward Link and store it in [02].\n
P:12B07:: Find the vertical direction toward Link and store it in [03].\n
P:12B14:: If the horizontal direction toward Link is not allowed, then\n go check the vertical direction.\n
P:12B1B:: If the horizontal direction toward Link is the same direction\n that Link is facing, then go test it for tile and room boundary collision.\n
P:12B1F:: Load the vertical direction toward Link in order to test it for\n room boundary and tile collision.\n
P:12B21:: Go test this direction for collisions with tiles or the room boundary.\n
P:12B24:Lamnola_Move: This code is similar to 04:96EB Digdogger_Move.\n\n Change coordinates by the appropriate speed according to the direction.\n\n Start with a mask of $A1 in [02]:\n - low nibble represents the right direction\n - high nibble is used to set or clear carry as we go along\n
P:12B28:: If direction has a right component (1), then add offset to X coordinate.\n
P:12B36:: If direction has a left component (2), then subtract offset from X coordinate.\n
P:12B38:: Bit 7 of mask $A1 sets Carry now.
P:12B45:: If direction has a down component (4), then add offset to Y coordinate.\n
P:12B47:: Bit 6 of mask $A1 clears Carry now.
P:12B54:: If direction has an up component (8), then subtract offset from Y coordinate.\n
P:12B56:: Bit 5 of mask $A1 sets Carry now.
P:12B64:PatraManeuverTime: TODO:\n Was this intended to be an array of two elements?\n
P:12B66:UpdatePatra
P:12B69:: Reset flying distance traveled, so that we know what offset to\n apply to the children.\n
P:12B74:: 2 animation frames a screen frame
P:12B79:: Loop over the object slots of the 8 children.\n If any are found, then go check for collision with Link only.\n
P:12B7E:: Patra Child 1 object type
P:12B82:: Patra Child 2 object type
P:12B89:: If there are no children, then Link can harm Patra.\n
P:12B95:: Else there are child patras left.\n Link cannot harm Patra, but it can harm Link.\n
P:12B98:: If timer = 0 and the angle of patra child in slot 3 = 0, then\n flip the maneuver index.\n
P:12BA8:: TODO:\n for this to make sense, Y must be 0 or 1. But where is is set?\n
P:12BAE:ControlPatraFlight
P:12BBC:Flyer_PatraDecideState: Go to the next state randomly:\n Random >= $40: 2\n Else:          3\n\n Set up 8 turns.\n
P:12BCF-12BD5:PatraChildStartAngles
P:12BD6:PatraChild1RotationCosineBits
P:12BD7:PatraChild2RotationBits
P:12BD8-12BD9:PatraChild1RotationSineBits
P:12BDA:UpdatePatraChild: If state = 1, then go orbit.\n
P:12BDE:: State = 0.\n\n If the current object slot is 2, then go initialize the patra child.\n This is the only patra child shown in the first fame.\n
P:12BE2:: The patra child in slot 2 is the last one to be updated.\n So all other patra children will see slot 2's state = 0, and return.\n\n This means that in the first frame, slot 2 is the only one to be\n shown.\n
P:12BE6:: In subsequent frames, patra children in slots >= 3 will reach\n here to wait to be shown at the top position (N) one at a time.\n
P:12BE7:: Subtract 3 from the object slot to get the angle where the\n patra child in object slot 2 should be for the current one to appear.\n
P:12BEB:: If the patra child in slot 2 has not reached the required angle,\n then return.\n
P:12BF3:: Once the patra child in the last slot 9 reaches here, advance\n the patra parent's state.\n
P:12BF9:: Go to state 1 to orbit.\n
P:12BFB:: TODO: ?\n
P:12BFF:: Set angle $18 (N).\n
P:12C04:: This location is right above Patra.\n Set X coordinate to Patra's.\n
P:12C08:: If patra child type = $25, then the radius of its orbit is $2C.\n Else use radius $18. Store the chosen value in [00].\n
P:12C15:: This location is right above Patra.\n Set Y coordinate to (Patra's Y - [00]).\n
P:12C1D:: Add Patra's distance traveled since the last frame to this child's coordinates.\n
P:12C2D:: Reset [0B]. The high byte of the amount to subtract is 0.\n
P:12C31:: If the monster is type $25 Patra Child1, then decrease the\n monster's angle by $70, else by $60 to go slower.\n
P:12C3F:: Load Patra's maneuver index.\n It determines which counts of bits are looked up below.\n
P:12C42:: If the monster is Patra Child 1 ($25), then look up two separate\n counts of bits to use for Y and X increment calculations in rotation.\n This leads to a large circle (6,6) and a wobbling ring (5,6).\n
P:12C55:: Else it's Patra Child 2 ($26). Look up one value that will be used\n for both Y and X increment calculations in rotation. This leads to\n a small circle (5) and a large circle (6).\n
P:12C61:: If Patra's state still = 0, then the last patra child has not\n shown up yet. In this case don't check collisions yet, only return.\n
P:12C68:: If the monster died, then change to the dead dummy object.\n
P:12C71:_DrawPatraChild
P:12C74:: 2 was returned from the routine above in A.\n Pass it as the animation counter value to the routine below.\n
P:12C7D:UpdateGanon
P:12C89:Ganon_ScenePhase0: Description:\n Lift up the Triforce of Courage while the room is dark.\n\n Lift the Triforce of Courage -- represented with a triforce piece.\n
P:12C8E:: If Link's timer has not expired, then go do nothing until the last frame.\n
P:12C92:: Once the timer expires, it's time to brighten the room.\n\n Save the current object slot.
P:12C97:: Restore the current object slot.
P:12C99:: Turn off the room brightening flag, because we're controlling it\n here instead of in the Mode 5 object update loop.\n
P:12C9E:: On the first frame of the fade-to-light cycle, play the\n Triforce/Ganon song.\n
P:12CAA:: If the fade cycle has not ended, then go draw Ganon.\n
P:12CB3:: Set Link's timer to $C0 for the next scene phase.\n
P:12CB7:: Set scene phase 1, and go draw Ganon.\n
P:12CBC:: TODO:\n If state = 1, then\n
P:12CC6:Ganon_ScenePhase1: Description:\n Lift up the Triforce of Courage while the room is light.\n\n Lift the Triforce of Courage -- represented with a triforce piece.\n
P:12CCB:: If Link's timer hasn't expired, then go draw Ganon.\n
P:12CCF:: Once the timer expires:\n 1. unhalt Link\n 2. clear the item to lift\n 3. play level 9 song\n 4. go to scene phase 2: fighting / not holding triforce\n
P:12CDC:: When holding the Triforce of Courage, only draw Ganon\n with animation frame 0.\n
P:12CE4:Ganon_ScenePhase2: Description:\n Fighting Ganon.\n\n If Ganon is dying, go handle it.\n
P:12CEF:: Go handle the brown state specially.\n
P:12CF3:: State = 0: Blue\n\n If timer = 0, then go move around and shoot.\n
P:12CF7:: If timer > 1, then Ganon is blue and visible. Only draw.\n Collisions were checked already.\n\n Else timer = 1. Fall thru and randomize Ganon's location,\n in anticipation of moving around when timer becomes 0 next frame.\n
P:12CFB:_Ganon_RandomizeLocation: Description:\n Put Ganon at Y=$A0, and a random X of $30 or $B0.\n
P:12D0A:: Change the animation frame every screen frame; so that\n when Ganon is hit, he appears in a random pose.\n
P:12D0D:: The animation cycle has 6 frames.\n
P:12D19:: Move like a blue wizzrobe teleporting.\n\n MULTI: [0394][X]\n
P:12D21:: Shoot every $40 frames.\n
P:12D27:: Fireball
P:12D2D-12D2E:GanonStartXs
P:12D2F:_Ganon_UpdateBrownState: Every other frame decrement the state.\n But every frame draw Ganon either translucent or opaque.\n
P:12D36:: If the state becomes 0, then Ganon is blue again.\n Go switch his palette row to reflect it.\n
P:12D3E:: When state >= $30, draw Ganon opaque.\n When state goes below, draw him translucent.\n
P:12D4D:: Ganon is dying.\n Increment Ganon phase every frame.\n
P:12D50:: If it just went from $FF to 0, then keep it at $FF.\n
P:12D5A:: If Ganon phase < $50, then go draw only.\n
P:12D5E:: If > $50, then go handle ashes only.\n
P:12D60:: Otherwise Ganon phase = $50.\n Set up the burst and ashes.\n
P:12D63:: Ganon is now a pile of ashes at offset (7, 8) from where he was.\n
P:12D75:: Ganon/Triforce song
P:12D7D:: Keep drawing the burst artifacts while Ganon phase < $A0.\n
P:12D84:: If > $A0, then there's nothing left to do, except return.\n
P:12D86:: Otherwise Ganon phase = $A0.\n Activate the room item (triforce of power).\n
P:12D89:: Put it at Ganon's ashes' location.\n
P:12D91:: Increase the room kill count.\n
P:12D95-12D9C:GanonBurstDirs
P:12D9D-12DA6:GanonBurstSpriteAttrs
P:12DA7-12DB0:GanonBurstTiles
P:12DB1:_Ganon_SetUpBurstRays: Loop over 8 burst rays, from 7 to 0, indexed by Y register.\n Access object slots 9 to 2.\n
P:12DB3:: Start each piece at offset (4, 4) from Ganon's location.\n
P:12DC2:: Set the direction.\n
P:12DCC:Ganon_DrawCloud: Params:\n [00]: X\n [01]: Y\n\n Save the coordinates.\n
P:12DD2:: If cloud distance < 6, then use frame image $C (medium).\n Else use frame image $D (low).\n
P:12DDB:: Low density cloud frame image (tile $74)
P:12DDD:: No horizontal flipping.
P:12DE4:: Restore the coordinates.\n
P:12DEB:_L_Ganon_DrawBurst: If cloud distance <> 0, then decrement it once every 8 frames.\n
P:12DF9:: Draw the four clouds at diagonal corners.\n
P:12E17:: Draw the top and bottom clouds.\n
P:12E27:: Draw the left and right clouds.\n
P:12E37:: Save the object index.\n
P:12E3B:: Loop over the 8 burst rays in slots 2 to 9, to move and draw them.\n
P:12E40:: If object slot < 5 or = 7, then move every frame.\n Else move 3 out of every 4 frames.\n\n This makes pieces spread out in somewhat of a circle,\n by making the pieces at cardinal directions move at\n full speed while the diagonal ones move a little slower.\n
P:12E54:: The frame counter will make the sprite flash.\n The array has the horizontal and vertical flipping attributes.\n Combine them into [03].\n
P:12E63:: Bottom of the loop.\n Increment object slot while <= 9.\n
P:12E68:: Restore the object index.\n
P:12E6D:Ganon_GetCurCloudLeft: Returns:\n [00]: X coordinate\n
P:12E76:Ganon_GetCurCloudRight: Returns:\n [00]: X coordinate\n
P:12E7F:Ganon_GetCurCloudTop: Returns:\n [01]: Y coordinate\n
P:12E88:Ganon_GetCurCloudBottom: Returns:\n [01]: Y coordinate\n
P:12E91-12EA8:GanonFrameImages
P:12EA9-12EAC:GanonSpriteOffsetsX
P:12EAD-12EB0:GanonSpriteOffsetsY
P:12EB1-12EB4:GanonSpriteHFlips
P:12EB5:_DrawGanon: Loop over four 16x16 images that make up Ganon.\n There are 6 animation frames.\n
P:12EB7:: Add an offset to Ganon's X, and store the result in [00] -- the sprite's X.\n
P:12EBF:: Add an offset to Ganon's Y, and store the result in [01] -- the sprite's Y.\n
P:12EC7:: Each part has a horizontal flipping flag.\n
P:12ECC:: Save and copy the loop index (the current part) to [07].\n
P:12ED0:: Multiply the animation frame by 4, because of the 4 parts\n that make it up.\n
P:12ED5:: Add [07] -- the index of the current part.\n\n Now you have an index into the frame image table, for the\n current image part of the current animation frame.\n
P:12EDE:: Restore the loop index.
P:12EDF:: Bottom of the part loop.\n
P:12EE4:Ganon_CheckCollisions: Calculate Ganon's midpoint at offset ($10, $10) from his coordinates.\n Store in [02] and [03].\n
P:12EF2:: Check for a collision with Link.\n\n We can't call CheckLinkCollision, because we need to\n customize Ganon's midpoint.\n\n So, we've calculated the midpoint hotspot. Now, skip collision\n detection, if Link is invincible. Initialize variables that will\n be returned from the partial collision check routine. Then\n call it.\n
P:12F04:: If Ganon is not in state 0, then he's red.\n Go check collision with an arrow.\n
P:12F08:: If timer <> 0, then Ganon is visible.\n He can't be harmed like this. So, return.\n
P:12F0C:: Sword slot
P:12F11:: TODO: is red the right description of this color and state?\n\n If Ganon has died, according to the usual collision check rules\n (HP = 0), then:\n 1. Restore HP to the initial value $F0\n 2. Set state to $FF to note that Ganon is vulnerable to silver arrows\n 3. Change palette row 7 to make Ganon red\n
P:12F20:: If Ganon was harmed, then play the sound effect\n and set timer to $40, so that he's visible for $40 frames.\n
P:12F2C:: Reset metastate, because Ganon cannot die this way.\n
P:12F2F:: Reset shove info and invincibility timer, because Ganon\n doesn't react at all as a usual monster.\n
P:12F33:: If the silver arrow is not in the inventory, then return.\n
P:12F3A:: Reset the collision return value [06].\n
P:12F3E:: If there's no arrow in flight, then return.\n
P:12F47:: Check for collision with an arrow; and return if no collision.\n
P:12F4A:: [06] collision result
P:12F4E:: Set the Ganon phase to "dying".\n
P:12F51:: Now his body does flash.\n
P:12F56:: Set initial cloud distance 8.\n
P:12F5C-12F63:GanonColorTransferRecord
P:12F64-12F6C:GanonColorSets
P:12F6D:_AppendGanonPaletteRowTransferRecord_Brown: Brown and white colors at AF64.
P:12F71:_AppendGanonPaletteRowTransferRecord_Blue: Red and blue colors at AF67.
P:12F75:_AppendGanonPaletteRowTransferRecord_Triforce: Yellow and red colors at AF6A.
P:12F77:: Save the end index of the colors.
P:12F79:: Get the length, to append to the dynamic transfer buf.\n
P:12F7C:: Copy the 8 bytes of the palette row transfer record template.\n
P:12F8D:: Restore the end index of the colors.
P:12F8F:: Overwrite the last 3 colors in the record, with the ones\n ending at the index passed in.\n
P:12F9F:_DrawGanonAshes
P:12FA7:Ganon_ActivateRoomItem: If the room item was already active or taken, then return.\n
P:12FB0:: Activate the room item, by setting its state to 0.\n
P:12FB4:: Play "item appears" tune.\n
P:13000:_ExtractHitPointValue: Params:\n A: hit point doublet (byte)\n [00]: object type\n\n Returns:\n A: hit points for object type\n
P:13001:: Even object types only have to mask off the bottom nibble.\n
P:1300B:: Odd object types have to multiply by 16.\n
P:13010:_PlayBossDeathCry
P:1301B-13021:NoDropMonsterTypes: Types of objects that do not drop items.\n
P:13022-13027:DropItemMonsterTypes0
P:13028-13030:DropItemMonsterTypes1
P:13031-13039:DropItemMonsterTypes2
P:1303A-1303D:DropItemSetBaseOffsets: Multiples of $A to index the base of each row of items in DropItemTable.\n
P:1303E-13041:DropItemRates: Top drop an item, a random value must be less than the\n element for the monster group.\n
P:13042-13069:DropItemTable: ID's for items dropped by monsters.\n WorldKillCycle addresses the column.\n\n Monsters are arranged in groups that determine the row.\n There are four rows.\n
P:1306A:SetUpDroppedItem: Reset [01] which holds the row number of the drop item table.\n
P:1306E:: Compare dead object's type to array of 7 that don't drop items.\n If found, go destroy the monster.\n
P:13076:: If found, go destroy the monster.
P:1307B:: Look for object type in array of 6. These use drop item table row 0.\n
P:13080:: If found, use row 0.
P:13085:: Increment row number in [01] to 1.\n
P:13087:: Look for object type in array of 9. These use drop item table row 1.\n
P:1308C:: If found, use row 1.
P:13091:: Increment row number in [01] to 2.\n
P:13093:: Look for object type in array of 9. These use drop item table row 2.\n
P:13098:: If found, use row 2.
P:1309D:: Increment [01]. The rest use row 3.\n
P:1309F:: If object slot = 1 and object is stalfos or gibdos, then\n go destroy the mosnter, because it might already be carrying\n a room item.\n
P:130AB:: Look up the base offset of the row in the drop item table.\n Add it and WorldKillCycle to look up the dropped item for\n this object type and store it in [00].\n
P:130B8:: [00] Dropped item ID
P:130BA:: TODO: Is this really what [0627] represents?\n If the global kill count = $10, set the dropped item to a fairy.\n
P:130C3:: If help drop counter < $A, then use the dropped item ID as is.\n But there is a random chance that the item drop will be canceled.\n
P:130C9:: Otherwise, the item will be guaranteed to be made.\n [51] HelpDropValue determines which kind:\n - 0:     5 rupees\n - other: bomb\n
P:130CF:: Bomb
P:130D1:: [00] Item ID
P:130D3:: The player has been helped with a dropped item. Reset the\n help drop variables.\n
P:130DB:: If the random value >= drop item rate for the monster's group,\n then go destroy the monster.\n
P:130E4:: Set ObjItemLifetime to $FF.\n
P:130E9:: Set ObjItemId.\n
P:130ED:: If the item is a fairy, we have to finish setting it up.\n
P:130F8-130FB:ItemTakerObjSlots
P:130FC:UpdateItem: Every other frame, decrement the item lifetime.\n
P:13101:: MULTI: ObjItemLifetime
P:13104:: If lifetime reached 0, go destroy the object.\n\n\n MULTI: ObjItemLifetime
P:13109:: Draw the item. Fairies are animated separately.\n\n\n MULTI: ObjState/ObjItemType\n
P:13118:: If the player is halted, then return.\n
P:13120:: In addition to Link, there are 3 objects that can pick up items: \n * arrow\n * sword\n * boomerang\n\n For each weapon that's active, substitute it's location for\n Link's and try taking the item. Have Link himself check last.\n
P:13122:: [0D] holds index into array of item slots that can take an item.
P:13124:: Save Link's location.\n
P:1312A:: Set Link's location to this object's.\n
P:1312C:: TODO: (use ItemTakerObjSlots-1)
P:13139:: If Link is checking directly, go try to take the item.
P:1313B:: If the object whose place Link is taking is not active, then\n don't try to take the item.\n
P:13141:: Try to take the item.\n
P:13144:: MULTI: ObjItemType
P:1314B:: Restore Link's location.\n
P:13151:: Reload object index in X.
P:13154:: If item object's item type is invalid, then the item was taken.\n So, go destroy this object.\n\n\n MULTI: ObjItemType
P:1315A:: Decrease the index [0D].
P:1315C:: If there are more object slots to check from, go try the next one.
P:1315F:DestroyMonster_Bank4: Params:\n X: object index\n
P:13179:_ShootIfWanted: Params:\n A: shot object type\n X: shooter object index\n\n Returns:\n C: 1 if succeeded\n Y: shot slot\n\n Description:\n The shot starts in state $10.\n
P:1317B:: If the monster does not want to shoot, then return C=0.\n
P:13180:_ShootLimited: Params:\n [00]: shot object type\n\n Returns:\n C: 1 if succeeded\n Y: shot slot\n\n Description:\n The shot starts in state $10.\n\n If no slot is found, return C=0.\n
P:13185:: If the object type to shoot is a true shot (projectile),\n and we're at the limit of active shots (4), then return C=0.\n
P:13192:: Else increase the number of active shots.\n
P:13195:_Shoot: Params:\n [00]: shot object type\n [59]: EmptyMonsterSlot\n\n Returns:\n C: 1 if succeeded\n Y: shot slot\n\n Description:\n The shot starts in state $10.\n
P:1319C:: Set state to $10 and reset timer, so that the shot moves right away.\n
P:131AB:: Set the shot's direction and coordinates the same as the thrower's.\n
P:131BA:: Return C=1.\n
P:131BC:: Return C=0.\n
P:131BE:UpdateCandle
P:131CA:UpdateCandle_Begin
P:131CF:: If it's not a dark room, return.
P:131D1:: Start a fade-to-light cycle (reverse of $40).
P:131DC:UpdateCandle_Done
P:131DD:: Stop brightening the room, and go set the candle state to done.\n
P:131E4:UpdateCandle_Brightening: Animating a brightening cycle.\n
P:131E7:: If done fading, go stop brightening the room.
P:131EA:IsDarkRoom_Bank4: Params:\n Y: room ID\n\n Returns:\n A: $80 if dark, else 0\n
P:131F4:SetUpFairyObject: Play "fairy appears" tune. It's also "object taken".\n
P:131FC:: Face up at first.\n
P:13200:: Set flying speed fraction to $7F.\n
P:13205:: Set maximum speed fraction to $A0.\n
P:1320B:ResetFlyerState
P:1320D:: TODO: Names\n
P:1321D:UpdateFairyObject: Params:\n X: object index\n
P:13223:_DrawFairy
P:13229:: Every 4 frames, switch between the two sprite frames.\n
P:13235:ControlFairyFlight
P:13243:Flyer_FairyDecideState: Set up 6 turns, and go to state 3.\n
P:1324D:Flyer_DoNothing
P:1324E-13255:Directions8
P:13256:Flyer_Delay: Delay until ObjTimer[X] expires. Then go to flying state 0.\n
P:13260:Flyer_SlowDown: Decrease speed each frame.\n When it goes below a threshold ($20), go to flying state 5.\n
P:13266:Flyer_SpeedUp: TODO:\n Increase speed each frame.\n When it reaches a threshold [04D1], go to flying state 1.\n
P:13270:: TODO:\n ([041F][X] & $E0) = 0\n Set a random timer between $40 and $7F.\n
P:13278:: Go to flying state 5.\n
P:13281:: TODO: If ([041F][X] & $E0) < [04D1], return.
P:13283:: Else go to flying state 1, and return.
P:13288:MoveFlyer: Add (flying speed AND $E0) to flying position fraction.\n
P:13294:: If the fraction isn't whole yet, then return.
P:13296:: Because this object can move in 8 directions,\n test the object's direction with each cardinal direction,\n to modify the coordinates accordingly.\n\n Test right.\n
P:1329E:: Right is not a component? Go check next direction.
P:132A2:: TODO: [046B]
P:132A5:: Test left.\n
P:132A9:: Left is not a component? Go check next direction.
P:132AD:: TODO: [046B]
P:132B0:: Test down.\n
P:132B4:: Down is not a component? Go check next direction.
P:132B8:: TODO: [0478]
P:132BB:: Test up.\n
P:132BF:: Up is not a component? Go finish up.
P:132C3:: TODO: [0478]
P:132C6:: Increase the distance traveled; and keep the object within\n the bounds of the room.\n
P:132CD:_BoundFlyer: Returns:\n A: original facing or the opposite\n [0F]: 0 if blocked\n
P:132D4:: Check vertical boundaries, if object is not a boulder.\n
P:132DE:: If movement wasn't restricted, then return.\n
P:132E2:ReverseObjDir8: Get the opposite direction of the one the object is facing.\n
P:132EC:: If the object type = $41 (moldorm), then go see if we need\n to set the deferred bounce direction.\n
P:132F3:: Apply the new direction.\n
P:132F9:: If the object is segment 5 or $A of moldorm (a head), then\n assign the new direction to the deferred bounce direction.\n
P:13308:Flyer_Chase: Description:\n Turn towards the player a number of times.\n Then go to state 1. After each turn delay $10 frames.\n\n\n Delay until timer = 0.\n
P:1330A:: If timer is not expired, then return.
P:1330C:: Decrease the turn counter.\n Once there are no more turns, go to flying state 1.\n
P:13316:: Set a delay of $10 frames.\n
P:1331A:TurnTowardsPlayer8: Build a direction in [00] towards the player.\n\n First, calculate a horizontal component:\n\n If   observed player X = object X, [00] := 0 (none)\n elif observed player X > object X, [00] := 1 (right)\n else                               [00] := 2 (left)\n
P:1332A:: Second, calculate a vertical component.\n Combine it with the horizontal component:\n\n Y := 4 (down)\n if observed player Y <> object Y then\n   if observed player Y < object Y then\n     Y := Y << 1   -- makes it 8 (up)\n   [00] := [00] | Y\n
P:1333C:: Get the index of the object's direction.\n
P:1333F:: Check 3 directions turning left:\n 1. right from object direction\n 2. object direction\n 3. left from object direction\n\n If the target direction matches any of these, then\n leave the object's direction alone.\n
P:13341:: [01] holds the count of directions to check
P:13343:: Turn right.
P:13345:: Modulo 8 to roll over the index as needed.
P:1334D:: Return if it matches.
P:1334F:: Turn left.
P:13354:: Check 3 directions turning right:\n 1. left of object direction\n 2. object direction\n 3. right of object direction\n\n If any direction component of the target direction matches\n these, then see if we should turn to this direction.\n
P:13358:: This brings the index to one turn left of the object's direction.
P:1335A:: Modulo 8 to roll over the index as needed.
P:13364:: Turn right.
P:13369:: We didn't find a direction to switch to.\n So turn left once; to one turn right of object direction.\n
P:1336A:: Apply the new direction.\n
P:13370:: If (test direction OR target direction) < 7, then allow this turn.\n Else go try the next test direction.\n\n For 3/5 of the arrangements of angles between Link and\n objects; this test yields a turn towards Link. The rest of\n the time, the object will keep going in its original direction\n or turn away from Link.\n
P:13378:_Flyer_Wander: TODO: Was called _Flyer_TurnRandomly\n\n Description:\n Delay and turn randomly a number of times.\n The go to state 1. After each turn, delay $10 frames.\n\n\n Delay until timer = 0.\n
P:1337C:: Decrease the turn counter.\n Once there are no more turns, go to flying state 1.\n
P:13384:: Set a delay of $10 frames.\n
P:13388:_TurnRandomlyDir8: Turn according to a random value:\n >= $A0: don't turn\n >= $50: turn right\n Else:   turn left\n
P:1339C:: Go set object direction for 8-way index.
P:1339F:GetObjDir8Index: Returns:\n Y: index of 8-way direction of flyer object\n
P:133AB:: If not found, then use index 0.
P:133AD-133BC:_PatraSines
P:133BD:_RotateObjectLocation: Params:\n A: high bits of cosine to use in calculating Y increment\n Y: high bits of sine to use in calculating X increment\n\n Returns:\n A: new Y coordinate of object\n\n [06] holds the number of high bits of cosine to use
P:133BF:: [05] holds the number of high bits of sine to use
P:133C1:: First, rotate the X coordinate.\n\n Look up the sine for the current angle, and store it in [00].\n
P:133CC:: Mutliply q-speed by [00].\n\n Q-speed has the default value $20 set when entering the room.\n
P:133D4:: The absolute X increment for the current angle is now in [02:03].\n\n If angle >= $10, then the monster is in the top half of circle going left.\n
P:133D7:: TODO: Why AND with $18?
P:133DD:: Subtract the product's fraction from the X coordinate fraction.\n
P:133E6:: And subtract the product's whole part from the X coordinate with carry.\n
P:133ED:: Else angle < $10. So, the monster is in the bottom half of circle going right.\n Add the product's fraction to the X coordinate fraction.\n
P:133F6:: And add the product's whole part to the X coordinate with carry.\n
P:133FC:: Now rotate the Y coordinate.\n\n Look up the cosine for the current angle, and store it in [00].\n The cosine corresponds to the sine offset by a quarter circle (8).\n
P:1340A:: Multiply q-speed by [00].\n
P:13412:: The absolute Y increment for the current angle is now in [02:03].\n\n If (angle - 8) >= $10, then the monster is in the right half of circle going up.\n
P:1341E:: Subtract the product's fraction from the Y coordinate fraction.\n
P:13427:: And subtract the product's whole part from the Y coordinate.\n
P:1342C:: Else (angle - 8) < $10. So, the monster is in the left half of circle going down.\n Add the product's fraction to the Y coordinate fraction.\n
P:13435:: And add the product's whole part to the Y coordinate with carry.\n
P:1343A:ShiftMultiply: Params:\n A: multiplicand\n Y: number of high bits of [00] to use\n [00]: multiplier (high Y bits are used)\n\n Returns:\n [02:03]: product\n
P:13459:_DecreaseObjectAngle: Params:\n A: low amount byte\n X: object index\n [0B]: high amount byte\n\n Subtract the low amount byte from low angle byte.\n
P:13464:: Subtract the high amount byte from high angle byte with borrow.\n
P:13469:: Cap the high byte at $1F.\n
P:14000:UpdateMenuAndMeters
P:14006:UpdateMenu
P:1400C:: Update menu in UW.\n
P:14021:: Update menu in OW.\n
P:14038:UpdateMenuCommon1
P:14041:: Move position markers and hardware vertical scroll position\n down 1 pixel.\n\n Because we'll be above the top of NT 0, switch to NT 2 to\n be at the bottom of NT 2.\n
P:14047:: 1 pixel
P:1404C:: Set menu state 2.
P:1404E:: SubmenuScrollProgress begins at $2B. Each frame it will be\n decremented. It encodes a submenu row index in bits 1 to 7,\n and a flag in bit 0.\n\n When the flag is 1, a full row of black tiles will be transferred\n at the current row. Otherwise, one of various static visual\n elements will be transferred.\n\n For example:\n 1. In the first frame of scrolling, $2B indicates that a full row\n    of black tiles must be transferred to row $15.\n 2. In the second frame ($2A), submenu row will again be\n    $15, but something else will be transferred.\n 3. In the third frame ($29), a full row of black tiles will be\n    transferred to row $14.\n
P:14052:: In UW, this variable will be used to scan every room in order\n to build the big sheet map in the submenu. It will range\n from $7F to 0.\n
P:14057:UpdateMenuCommon2: Cue the transfer of first set of submenu nametable attributes to NT 2.\n Advance state.\n
P:1405E:UpdateMenuCommon3: Cue the transfer of second set of submenu nametable attributes to NT 2.\n Advance state.\n
P:14062:UpdateMenuCommon4: Cue the transfer of a blank row of tiles to the bottom of NT 2.\n Advance state.\n
P:14066:UpdateMenu5UW
P:1406C:UpdateMenu5OW: Cue the transfer of "TRIFORCE" text.\n
P:14070:UpdateMenuScrollDownOW
P:14076:UpdateMenuScrollDownUW
P:14079:: Move position markers and advance nametable scrolling;\n so that we scroll down 3 pixels.\n
P:14085:: There's nothing else to do until we reach hardware VScroll=$41. Return.\n
P:14089:: VScroll reached $41.\n Advance the submenu state.\n If in OW or in a cellar, we're done. Return.\n
P:14095:: Calculate the X coordinate of the submenu position marker.\n\n First, mask off the high nibble of the room ID and multiply by\n the width of a tile, 8. Store the result in [00].\n
P:1409E:: If the submenu map's rotation >= 8, it's the same as a\n negative or left rotation by ($10 - rotation value).\n\n Subtract the two values as shown. Multiply the result by 8,\n the width of a tile. Then negate it. The final result is the\n negative offset.\n
P:140B3:: The submenu map's rotation < 8.\n It represents the number of tiles to move right.\n So, multiply it by 8.\n
P:140B6:: Add the offset we calculated, and $62 to [00] to get\n the position marker's X coordinate.\n
P:140BF:: Mask off the low nibble of room ID to get a multiple of $10.\n Divide by 2 to get a multiple of the tile height.\n Then add $69 to get the Y coordinate of the sprite.\n
P:140C9:: Write tile $3E (dot) and attributes 0 (Link palette row 4).\n
P:140D4:UpdateMenuActive
P:140DA:: TODO: #3\n If buttons Up and A are down on the second controller, then\n 1. reset submenu state\n 2. go to mode 8\n 3. play sound ?\n
P:140F3:: If Start was pressed, then hide all sprites except\n Link and triforce position markers, and go to the next state (scroll up).\n
P:140F9:: Save Link's position marker's Y.
P:140FD:: Save triforce's position marker's Y.
P:14104:: Restore triforce's position marker's Y.
P:14108:: Restore Link's position marker's Y.
P:1410F:UpdateMenuScrollUp: Move position marker's and vertical scroll up 3 pixels.\n
P:1411B:: If hardware vertical scroll still < $F0, then return.\n
P:1411F:: Once vertical scroll >= $F0, switch to NT0.\n
P:14121:: TODO: ?\n In UW, write $10 transparent sprites starting from index 0.\n
P:14128:: We reached the end. So, reset hardware vertical scroll\n and submenu state.\n
P:1412E:: Move the position markers 2 pixels down, because we\n overshot and reached vertical scroll $F2.\n
P:14130:MovePositionMarkers: Params:\n A: vertical velocity of menu scrolling\n\n\n [00] holds the vertical velocity of menu scrolling.
P:14132:: If Link's position marker is visible, then move it by the velocity in [00].\n
P:1413F:: If in UW and have the compass, then move the triforce position marker.\n
P:14152-14169:TriforceTransferBufOffsets
P:1416A-14181:TriforceTriforceBufReplacements
P:14182-14199:TriforceTransferBufTiles
P:1419A:UpdateMenuStartOW: Put the tiles into the submenu triforce transfer buffers that\n make it look completely empty, and no piece has been won.\n
P:141A8:: Reset triforce tile slot. These range from 0 to $17.\n
P:141A9:: Outer loop.\n A level test bit in [06] will be used to see whether\n we have a triforce piece.\n
P:141AB:: [06] level test bit
P:141AD:: Inner loop.\n Each level bit will make 3 triforce tile slots be\n checked and replaced.\n
P:141AF:: [07] inner loop counter
P:141B1:: Get the offset into the submenu triforce transfer buffers of\n the current tile slot.\n
P:141B4:: If the level test bit is not in the triforce mask, then we don't\n have this piece. So, go loop again, and leave the tile in the\n empty state.\n\n\n [06] level test mask
P:141BB:: We have the triforce piece.\n\n If the base/empty tile already in the transfer buf = $E5 or $E6,\n then make it $F5. These are tile that were half full, and now\n need to be full.\n\n Else replace it with the one at the current triforce tile slot\n in the replacement list.\n
P:141D1:: Bottom of the inner loop.\n\n Increment the triforce tile slot.\n Decrement [07] and loop again, if it's not 0.\n
P:141D2:: [07] inner loop counter
P:141D6:: Bottom of the outer loop.\n\n Shift the level test bit [06] left to test the next level.\n When it becomes 0, we're done.\n
P:141DD:ScrollWorld
P:141DF:: The purpose of this is to delay vertical scrolling.\n OW: once every two frames\n UW: once every four frames\n Horizontal scrolling happens every frame.
P:141EB:: If the player is facing up,
P:141F1:: then scroll up.\n Scrolling up starts from the top of NT 2 at $2800.\n
P:141F3:: Move the player down 1 tile length if not at edge.
P:141FD:: Subtract $20 from VScroll address for a row.
P:1420A:: If the result doesn't end in $E0, then return.
P:14210:: If the result is $20E0, then the scroll position reached the status bar. Go sanitize and keep it there.
P:14214:: If the result is not $27E0, then return.
P:14216:: VScroll address is $27E0. So, we rolled from the\n top of NT 2 to the last row of NT 0. Change the address\n to $23A0, the true last row of NT 0.
P:1421F:: Don't let the scroll position go above $2100, the bottom of\n the status bar; nor below $2800, the top of NT 2.
P:14225:: And we're done.
P:14228:ScrollWorldDownOrH: If the player is facing down,
P:1422D:: then scroll down.\n
P:1422F:: Move the player up 1 tile length, if not at edge.
P:14239:: Add $20 to VScroll address for a row.
P:14246:: If the result doesn't end in $C0, then return.
P:1424C:: If the result is not $23C0, then return.
P:1424E:: VScroll address is $23C0, the bottom of NT 0. So, we need\n to roll to $2800, the top of NT 2.
P:14255:ScrollWorldH: Use the default scroll speed: 2 pixels a frame.
P:1425D:: Scroll twice as fast if in the overworld.
P:14260:: [00] holds the speed.
P:14262:: [01] holds the X position where we must start using NT 1.
P:14264:: If player does not face left,
P:14268:: then go scroll right.
P:1426A:: Scroll left.\n
P:1426C:: Move player right by [00] if not at edge.
P:14276:: Update nametable X scroll by speed in [00].
P:1427D:: Stop when you've scrolled to the end (CurHScroll=0).
P:1427F:: Does scroll position match reference scroll position [01]?
P:14281:: If not, then return.
P:14283:: When we begin scrolling left, CurHScroll = 0 and base\n nametable is 0. This shows the current room completely.\n\n The first time in ScrollWorld, the speed [00] will be\n subtracted from CurHScroll to show most of NT 0, and\n a little of NT 1 to its left. In other words, the\n scroll position now refers to a position in NT 1.\n\n [01] is this first position shown in NT 1. So, once\n CurHScroll matches it (in the first call to this routine),\n turn on this flag that makes NT 1 the base nametable.
P:14285:: Start basing the horizontal scroll position on NT 1.
P:14288:ScrollWorldRight
P:14289:: If the player isn't facing right either,
P:1428B:: then quit.
P:14293:: Move player left by [00] if not at edge.
P:14299:: Update nametable X scroll by speed in [00].
P:142A0:: If scroll position hasn't reached 0, then return.
P:142A2:: Because CurHScroll is now 0 and base nametable is 0;\n we would be showing the new room at the end of the scroll\n but with old attributes.\n\n So, now use NT 1, until after we copy the attributes.
P:142A5:: Go to the next submode.
P:142A8:InitMode7Submodes
P:142BB:InitMode7_Sub1
P:142C1:: Assign the current opened doors to the previous one.
P:142C6:: If this doorway Link is entering from is not a true door,\n then LayOutDoors called from LayOutRoom will clear it.\n
P:142C9:: TODO: ?
P:142D2:: If next room ID is invalid, then return because\n something went wrong calculating it.\n The mode was changed to load the OW.
P:142D6:: Save current room ID.
P:142DB:: If we're not going up, then temporarily set RoomId to next\n room; so we can draw next room in NT 2 below and\n subsequent submodes.\n\n Only in up direction do we draw the current room in NT 2.
P:142E4:: Start at bottom row.
P:142EC:: If going up, then go lay out the only dynamic elements for the current room: the doors.
P:142EE:: else lay out the next room.
P:142F1:: Restore current room ID.
P:142F5:: Here, "previous" means "current", because we already changed TempDoorDirHeldOpen.
P:142F8:: Go restore current room ID and return.
P:142FB:LayOutDoorsPrev
P:142FD:: If in OW, then return.
P:1430E:InitMode7_Sub0: If teleporting, then set the room ID to the one that will\n make it look like we scrolled to a dungeon entrance.
P:1431A:: If we had no flute secret (pond) or it finished, then go to next submode.
P:1431C:: Go reverse the flute secret (pond colors).
P:1431F:InitMode7_Sub2: This transfers a room's play area tiles to nametable 2.\n\n CurRow starts at the bottom ($15).
P:14325:: Change the target nametable from 0 to 2.\n\n Because there's only a play area and no status bar in\n nametable 2, you have to add 7 to the high byte instead of 8.\n So, the top of the play area in NT 0 is at $2100.\n But the top of the play area in NT 2 is at $2800.\n\n This assumes that you want to scroll vertically, where the\n two scroll areas must be contiguous vertically.
P:14331:: If the scroll direction is not vertical,
P:14333:: then you DO have to account for the status bar.\n So, add $100 (by incrementing high byte) to move\n everything down 64 pixels.\n\n Now the play areas will line up in NT 0 and NT 2 when\n we change mirroring to vertical at the end of this mode.
P:1433D:InitMode7_Sub3And4_TransferPlayAreaAttrsToNT2: This transfers half of a room's play area attributes\n to nametable 2. The top half in submode 3, and the bottom\n half in submode 4.\n\n\n Test player's direction for up (8).
P:14343:: Test player's direction for down (4).
P:14348:: Scrolling up or down.\n\n\n This will mean PPU address $2BC0.
P:1434A:: This is the offset of the end of the first half of play area NT attributes.
P:14350:: If in submode 4 instead of 3,
P:14352:: then refer to bottom half of NT attributes.
P:14358:: Scrolling left or right.\n\n\n This will mean PPU address $2BD0, 64 pixels down from\n the top of NT 2. See submode 2 for an explanation of\n offsets and mirroring for vertical scrolling.
P:1435A:: Go continue setting up transfer of attributes.
P:1435C:InitMode7_Sub5: Reset fade cycle, in case we don't need to fade.
P:14365:: If direction is horizontal,
P:14367:: then cue transfer of a row of blanks above the play area.\n This should lead to clean vertical scrolling without visual\n artifacts.\n\n TODO: But, maybe it doesn't work, because its address\n $28E0 is in NT 2, which will become a mirror of NT 0 below\n in this submode.
P:1436F:: Scrolling up.\n\n\n Lay out the next room now, because we had to transfer\n the current one to NT 2 earlier. Up is the only direction\n that draws the current room to NT 2.
P:14371:: Save current room ID.
P:14372:: Lay out the next room.
P:14379:: Restore current room ID.
P:1437C:: Scrolling in any direction.\n
P:14381:: If the next room is not dark, then go finish up and start updating.
P:14383:: The next room is dark.\n
P:14388:: If the current room is dark by default, go see if it was lit up.
P:1438A:: Going from room with light to a dark room.\n\n\n The next room will not be lit yet.
P:1438F:: Start a fade-to-black cycle.
P:1439A:: If it was lit, then go start a fade-to-black cycle.
P:1439C:: Not lit. Dark to dark. Nothing to do.\n Go finish initializing, and begin updating the mode.
P:1439E:InitMode7_Sub6
P:143A1:: If we're still fading, then return.
P:143A3:: Finish initializing this mode, and start updating it.\n\n\n Set current room to next room.
P:143AE-143B1:Sprite0Descriptor
P:143B2:WriteAndEnableSprite0
P:143C2:SetEnteringDoorwayAsCurOpenedDoors: Calculate the opposite of the player's direction.
P:143D0:: That is the door the player's entering the new room from.
P:143D3-143D6:RoomPaletteSelectorToNTAttr
P:143D7:FillPlayAreaAttrs: Params:\n A: room ID\n\n Look up room attributes A for the room.
P:143DB:: Get the outer palette selector from the byte.
P:143DE:: Get the nametable attributes for the palette selector.
P:143E1:: Fill the play area NT attributes.
P:143E9:: Look up room attributes B for the room.
P:143EC:: Get the inner palette selector.
P:143EF:: Fill the inner play area NT attributes (offset 9 to $26).\n
P:143F2:: Skip left and right edges.
P:143FA:: For the bottom inner NT attribute row, go combine the inner and outer attributes.
P:14407:: If we haven't finished the last inner NT attribute row, then go fill more.
P:1440A:: Combine the NT attributes at current offset with the\n new ones we're filling; so that new (inner) attributes\n affect the top half of the row.
P:1441B:: Go advance the offset and check if we're done.
P:1441E:UpdateMode7SubmodeAndDrawLink
P:14421:: TODO: Draw Link?
P:14424:UpdateMode7ScrollSubmode
P:14439:UpdateMode7Scroll_Sub0
P:1443B:: Reset low byte of VScroll address for vertical scrolling.
P:1443D:: Reset horizontal scroll offset for horizontal scrolling.
P:14443:: If scrolling up, go handle it.
P:1444A:: Scrolling down.\n\n\n Start scrolling from $2100, the top of play area in NT 0 (current room).
P:1444E:: Start past the first row, because the scrolling process first increments it.
P:14452:: From submode 0 go to submode 2.
P:14457:: Scrolling left or right.\n\n Keep in mind that columns will not be copied if CurColumn\n is not between 1 and $20.\n\n Set up a starting column number well past the beginning or\n end of the play area; so that we don't write to a part of\n the scroll region.\n\n\n $A0 in UW.
P:1445D:: $E0 in OW.
P:14464:: Scrolling left.\n\n\n $81 in UW.
P:1446A:: $41 in OW.
P:1446C:: Set CurColumn to the value we determined.
P:1446E:: Go to submode 2.
P:14471:: Scrolling up.\n\n\n Start scrolling from $2800, the top of play area in NT 2 (current room).
P:14475:: Start past the last row, because the scrolling process first decrements it.
P:1447E:UpdateMode7Scroll_Sub1
P:14484:ChooseAttrSourceAndDestForSubmode: Results:\n A: low PPU address\n Y: end offset in PlayAreaAttrs to copy from\n\n\n Low byte $D0 mean destination PPU address of $23D0, $27D0, $2BD0, or $2FD0.
P:14486:: This is the offset of the end of the first half of play area NT attributes.
P:1448A:: Return.
P:1448C:GetPlayAreaAttrsBottomHalfInfo: Params:\n A: low PPU address\n\n Returns:\n A: low PPU address + $18\n Y: end offset of second half of play area NT attributes\n\n\n This is the offset of the end of the second half of play area NT attributes.
P:1448F:: Add $18 to point to the bottom half of NT attributes in PPU memory.
P:14492:UpdateMode7Scroll_Sub2: Calculates a VScrollingStartFrame value that enables\n immediate vertical scrolling in the next frame and submode.\n
P:14496:: Add 1, so that the frame value calculated in the next frame\n will match the VScrollingStartFrame value we calculate here.
P:14499:: Calculate VScrollingStartFrame the same way as the frame\n value in the next submode.
P:144A4:UpdateMode7Scroll_Sub3
P:144AE:: If the submode has advanced,
P:144B0:: then invalidate current and previous row, and reset the current column.
P:144BA:UpdateMode7Scroll_Sub6
P:144BC:: If in OW, then don't need to handle dark rooms. Go finish up.
P:144C3:: If the room isn't dark, then go finish up.
P:144C5:: Set CurRow = 0 (was $FF) to signal to mode 4 that\n it might need to brighten the new room, because we\n scrolled from a dark one.\n\n This isn't a concern, if you enter a room by any other mode.
P:144CC:UpdateMode7Scroll_Sub7
P:144D1:: Reset to initialize the next mode.
P:144D3:: TODO: [$010C] ?
P:144D6:: TODO: [$E7] ?
P:144D8:: Reset sprite-0 check, because we finished scrolling.
P:144DA:: Go to mode 4 submode 1.
P:144DF:UpdateMode7Scroll_Sub4: Transfer new room's attributes to NT 0.\n
P:144E3:: If not facing up, then go transfer new room attributes to NT 0.
P:144E5:: Go to submode 6.
P:144E8:UpdateMode7Scroll_Sub4And5_TransferNTAttrs: This will be PPU address $23D0, attributes for top half of play area in NT 0.
P:144EA:: Ending offset of first half of attributes.
P:144EE:: If in submode 4,
P:144F0:: then transfer top half.
P:144F2:: Transfer bottom half.\n\n\n Save low byte of PPU address of top of play area attributes.
P:144F7:: If scrolling horizontally,
P:144FB:: then don't use NT 1 anymore.
P:144FD:: Restore low byte of PPU address of top of play area attributes.
P:14501:CueTransferPlayAreaAttrsHalfAndAdvanceSubmodeNT0: Params:\n A: low PPU address\n Y: end offset in PlayAreaAttrs to copy from\n\n\n High byte of destination PPU address for play area attributes.
P:14506:CopyColumnOrRowToTileBuf: Copies a row if CurRow is valid. Otherwise, tries to copy a column.\n\n If CurRow = PrevRow, does nothing. After a row is copied,\n PrevRow is assigned CurRow.\n\n\n If CurRow is valid, then copy row.
P:1450C:: unless CurRow = LastRow, then don't repeat
P:14515:: If 0 < CurColumn < $21, then copy column.
P:14521:WaitAndScrollToSplitBottom: Wait for Sprite 0 Hit.
P:1452B:: Wait cycles.\n TODO: Why do these differ?\n (cycle at 8535 - cycle at 852b) = 1005  (see CPU status in debugger)\n (multiply instruction timing appropriately) = 1010
P:14535:: Wait 18 cycles.
P:14546:: If GameSubmode is 0, then return.
P:1454C:: TODO: If facing horizontally, then go update scroll registers.
P:1454E:: Scrolling vertically, will set PPUADDR instead of PPUSCROLL.\n Wait about 666 cycles.
P:14554:: Wait 10 cycles.
P:14559:: Prepare for writing to PPUADDR.
P:1455C:: Set PPUADDR mid-frame to \n achieve split-frame scrolling.
P:1458E:: If GameMode < $11,
P:14590:: then turn off video and return.
P:14593:: else change base nametable (0 -> 1 or 2 -> 3).
P:14600:InitMode8
P:14607:: Reset.
P:14613:: Cue the transfer of text and attributes for mode 8.
P:1461A:InitModeD
P:14620:: If initialized save RAM, then it wasn't previously\n initialized or something went wrong.\n So, go reset the game.
P:14628:InitMode10: Get the tile the player is standing on (on the hotspot).
P:1462F:: If player touched any stairs tile instead of a cave or dungeon entrance, go start updating.
P:14631:: TODO: ?
P:14636:: TODO: ?
P:1463B:: Set the target Y coordinate $10 pixels below current one.\n
P:14640:: TODO: TargetY
P:14646-14649:SpawnPosListAddrsLo
P:1464A-1464D:SpawnPosListAddrsHi
P:14672-14675:EnteringRoomRelativePositions
P:1473F-1475C:ObjLists
P:1477B:InitMode4
P:1477D:: If in submode 0, go perform common tasks to enter a room.
P:14782:: Submode 1.\n Copies the whole play area to NT 0, one row each frame.\n\n TODO:\n If mode 7 scrolls to a dark room, then it sets\n CurRow to zero. Otherwise it would be $FF.\n A positive value triggers this submode 1 to transfer\n the whole play area.\n\n But why? As far as I can tell, the NT 0 is already in\n a good state reflecting the new room. The only thing\n needed is possibly to brighten the room by way of\n changing the palette.\n\n So why does mode 7 trigger this?\n Is there another mode that truly needs this behavior?\n
P:14784:: If CurRow is negative, then go to the next submode.
P:14789:: If the last row has been copied,
P:1478B:: then go to the next submode.
P:14791:: Submode 2.\n
P:14796:: If this room is dark, then nothing else to do. Go to submode 0.
P:14798:: This is a light room.\n See if we have to brighten it after leaving a dark room.\n
P:1479D:: Subtract RoomId from next room ID that was calculated\n to get room ID offset in that direction.
P:147A0:: We really want the opposite offset/direction.
P:147A3:: Add the current room ID to that to get the previous room ID.
P:147AA:: If previous room was light, then go to submode 0.
P:147AC:: The previous room was dark.\n
P:147AF:: But if it was lit up, then nothing else to do. Go to submode 0.
P:147B1:: Start a fade-to-light cycle (reverse of cycle $40).
P:147B3:SetFadeCycleAndAdvanceSubmode: Params:\n A: start index of cycle\n
P:147B9:InitMode4_Sub3: Submode 3.\n
P:147BC:: If not done animating, then return.
P:147C6:InitMode_EnterRoom: TODO: Is also called for modes 9, $B, $C.\n
P:147CC:: Reset [0300] to [051F].\n
P:147D3:: Reset door trigger info.\n
P:147D9:: Store level block attribute byte F for convenience.\n
P:147E4:: There's more than one way to enter a room.\n\n 1: Out of a cave, dungeon, or cellar\n     a. Walking exit\n     b. Next to stairs\n 2: Room to room\n\n Determine which one we need.\n
P:147E6:: If not leaving underground, go handle method 2.
P:147EA:: If in UW and stepping out of cellar, Link is already where he needs to be. But go handle the rest (method 1-b).
P:147EC:: Enter method 1.\n\n Set up Link's exit from underground.\n
P:147F1:: X coordinate where link comes out of underground
P:147F8:: Square row where Link comes out of underground, starting from square row 1. See the addition below.
P:147FA:: Multiply by $10 to get a height in pixels.
P:147FE:: Add the first Y where Link can come out of underground.\n $4D is $50 (the second square row) - 3 (Link's offset above the row).
P:14802:: If the player didn't step on a cave entrance to go underground,\n then he used the stairs. So, skip starting the exit effect (method 1-b).\n
P:14804:: $24 is black entrance, and contrasts with $70 to $73 (stairs).
P:14808:: Enter method 1-a.\n\n\n MULTI: Store the Y coordinate that we determined as the Target Y [0412].
P:1480E:: But have Link start walking out from $10 pixels below.
P:14810:: TODO: play walking sound effect.
P:14812:: TODO: [0603]
P:14815:: This part is the same no matter if the player went\n underground by stairs or a cave entrance.\n
P:14817:: Link faces down when coming out of a cave or dungeon.
P:1481B:: Reset DoorwayDir, assuming there is no doorway.
P:1481D:: Go reset Link's relative position, and work on objects.
P:14820:: Enter method 2.\n Room to room.\n\n Get the direction that the player is entering from.\n
P:14822:: The player entered the doorway in a room. So, set DoorwayDir.
P:14827:: If the player is entering from a door that was opened, then\n set the "close" door command.\n
P:14831:: If in OW, go reset Link's relative position, and work on objects.\n
P:14835:: If facing right, then set Link's X to 0 at the left edge.\n If direction is left, then set Link's X to $F0 at the right edge.\n
P:14845:: Choose a distance to walk depending on the door you\n come out of.\n\n We'll get a 0 or 1 depending on the direction of the door.\n\n If the attribute of the door is "open", "key", or "key 2";\n then you have shorter distance to cover. So use the\n previous value as is to use indexes 0 and 1.\n\n Otherwise, add 2 to use indexes 2 and 3 to walk farther\n to get out of the way of the wall or door.\n
P:1485F:: Set current object slot variable to $B, to be ready for the\n first frame of mode 5. So, that it begins updating objects\n at slot $B.\n
P:14864:: Reset common state of objects $B to 1.\n
P:14870:: TODO: INC?
P:14873:: By default, objects start in metastate 1 (first cloud state).
P:14876:: Set the default speed.
P:1487E:: Put the monster list ID in [02].\n
P:14884:: Low 6 bits of monster list ID
P:1488B:: High bit of monster list ID
P:1488C:: If high bit is set in attribute byte D,
P:1488E:: Then set bit 6 of monster list ID.
P:14896:: Get index of monster count from high 2 bits of attribute byte C.\n
P:1489D:: Get the object count from level info.\n
P:148A0:: But make the count 1, if  the object list ID >= $32 and < $62.\n This includes bosses and other non-recurring objects.\n
P:148AC:: Put the count in [03].
P:148AE:: Use the room history to modify the number of objects to make.\n
P:148BB:: If in mode 9 (most caves), then\n reset object count and object list ID.\n
P:148C7:: Store the object count.
P:148CC:: If object count = 0 or object list ID = 0, then\n skip instantiating objects.\n
P:148D2:: TODO: If object list ID (or call it object template ID?) >= $62,\n then it refers to a list. Go handle it.\n
P:148D6:: TODO: Object list ID (or call it object template ID) refers to a\n repeated object.\n\n Set the object type at each element from 1 to Object Count\n to object list ID (or call it object template ID).\n
P:148E5:: TODO: Object list ID (or call it object template ID) refers to a\n list of object types.\n\n Get the index of the list itself by subtracting $62.\n
P:148EA:: Put the address of the list in [04:05].\n
P:148F7:: Copy elements from the list to ObjType up to object count [03].\n
P:14903:: Remember the object template type.\n
P:14929:_DrawLinkBetweenRooms
P:1492C:: If mode is not $B nor $C (caves),
P:1493B:: If coming out of a cave or dungeon, then ...
P:14941:SetupTileObjectOW: If this is a room with a dock ($3F and $55), then\n set the dock object type ($61) in tile object slot ($B).\n
P:14950:: There's no dock here, but there might be a tile object that\n we found while laying out the room. Set the type, X, and Y\n to the details we determined.\n
P:14963:: TODO: Activate room tile object.
P:14966-14969:CellarKeeseXs
P:1496A-1496D:CellarKeeseYs
P:1496E:AssignObjSpawnPositions: Params:\n [02]: object template ID\n
P:14971:: If object template type = 0 or refers to Zelda, then\n skip spawning normal objects.\n
P:14979:: If in OW, then see if monsters come in from the edges of the screen.\n
P:14980:: Monsters from the edges of the screen
P:14982:: If monsters come in from the edges, go skip spawning normal objects.
P:14987:: If object count = 0, go skip spawning normal objects.
P:14989:: Get the direction from Link's direction (bit).\n
P:14991:: Put the address of the spawn list for Link's direction in [06:07].\n
P:1499B:: Assign spawn coordinates to 9 object slots.\n
P:1499E:: Starting at object 1.
P:149A0:: Get a spawn spot from the list.
P:149A3:: Turn the column component into an X coordinate.
P:149A9:: Turn the row component into a Y coordinate.
P:149AC:: Add $D to the Y coordinate.
P:149B5:: Point to the next object.
P:149B6:: Point to the next spawn spot.
P:149B9:: If we went past the last spawn spot,
P:149BB:: then reset the cycle.
P:149C4:: If in mode 9 (play cellar), then\n spawn 4 blue keeses.\n
P:149C8:: If not in mode 9, go check caves.
P:149CC:: Blue Keese
P:149DF:: If the mode is not $B nor $C (caves), then return.\n
P:149E7:: We're in a cave.\n Reset object types in slots 1 to 8.\n
P:149F1:: cave index = ((cave value) >> 2) - $10\n
P:149F6:: Cave
P:149FD:: cave dweller object type = $6A + (cave index)\n
P:14A00:: Replace first non-Link object type with the cave dweller type.
P:14A04:IsSafeToSpawn: Params:\n X: object index\n\n Returns:\n C: 1 if unwalkable\n\n\n Save %Y.
P:14A09:: Restore %Y.
P:14A11:: If the tile at the object's hotspot is unwalkable, return unwalkable.
P:14A13:IsDistanceSafeToSpawn: Params:\n X: object index\n\n Returns:\n C: 1 if unwalkable\n\n\n Get the absolute X distance to Link.\n
P:14A1D:: If distance > $22, return walkable.
P:14A1F:: Get the absolute Y distance to Link.\n
P:14A29:: If distance < $22, go return unwalkable.
P:14A2B:: Walkable
P:14A2D:: Unwalkable
P:14A2F:InitMode11: Decrease Link's invincibility timer. This is needed in submode 1.
P:14A34:: TODO: draw Link?
P:14A39:: Go handle submode 1.
P:14A3B:: Submode 0.\n
P:14A56:: Set the invincibility timer, so that Link will flash for a fixed amount of time.
P:14A5B:: Invincibility timers count down every 2 frames, while\n object timers count every frame. So, these 2 timers measure\n about the same amount of time.\n
P:14A60:InitMode11_Sub1
P:14A62:: If ObjTimer hasn't expired, then return.
P:14A6B:: If not in a cellar (unique room ID's $3E and $3F),
P:14A6D:: then lay out the doors again. But this seems redundant.
P:14A75:: DeathPaletteCycle
P:14A7A:: Set a timer. But no one waits for it?
P:14A7E:: Reset submode, CurRow, and player's state.
P:14A86:: There will be 4 turns starting from down direction.
P:14A8C:: Start updating.
P:14A8E:: TODO: ?
P:14A97:SetDoorFlag: Params:\n X: door direction index\n\n Returns:\n Y: room ID\n [00:01]: address of level block world flags\n
P:14AA0:ResetDoorFlag: Params:\n X: door direction index\n\n Returns:\n Y: room ID\n [00:01]: address of level block world flags\n
P:14AAD:CheckShutters:\n\n If the shutters have not been triggered to open, return.\n
P:14AB2:: Loop to look for an unopened shutter.\n The loop variable is a direction bit in [0E], starting with up (8).\n
P:14AB6:: If the door for the direction bit is not opened, go see if it's a shutter.\n
P:14ABC:: This door was opened. Shift the direction bit right.\n Loop until direction bit = 0.\n
P:14AC2:: If there were no unopened shutters, then turn off the shutter trigger.\n
P:14AC8:: Pass the direction bit as an argument to get the door attribute.\n
P:14ACC:: TODO: Why not call it door type instead of door attribute?
P:14ACF:: If it's not a shutter, go loop again.\n
P:14AD3:: If there's already a triggered door command, quit.\n
P:14AD8:: Else set a command to open the door in this direction.\n
P:14ADA:TriggerOpenDoor: Params:\n A: direction\n
P:14ADD:: Open door command
P:14AE3-14AE5:Mode8BaseSpriteValues
P:14AE6-14AE8:Mode8SpriteYs
P:14AE9-14AEB:Mode8SelectionToMode
P:14AEC-14AF0:Mode8FlashTransferRecord
P:14AF1-14AF3:Mode8FlashAttrsAddrLo
P:14AF4:UpdateMode8ContinueQuestion_Full
P:14AF7:: If the flag is set in submode, then go animate and\n handle the selection.
P:14AFD:: If Start is pressed, go handle it.
P:14B03:: If Select was pressed,
P:14B05:: Play a short sound for it (same as rupee taken).
P:14B0A:: The selection is tracked by the submode.\n Increase it. Wrap around, if needed.
P:14B16:: Set tile, attributes, and X for selection sprite (0).
P:14B2A:: Show in the submode that Start was pressed by setting high bit.
P:14B30:: Flash the selection for $40 frames.
P:14B37:: When the timer expires, go handle the selection.
P:14B39:: Copy to dynamic tile buf the transfer record\n for flashing NT attributes.
P:14B44:: Patch the transfer record to write the low byte of the\n appropriate address of the attributes depending on\n the selection.
P:14B4F:: Every 4 frames, depending on ObjTimer,\n change the NT attribute byte to another palette.
P:14B5D:: Mask the submode, so that it only holds the selection.
P:14B66:: Set the next game mode according to the selection.\n 3: Continue\n D: Save\n 0: Retry
P:14B6D:: Make the player start again with 3 full hearts.
P:14B7F:: If player chose Retry,
P:14B84:: Start the next mode in submode 1 and updating.
P:14B8B:UpdateMode10Stairs_Full
P:14B90:: If player touched a stairs tile instead of a cave or dungeon entrance, go end the mode without animating Link.
P:14B92:: Update the position once every 4 frames.\n
P:14B96:: If it's not time to change position, go draw.
P:14B98:: Move Link down 1 pixel.
P:14B9C:: TODO: Here it's the target Y.
P:14B9F:: If Link hasn't reached the end of the walk, go draw.
P:14BA1:: Else go to the target mode.
P:14BAB:PutLinkBehindBackground: Change priority of Link sprites $12 and $13 to show them behind the background.
P:14BBC:CheckUnderworldSecrets
P:14BBF:: If there's no secret in this room, return.\n
P:14BC2:: Secret trigger
P:14BC6:: If the secret was not triggered, return.\n
P:14BCB:: If the secret is not "foes for an item", then we're done.\n
P:14BCE:: Secret trigger
P:14BD4:: If the room item was already activated, or the item was\n already taken, then return.\n
P:14BDD:: Else activate the room item, and play the "item appears" tune.\n
P:14BE6:CheckSecretTriggerNone
P:14BE7:CheckSecretTrigger: Returns:\n C: 1 if the condition for the secret was met\n
P:14BFA:_CheckHasLivingMonsters: Look for monsters in slots $C to 1 that are not bubbles.\n If one is found, return.\n\n Else flag Link not paralyzed (to cancel the effects of a like-like),\n and set the all-dead-in-room flag.\n
P:14C1A:CheckSecretTriggerAllDead: If there are still monsters, not counting bubbles, then return C=0.\n
P:14C1F:: No monsters are left. Trigger shutters to open, and return C=1.\n
P:14C28:CheckSecretTriggerRingleader: If the first monster slot is empty, go kill all monsters.\n
P:14C2D:: If the first monster slot has an object other than a monster,\n then return C=0.\n
P:14C31:: For each object slot from $C to 1:\n\n If the slot is empty, or has something not a monster, or is\n already dying; then go loop again.\n
P:14C42:: Set the object's metastate to die.\n
P:14C4A:: Return C=1.\n
P:14C4C:CheckSecretTriggerBlockDoor: If the block has not been pushed completely, then return C=0.\n
P:14C51:: Else go trigger shutters to open, and return C=1.\n
P:14C53:CheckSecretTriggerBlockStairs: If the block has not been pushed completely, then return C=0.\n
P:14C58:: If BlockPushComplete = 2, then it was pushed, and we already\n took action for the secret. So, return C=0.\n
P:14C5B:: Else BlockPushComplete = 1. It was pushed, but this is the\n first time checking it for a secret. Make it 2.\n
P:14C5E:: Tile object slot
P:14C60:: Stairs in UW always go at ($D0, $60).\n
P:14C68:: Stairs tile
P:14C6D:: Return C=1.\n
P:14C6F:CheckSecretTriggerLastBoss: If the last boss was defeated, then\n go trigger shutters to open, and return C=1.\n
P:14C74:: Else return C=0.\n
P:14C76:CheckSecretTriggerMoneyOrLife: If the money-or-life man is gone, then\n go trigger shutters to open, and return C=1.\n
P:14C7B:: Else return C=0.\n
P:14C7D:UpdateMode11Death_Full
P:14C9C:UpdateMode11Death_Sub1: Submode 1 prepares bottom half of play area attributes.\n\n Play death tune.
P:14CA1:UpdateMode11Death_Sub0: Submode 0 prepares top half of play area attributes.\n
P:14CA4:CueTransferPlayAreaAttrsHalfAndAdvanceSubmodeNT2: Params:\n A: low PPU address\n Y: end offset in PlayAreaAttrs to copy from\n\n\n Use nametable 2.
P:14CA6:CueTransferPlayAreaAttrsHalfAndAdvanceSubmode: Params:\n X: high PPU address\n A: low PPU address\n Y: end offset in PlayAreaAttrs to copy from\n
P:14CAC:UpdateMode11Death_Sub2: Updates all play area tiles.\n
P:14CB4:: Modify the transfer record, so that it changes nametable 2.
P:14CBE:UpdateMode11Death_Sub3: Cue transfer of top half of play area attributes.
P:14CC0:: Go set this TileBufSelector value, and advance submode.
P:14CC3:UpdateMode11Death_Sub4: Cue transfer of bottom half of play area attributes.
P:14CC5:: Go set this TileBufSelector value, and advance submode.
P:14CC8:UpdateMode11Death_Sub5
P:14CCC:: TODO: Cue transfer of bottom half of background palette for this mode.
P:14CCE:: Go set this TileBufSelector value, and advance submode.
P:14CD1:UpdateMode11Death_Sub6
P:14CD3:: Make sure we're using an even nametable number.
P:14CDA:UpdateMode11Death_Sub7
P:14CDC:: Once Link has turned enough times, go to the next submode.
P:14CE0:: If timer hasn't expired, only redraw sprites.
P:14CE2:: Once ObjTimer[11] expires, arm it again, and change direction.
P:14CEA:: If not left, then go check other directions.
P:14CEC:: Facing left.\n
P:14CEE:: Face the next direction (down).
P:14CF2:: Go redraw Link.
P:14CF5:: If not right, then vertical. %A was shifted to become\n horizontal direction counter-clockwise from original\n vertical direction. Got set it and redraw.
P:14CF7:: Facing right.\n\n Face the next direction (up).
P:14CF9:: Go set the direction and redraw.
P:14CFB:UpdateMode11Death_Sub8
P:14CFE:: If done, then go to the next submode.
P:14D01:UpdateMode11Death_Sub9: Cue the transfer of the dead Link (grey) palette row.
P:14D07:: TODO: Here [$E5] means more like spark timer.
P:14D0B:: Go set a delay of $17 ($18-1) frames, and advance the submode.
P:14D0D:UpdateMode11Death_SubA
P:14D0F:: Delay until the timer expires, and we can show the spark.
P:14D11:: The little spark tile.
P:14D13:: TODO: Here [$E5] means more like spark timer.
P:14D17:: TODO: If DeathTurns >= 6, use little spark tile $62.
P:14D19:: Else use the big one.
P:14D1D:: Use Link's Y for both sides.
P:14D23:: Use the spark tile we chose.
P:14D29:: Use palette 5 for the left.
P:14D2E:: Use the same palette, but flip horizontally on the right.
P:14D33:: Use Link's X.
P:14D38:: The second sprite is 8 pixels to the right.
P:14D3E:: TODO: Count down how long you see the spark.
P:14D40:: If not zero yet, then return.
P:14D42:: Play "heart taken" tune.
P:14D47:: Hide the Link/spark sprites.
P:14D4F:: Set a delay of $2D ($2E-1) frames for the next submode.
P:14D56:UpdateMode11Death_SubB
P:14D58:: If the timer hasn't expired, then return.
P:14D5A:: Set a delay of $5F ($60-1) frames for the next submode.
P:14D5E:: Cue transfer of "GAME OVER" text, and advance submode.
P:14D63:UpdateMode11Death_SubC
P:14D65:: If the timer hasn't expired, then return.
P:14D6A:: Go to the Continue Question mode.
P:14D6E:: Request Game Over music.
P:14D75:: Increase the death count for current profile.
P:14D78:: Up to the maximum $FF.
P:14D80-14D8B:BorderBounds: Three sets of border coordinates:\n - outer OW\n - outer UW\n - inner\n\n Within each set, the coordinates are arranged:\n down, up, right, left\n
P:14D8C:Link_FilterInput: [00] holds the opposite of Link's facing direction.\n
P:14D93:: Call GetOppositeDir again to use this mapping:\n In Dir: 1 2 4 8\n         -------\n Index:  2 3 0 1\n
P:14D96:: Get the appropriate coordinate for the direction:\n X for horizontal\n Y for vertical\n
P:14D9E:: [02] holds the coordinate (X or Y).
P:14DA0:: Mask A button and directions if inner border is crossed.\n
P:14DA1:: Save reverse direction index.
P:14DA3:: Add 8 for the third set of border bounds. Each is 4 bytes.
P:14DA6:: Button A will be masked off, if boundary is crossed.
P:14DAB:: Restore reverse direction index.
P:14DAD:: If inner boundary was not crossed, then we'll check the outer\n boundary using player's direction and reverse direction index.\n
P:14DB5:: [00] now holds facing direction instead of the opposite.
P:14DB7:: Get the reverse direction index for the actual facing.
P:14DBA:: If in UW, use the second set of bounds by adding 4\n to reverse direction index.\n\n Else in OW, and use first set that begins at offset 0.\n
P:14DC3:: We won't mask buttons (A) this time. Only directions now.\n
P:14DC5:MaskInputInBorder: Params:\n A: mask of buttons to block\n Y: offset into BorderBounds\n [00]: direction\n [02]: coordinate\n\n Returns:\n [01]: button mask that was used\n       (set to $FF if boundary not crossed)\n
P:14DC7:: If direction is positive (right or down), then go handle it separately.\n
P:14DCD:: The direction is negative (left or up).\n\n If the coordinate does not cross (<) the boundary, then\n go set mask $FF, so that no button is excluded.\n
P:14DD4:: The boundary was crossed. Mask buttons.\n
P:14DD6:: [01] button mask
P:14DDA:: If in OW or button mask <> 0, return.\n
P:14DE2:: Mask off input directions perpendicular to player's facing.\n
P:14DF4:: The direction is negative.\n\n If the coordinate crosses (<) the boundary, then\n go mask buttons.\n\n\n Get coordinate in [02].
P:14DFB:: The coordinate is not crossed; then set mask $FF,\n so that no button is excluded.\n
P:14DFD:: [01] holds button mask.
P:14E00:WieldSword: If there's no sword, return.\n
P:14E05:: Switch to the sword slot.\n
P:14E07:: If state <> 0, then sword or item is in use. So, return.\n
P:14E0B:: The first state lasts 5 frames.\n
P:14E10:: The initial state is 1.\n
P:14E15:: TODO: ?\n
P:14E1A-14E1B:BoomerangLimits
P:14E1C:WieldItem: If the letter slot is selected, return.\n
P:14E38:WieldBoomerang: If missing wooden boomerang and magic boomerang, return.\n
P:14E40:: Switch to the boomerang slot.\n
P:14E42:: If state in object slot <> 0 and high bit is clear, return.\n
P:14E49:: Set state to $10 for boomerang.\n
P:14E4D:: Set the farthest distance the boomerang can fly based on\n the type of boomerang.\n
P:14E56:: Set up the boomerang.\n QSpeed = $C0 (3 pixels a second)\n\n TODO:\n Each turning animation frame lasts 3 screen frames.\n
P:14E63:: See _SetUpWeaponForPlayerStateAndAnim for the reason\n that Link's animation counter is set to 1.\n
P:14E68:: If there's an input direction, then use it as the weapon's direction.\n It might be diagonal, with horizontal and vertical components.\n Else use Link's facing direction.\n
P:14E72:WieldArrow: If there's no bow, return.\n
P:14E77:: Switch to the arrow slot.\n
P:14E79:: If state <> 0 and high bit is clear, return.\n
P:14E80:: If there are no rupees, return.\n
P:14E85:: TODO: ?\n
P:14E8A:: Post a rupee to subtract.\n
P:14E8D:: Arrows start in state $10.\n
P:14E8F:WieldWeapon: Params:\n A: initial state\n
P:14E91:: Set q-speed $C0 (3 pixels a second).\n
P:14E99:: If the direction is vertical, move the object right 3 pixels.\n
P:14EA7:WieldFood: Switch to the food slot.\n
P:14EA9:: If there's an item already active in the slot (state <> 0), return.\n
P:14EAD:: The first state of food lasts $FF frames.\n
P:14EB1:: Set up the food in state $80.\n
P:14EB6:WieldPotion: If there's nothing in the item slot, return.\n
P:14EBB:: We're using one potion. So decrement the item value.\n
P:14EBE:: Flag that we're filling hearts and involuntarily paused.\n
P:14EC7:WieldRod: Switch to the rod slot.\n If it's already in use, then return.\n
P:14ECD:: The first state lasts 5 frames.\n
P:14ED2:: The initial state is $31.\n
P:14ED7:CheckSubroom: Params:\n [0F]: movement direction\n\n Returns:\n [0F]: untouched, or 0\n
P:14EDD:: In a cellar.\n\n If Link's Y >= $40 or input direction <> up, return.\n
P:14EEA:: Look for this room's ID in the 6-element cellar room array.\n
P:14EF5:: Determine the destination room ID, and go there.\n\n If Link's X < $80 look in level block attributes A, else B.\n\n Note that in cellars, level block attributes A and B indicate\n the destination room ID only.\n
P:14F08:: Set Link's position in the destination room.\n
P:14F1C:: In a cave.\n\n Check whether a person is blocking the upper half of the room.\n
P:14F21:: If mode is not $C (shortcuts), go check the screen edge.\n
P:14F25:: In a shortcut cave (mode $C).\n\n If grid offset <> 0, return.\n
P:14F2A:: If Link's Y <> $9D, go check the screen edge.\n
P:14F30:: See if Link is on one of the 3 shortcut stairs.\n X = $50: 1\n X = $80: 2\n X = $B0: 3\n\n If he's not on any, then return.\n
P:14F42:: Look for the current room in the cellar/shortcut room array.\n
P:14F4E:: Add the value of the shortcut chosen to whatever index\n the current room has in the array.\n\n This yields the index of one of the three shortcut rooms\n after the current one.\n
P:14F52:: Wrap around if needed. Go to that room by way of mode $A.\n
P:14F58:_GoToModeAFromCellar: Params:\n A: destination room ID\n
P:14F5D:_GoToModeAFromCave
P:14F61:_EndPrepareMode
P:14F76:: If the player touched the edge of the screen and triggered\n a transition to another mode, then go set up the right mode.\n
P:14F7B:CheckLadder: Params:\n [0F]: movement direction\n\n Returns:\n [0F]: movement direction or 0\n\n\n If the ladder's not in use, return.\n
P:14F7F:: If the ladder is done (state 0), go put away the ladder.\n
P:14F83:: If the ladder is facing vertically, calculate the vertical distance\n between the ladder and Link.\n If Link's X no longer matches the ladder's, go put the ladder away.\n
P:14F9A:: If instead it's facing horizontally, calculate the horizontal distance\n between the ladder and Link.\n If Link's Y no longer matches the ladder's, go put the ladder away.\n
P:14FA8:: If absolute distance < $10, go handle movement on the ladder and set state 2.\n If > $10, go put the ladder away.\n
P:14FAB:: [00] holds the absolute distance between Link and the ladder in whichever axis is relevant.
P:14FB5:: Distance = $10. If player's not facing in the same direction as\n the ladder, go put away the ladder.\n
P:14FBB:: Distance = $10, and player's facing in the same direction.\n\n If the ladder's still in initial state 1, then Link's facing the\n ladder and had not stepped onto it yet.\n Go handle movement on it, but don't change state yet.\n\n But if ladder state is 2, then it means Link completely stepped\n off of the ladder. So the ladder should be put away. In this\n case, fall thru.\n
P:14FC1:: Put away the ladder. Reset ladder slot and destroy the object.\n
P:14FC9::  Set state 2, because we're on the ladder.\n
P:14FCD:: If input direction = 0, go draw and reset moving direction.\n
P:14FD2:: Input direction <> 0. The player intends to move.\n So, see if we need to override the moving direction.\n\n A. If the distance <> 0, and they are facing the same way,\n go draw and set moving direction to Link's direction.\n\n This lets Link step onto the ladder. Otherwise he would have\n been blocked by the water.\n\n Or, Link already passed over the point right over the ladder\n and was allowed to move onto the tiles after the ladder.\n
P:14FD4:: [00] distance between Link and ladder
P:14FDC:: Distance = 0, or facing different directions.\n\n B. If ladder's direction = Link's *moving* direction,\n then go draw and keep moving.\n\n This only applies when distance = 0. Otherwise, (A) would have caught it.\n\n Before checking the ladder, a tile collision check allowed Link\n to move onto the tiles after the ladder.\n\n Note that if Link is not moving, then this test will fail,\n and case (D) will catch it.\n
P:14FDE:: [0F] Link's moving direction
P:14FE2:: C. If opposite of ladder's direction = Link's facing direction,\n then go draw and move in ladder's direction.\n\n You can always step off the ladder where you came from.\n
P:14FE9:: D. If opposite of ladder's direction <> down,\n or input direction <> up,\n then go reset moving direction, and draw.\n\n This will catch all cases of Link facing perpendicular to\n ladder direction. Also, it will catch Link not moving, unless\n ladder direction is up and input direction is up (E).\n
P:14FF4:: E. The ladder's direction is up and input direction is up.\n\n An earlier call to check tile collision would have blocked\n movement, because the tile under Link's top half is a water tile.\n But because Link is squarely on the ladder, we really have\n to check the tile above that one.\n\n Set moving direction to input direction (up) and switch X to\n the player's slot for the purpose of checking tile collision below.\n Based on that, we'll set moving direction according to walkability.\n
P:14FF7:: Check the colliding tile as if Link was 8 pixels up.\n
P:15005:: If the tile is walkable, go draw the ladder and leave the moving\n direction as the input direction (in a roundabout way).\n Else fall thru to reset moving direction and draw the ladder.\n
P:1500F:: Set A to reset moving direction in [0F].\n
P:15011:: Draw the ladder.\n
P:1501F:SetMovingDirAndSwitchToPlayerSlot: Params:\n A: direction\n\n Returns:\n [0F]: direction\n
P:15024:FindNextEdgeSpawnCell: Load [0A] with the value before the call.\n
P:15029:: Loop to look for a place to spawn a monster from the edge\n of the screen. Move counterclockwise, one square at a time.\n\n First, if low nibble = 0, then we're at the left edge.\n We'll move down $10 pixels.\n
P:15031:: Else if low nibble <> $F, then we're at the top or bottom.\n Don't move vertically.\n
P:15037:: Else low nibble = $F. We're at the right edge,\n and we'll move up $10 pixels.\n
P:15039:: Add $10 or -$10 at the left or right edge.
P:1503D:: Next, if high nibble = $E, then we're at the bottom edge.\n Move right one pixel.\n
P:1504A:: Else if high nibble <> 4, then we're at the left or right.\n Dont' move horizontally.\n
P:1504E:: Else high nibble = 4. We're at the top edge.\n Move left 1 pixel.\n
P:15050:: Time to get the address of the column.\n Starting at the top of the leftmost column.\n
P:15053:: Add $2C to the address as many times as the low nibble of [0A],\n in order to point to the column we want.\n
P:1505A:: Each column is $16 tiles. Each square column has two columns.
P:15062:: Turn the row part of [0A] into a tile index.\n row := (([0A] AND $F0) - $40) / 8\n
P:1506D:: If the tile < $84, then it's walkable. So, go use it.\n $84 is a sand tile, which is OK for many monsters; but not\n when coming in from the edges.\n
P:15073:: Bottom of the loop.\n If you reach the original cell, then stop.\n
P:1507A:: Set the spawn cell to the one we found.\n
P:15080:InitModeB
P:15097:InitModeC
P:150AE:ModifyObjCountByHistoryOW:Look for the room in the history.\n
P:150B5:: If found, go check kill count in depth.
P:150BA:: It wasn't found. Check the kill count in the room flags.\n
P:150C1:: If kill count < max, go check kill count in depth.
P:150C3:: The room is not in history, and all foes were defeated.\n So, reset the kill count in room flags.\n
P:150CA:: If kill count in room flags = 0, leave object count alone, and return.\n
P:150D1:: If kill count = 7, go reset object count and object list ID.\n Else subtract kill count from object count.\n
P:150DC:: If the result >= 0, go set the object count to this.
P:150DE:: Else, reset object count and object list ID.
P:150E5:SaveKillCountOW
P:150E8:: Put kill count from the room's flags in [02].
P:150EC:: Reset kill count part of the room's flags.
P:150F2:: RoomKillCount
P:150F8:: If RoomKillCount >= RoomFoeCount, go store the max kill count.
P:150FA:: Limit RoomKillCount to 7.
P:150FC:: Add it to kill count from flags.
P:15101:: If the total > 7,
P:15103:: then limit it to 7.
P:15105:: Combine this new total and the room's flags.
P:1510A:InitMode9
P:1513F:Link_ModifyDirInDoorway: In a doorway (UW), you can only move in the direction\n that you entered it or the opposite.\n\n\n If not in a doorway nor moving, then return.\n
P:15148:: If the facing direction is part of the input direction, then\n keep moving in the facing direction.\n
P:1514F:: If the opposite of the facing direction is part of the input direction, then\n face the opposite direction.\n
P:15157:: If neither direction matched input direction, then\n change input direction to facing direction.\n
P:15168-1516B:DoorwayRequiredCoord: To be considered within a doorway, one condition is that\n Link's perpendicular coordinate ([00]) has to match the doorway's\n (X=$78 for verticals, Y=$8D for horizontals).\n\n TODO:\n See _GetPlayerCoordsForDirection.\n
P:1516C-1516F:DoorwayBoundsMinOver: Player coordinate must be >= these bounds.\n Using these bounds; the player will be considered within the\n bounds of a doorway, if strictly inside or 1 pixel outside.\n
P:15170-15173:DoorwayBoundsMaxOver: Player coordinate must be < these bounds.\n Using these bounds; the player will be considered within the\n bounds of a doorway, if strictly inside or 1 pixel outside.\n
P:15174:DoorwayBoundsMinUnder: Player coordinate must be >= these bounds.\n Using these bounds; the player will be considered within the\n bounds of a doorway, if strictly inside except for 1 or 2 pixels\n at the edge.\n
P:15178:DoorwayBoundsMaxUnder: Player coordinate must be < these bounds.\n Using these bounds; the player will be considered within the\n bounds of a doorway, if strictly inside except for 1 or 2 pixels\n at the edge.\n
P:1517C:CheckDoorway: Params:\n [0F]: moving direction\n\n Returns:\n [0E]: reverse index of doorway direction found, or $FF if blocked\n [0F]: untouched, or changed from 0 to a moving direction\n\n When not at or in a doorway, this function leaves\n [0F] moving direction as is.\n\n When blocked by a door, [0E] will be set to $FF. But [0F]\n will be left as is, assuming that it had been reset before this\n routine by BoundByRoom.\n\n Otherwise, [0F] will be changed from 0 to the door's direction.\n\n\n If already in a doorway, go handle it separately.\n
P:15180:: Not in a doorway. Look for a doorway that Link might be in.\n\n To match a doorway:\n 1. Link's [00] coordinate has to match the doorway's\n    (X=$78 for verticals, Y=$8D for horizontals)\n 2. Link's [01] coordinate has to >=  min bound, and < max bound\n\n The "overflow" bounds are used that consider 1 pixel outside\n a doorway to be part of it.\n
P:15187:: [00] is Link's Y, if facing horizontally; else X.
P:1518E:: [01] is Link's X, if facing horizontally; else Y.
P:15198:: If found a doorway, go see what it does when you touch it.
P:1519D:: Not in any doorway. Reset DoorwayDir.\n Leave [0F] moving direction as is.\n
P:151A2:: In a doorway. DoorwayDir is in A.\n
P:151A7:: Get reverse index of doorway direction.
P:151AA:: [01] is Link's X, if facing horizontally; else Y.
P:151AC:: If the player is within the bounds of the doorway for DoorwayDir\n (for example the left door way, if DoorwayDir = left;\n instead of right doorway while DoorwayDir = left),\n and player is facing in DoorwayDir, then go repeat the\n original search used to enter the doorway.\n
P:151BC:: The player might be in the original doorway facing backwards,\n outside it, or in the other doorway along the axis.\n\n Look for a doorway that Link might be in.\n The difference between this search and the one above\n is that we check the "underflow" bounds that are shorter than\n the full doorway length.\n
P:151BE:: [00] is Link's Y, if facing horizontally; else X.
P:151C5:: [01] is Link's X, if facing horizontally; else Y.
P:151D4:: Not in a doorway. Go set DoorwayDir to 0, and leave [0F] alone.
P:151D6::\n\n [0E] holds reverse index of doorway direction found.\n
P:151D8:: Store input direction in [02] and [0C].\n
P:151E1:: If input direction is not the doorway direction found, return.\n
P:151E6:: Touch the door in the direction we found.\n
P:151E9:: [0D] holds the door attribute.
P:151EB:: Can set [0E] to $FF, if a door blocks the way.
P:151EE:: If blocked, then return and leave DoorwayDir as it was.\n
P:151F2:: Set variables to doorway direction found.\n
P:151F7:: [0F] movement direction
P:151FB:: Movement was not blocked at a doorway.\n If we're at a false wall or bombable, then go pass thru it\n and leave the room.\n
P:1520F:_GetPlayerCoordsForDirection: Params:\n A: direction\n\n Returns:\n [00]: coordinate on perpendicular axis\n [01]: coordinate on direction's axis\n\n [00]: Y if facing left or right, else X\n [01]: X if facing left or right, else Y\n
P:15220:TouchDoor: Params:\n [0C]: door direction\n [0E]: reverse index of direction\n\n Returns:\n [0E]: untouched, or $FF if blocked\n
P:15235:TouchDoorWall
P:15239:TouchDoorOpen
P:1523A:TouchDoorFalse: At first, Link's timer = 0. So set it to $18 frames, and block movement.\n Subsequently, block movement until timer = 1.\n
P:1524A:TouchDoorBombable: Block movement, if this door's direction is not in the open door mask.\n
P:15251:TouchDoorShutter: If a door is triggered or this door wasn't already opened,\n then block movement.\n
P:1525B:: TODO: ?\n
P:15260:: Go block movement while timer <> 0.
P:1526B:TouchDoorKey: If this door was already opened, return.\n
P:15271:: If a door is triggered, go block movement while Link's timer <> 0.\n
P:15275:: If we don't have the magic key nor any normal keys, \n go block movement.\n
P:1527F:: If we don't have the magic key, decrease the key count.\n
P:15282:: Trigger this door to open.\n
P:15287:: Set player's timer to block for $20 frames.\n
P:1528E:: Block movement while Link's timer <> 0.\n
P:15293:ModifyObjCountByHistoryUW: Look for the room in the history.\n
P:1529A:: If found, go subtract kill count from object count.
P:1529F:: It wasn't found. Check the kill count in the room flags.\n
P:152A6:: If not all defeated, go subtract kill count from object count.
P:152A8:: The room is not in history, and all foes were defeated.\n Does the object list ID indicate a non-recurring object?\n
P:152B8:: If it's non-recurring, go reset the object count.
P:152BA:: The object list ID is for recurring objects.\n So, reset the kill count in room flags and level block.\n
P:152C6:: Subtract the level block's kill count from the object count.\n
P:152CE:: If the result >= 0, go set the object count to this.
P:152D0:: Else, reset object count and object list ID.
P:152D7:SaveKillCountUW
P:152DA:: Reset kill count part of the room's flags.
P:152E1:: If no monsters were made in this room, go store the max kill count.
P:152E3:: RoomKillCount
P:152E6:: If RoomKillCount = 0, go compare it to RoomFoeCount.
P:152E8:: If the object template type is ...\n >= $32 and\n <> $3A and\n <> $3B and\n <  $49,\n then it refers to a non-recurring foe that shouldn't be made\n again. So, go store the max kill count for the room.\n 
P:152FB:: Compare RoomKillCount and RoomFoeCount.\n
P:152FE:: If RoomKillCount >= RoomFoeCount, go store the max kill count for the room.
P:15300:: RoomKillCount < _RoomObjCount.\n Add RoomKillCount to level kill count for this room.\n
P:15309:: Cap the kill count to 2.
P:1530F:: Shift the adjusted kill count (up to 2) into the top 2 bits.
P:15313:: Go combine this mask with the room's flags.
P:15316:: For this room in the level block, set kill count to max ($F).
P:1531D:: For this room in world flags, set kill count to max (3).
P:1531F:: Combine the mask with the room's flags.
P:15324-15327:BossSoundEffects
P:15328:CheckBossSoundEffectUW
P:1532E:: Get room flags for boss room.
P:15334:: If the boss was defeated, go turn off ambient sound effects.
P:1533B:: Sound effect index
P:1533D:: Shift the sound effect index to the low end of the byte.
P:15345:: If the room has no boss sound effect, go turn off any that might be playing.
P:15347:: TODO: ?
P:15400:_WriteDoorFaceTileHorizontally: Params:\n [02:03]: address of door tiles for direction and face\n [04]: count of tiles remaining\n [07]: current index (0 to 3) of the tile to copy\n       to the dynamic transfer buf\n [09]: door direction index\n\n Returns:\n Z: 1 if wrote the last tile / [04] became 0\n [04]: original value - 1\n [07]: original value + 1\n\n The door face tile list at [02:03] has pairs of tiles arranged\n vertically. The point of this routine is to access them\n horizontally in order to transfer them to a nametable.\n\n\n For the direction index in [09], look up the base offset of the\n set of 4 indexes in HorizontalDoorFaceIndexes that point to\n the door face tiles at [02:03].\n
P:15405:: Add [07] to the base offset we got above. This yields one\n of four consecutive indexes into HorizontalDoorFaceIndexes.\n
P:15406:: Current index of a tile, abstractly (0 to 3)
P:15409:: With that index, look up the index to use with the door face\n list of tiles at [02:03].\n
P:1540D:: Now we can read one of four tiles inside a door face tile map,\n and copy it to the dynamic transfer buf.\n
P:15412:: Prepare for the next call:\n - increment dynamic transfer buf pointer\n - increment index of tile to copy [07]\n - decrement count of tiles remaining\n
P:15418-15BD7:RoomColumnDirectoryOW
P:15BD8-15F9B:ColumnHeapOW
P:15F9C-15F9D:RoomColumnDirectoryOWAddr
P:15F9E-15F9F:ColumnHeapOWAddr
P:15FA0:WallTileList
P:15FEE-16029:DoorFaceTilesE: 5 sets of 12 bytes laying out door faces facing E.
P:1602A-16065:DoorFaceTilesW: 5 sets of 12 bytes laying out door faces facing W.
P:16066-160A1:DoorFaceTilesS: 5 sets of 12 bytes laying out door faces facing S.
P:160A2-160DD:DoorFaceTilesN: 5 sets of 12 bytes laying out door faces facing N.
P:160DE-162D5:RoomColumnDirectoryUW
P:162D6-163B3:ColumnHeapUW
P:163B4-163D3:RoomColumnDirectoryUWCellar
P:163D4-163F5:ColumnHeapUWCellar
P:163F6:FindDoorAttrByDoorBit: Params:\n [02]: bitmask for target door.\n\n Returns:\n A: door attribute for desired direction in current room.\n [01]: same as [02] if found; $10 otherwise\n [03]: reverse direction index\n\n Door bits:\n 1: E\n 2: W\n 4: S\n 8: N\n\n\n Start with single-bit mask 1.
P:163FA:: Test 4 directions.
P:16400:: Get attr byte A for S/N doors.
P:16407:: If counter >= 2, then get attr byte B instead for E/W doors.
P:1640E:: Store either attribute byte in [$00].
P:16414:: If counter is even, then ...
P:16416:: Isolate N/W doors.
P:1641C:: Isolate S/E doors, if we jump here.
P:16420:: Now [$00] holds isolated door attribute.\n\n\n Test mask passed in [$02] with current single-bit mask in [$01].
P:16424:: If they match, then go return door attribute for current direction.
P:16426:: Shift the single-bit mask left.
P:1642A:: Go test the next direction.
P:1642C:: Else return an invalid door attribute.
P:16434:: Read a zero tile. Reached the bottom of a top wall.\n\n Set up A and X to move top and bottom offsets to the next column.\n
P:16436:: TODO: I think that any value >= 4 would work here;\n so that we keep processing the wall tile list.
P:1643A:: Go move top and bottom pointers.
P:1643C:: Subtract A=1 from bottom offset.\n
P:1643F:: Go increment the wall tile list address, and continue.
P:16442:FillWalls: Load the address of WallTileList.\n
P:1644A:: Load the address of second tile in second row of PlayAreaTiles.\n This is where we'll start loading tiles for the room.
P:16452:: Load the address of second last tile in second row of PlayAreaTiles.\n This is where we'll stop loading tiles for the room.
P:1645A:: Load $A pairs of tiles, top and bottom ($14 tiles total).
P:16460:: Get a tile from wall tile list.
P:16464:: Set the tile at the top and bottom locations.
P:16468:: If the tile isn't the vertical line $DE nor anything >= $E2,\n then set the bottom tile to the next one, which is flipped\n vertically. For example, $E0 => $E1.
P:16474:: Set A to advance to next tile in column.
P:16476:: 1 means subtract 1 from bottom offset.
P:16478:: Decrement count.
P:1647A:: If reached the end of the column,
P:1647C:: then count $A tile pairs again.
P:16480:: Set A to advance to next column (at second tile).
P:16482:: $1F means add this amount to bottom offset to move\n it to bottom of next column.
P:16484:: Increase top offset by 1 tile, or by another amount to get to the next column (at second tile).
P:16487:: We need the amount to add or subtract in A.
P:16489:: If X was 1, then go subtract 1 from bottom offset.
P:1648B:: Else add the original X value to bottom offset,\n intending to move it to the bottom of the next column.
P:1648E:: Increment the wall tile list address.
P:16493:: If wall tile list pointer hasn't reached the end ($94EE), go process tiles again. At this point, we'll have written the walls on the left half of the play area.
P:16495:: Copy rotated 180 degrees, accounting for appropriate\n horizontal or vertical flipping of tiles.\n\n The source is in the top left.
P:1649D:: The destination is the bottom right.
P:164A5:: Copy 1 tile.
P:164AB:: If this is a horizontal line, then go flip it vertically.
P:164AD:: Tiles >= $E0 don't need to be flipped.
P:164AF:: Skip this if tile doesn't need to be flipped.
P:164B3:: If tile < $DC,
P:164B5:: then tile needs 2 added to rotate it 180 degrees.
P:164B9:: Tiles >= $DC only need 1 added to flip them.
P:164C4:: Once source pointer reaches the middle ($6690), we're done.
P:164D3-164D6:DoorBits
P:164D7-164DA:DoorFaceTilesAddrsLo
P:164DB-164DE:DoorFaceTilesAddrsHi
P:164DF-164E2:PlayAreaDoorFaceAddrsLo
P:164E3-164E6:PlayAreaDoorFaceAddrsHi
P:164E7-164E9:NextDoorTileOffsets
P:164EA-164ED:DirIndexToDoorSecondHalfOffsets
P:164EE-164F1:DirIndexToDoorColumnCount
P:164F2-164F5:DirIndexToDoorRowCountMinusOne
P:164F6:LayOutDoors: Copies the right door face for the direction, type, and state\n of the door to the play area tile map.\n\n Also, clears door bits from CurOpenedDoors of doorways\n that are not true doors.\n
P:164F8:_L_LayOutDoors_LoopDoors: For each door, indexed by X, from 3 (N) to 0:\n
P:164FA:: For each half of a door, indexed by [06], from 1 to 0:\n\n [06] indicates whether we're handling the first half of\n the door: Left half for N/S, Top half for E/W.\n
P:164FC:_L_LayOutDoors_LoopHalves
P:164FD:: Save the current direction index (door index).
P:164FE:: [0B] holds direction index.
P:16503:: [02] holds the direction (bit) for the current door.
P:16508:: Begin looking for the door face for the door attribute.\n In general, use the door type as the provisional face;\n except turn 4 into 8.\n
P:1650A:: If door attribute > 4, go use it as the provisional face.
P:1650E:: Door attribute < 4, go process it.
P:16512:: Door attribute = 4, go use 8 as the provisional face.
P:16514:: We jump here if the door type is bombable and its open.\n Change the provisional door face to value 9, which\n will become the "hole in the wall".\n
P:16518:: Door attribute < 4 (open or any wall), clear door bit from\n the mask of opened doors, because this is not a true door.\n
P:16519:: [02] current direction
P:16522:: Furthermore, if door type = 0, then use 4 as the provisional face.\n
P:16528:: The door attribute (DA) has been mapped to a\n provisional door face value (PF) in %A as follows:\n\n DA PF Meaning\n -------------\n 0  4  open\n 1  1  wall\n 2  2  false wall\n 3  3  false wall 2\n 4  8  bombable\n 5  5  key\n 6  6  key 2\n 7  7  shutter\n\n Also at this point, the door bit in CurOpenedDoors\n has been cleared, if the type was "open" or any wall.\n\n\n Save the provisional face.
P:16529:: If the current direction points to a door that has been opened,\n then see if we need to set door flags.\n
P:1652B:: [02] current door direction
P:1652E:: Restore the provisional face.
P:16533:: The current direction points to a door that has been opened.\n It can only be "bombable", "key", "key 2", or "shutter".\n\n\n Save provisional door face in Y register.
P:16534:: Get the direction index.
P:16536:: Put direction index in X.
P:16537:: Restore provisional door face value.
P:16538:: If provisional door face is not for a shutter, then\n it's for a "key" or "bombable". So, set the door's flag.\n\n Else it is for a shutter. Go set provisional door face to 4.\n
P:1653A:: If provisional door face is for "key" or "bombable",
P:1653D:: then set the door's flag.
P:16541:: If the provisional door face = 8 (closed "bombable"),\n then go make it 9 (open "bombable").\n Else make it 4 (open "door").\n
P:16547:: For opened doors, the provisional door face has become:\n\n DA PF Meaning\n -------------\n 0  4  open\n 1  1  wall\n 2  2  false wall\n 3  3  false wall 2\n 4  9  bombable\n 5  4  key\n 6  4  key 2\n 7  4  shutter\n\n\n If handling the first half [06], then calculate OpenDoorwayMask.\n
P:1654B:: [0B] direction index
P:16555:: If provisional door face < 4 (any wall), then go loop another half,\n because the visible door face is already a wall.\n
P:16559:: For all other provisional face values, calculate:\n door face := provisional face - 3
P:1655D:: Furthermore, if the latest provisional door face >= 3, then\n subtract one.\n
P:16562:: Now Y holds the door face index (DFC closed, DFO opened) for the door type (DT).\n\n DT DFC DFO Meaning\n ------------------\n 0  1   1   open\n 4  4   5   bombable\n 5  2   1   key\n 6  2   1   key 2\n 7  3   1   shutter\n\n\n Get the direction index.
P:16567:: If handling the second half, then offset to the second half\n of the tiles.\n
P:1656B:: Advance destination tile address to the second half of door.
P:16571:: Advance source tile address to the second half of door.
P:16576:: Fix Y at 0 for copying source tiles to destination.\n Pointers will be incremented instead of Y.
P:1657B:: [05] holds the column count.
P:1657D:: For each column (3 or 2), indexed by [05] down to 1:\n
P:1657E:: Put the direction index in X.
P:16580:: For each row (2 or 3) in the door, indexed by X,\n starting from highest index down to 0:\n
P:16584:: Copy 1 door tile.
P:16588:: Increment source tile address.
P:1658B:: Get the offset needed for the next play area tile.
P:16591:: If we're at the last row, and the direction is horizontal (< 2), then\n go 1 more tile down, to start the next column at the right place.\n We have to compensate for the fact that E/W doors are \n shorter vertically than N/S doors.
P:16595:: Put direction index in A.
P:16599:: If direction index is horizontal (< 2),
P:1659E:: Bottom of the tile row copying loop.\n Decrement the row index.\n
P:165A1:: Bottom of the column copying loop.\n Decrease the column counter.\n
P:165A5:: Bottom of the door halves loop.\n
P:165A6:: Restore X to the door index.
P:165A7:: Decrement [06] door half counter.
P:165AB:: then go handle it.
P:165AE:: Bottom of the door loop.\n Decrement door index.\n
P:165AF:: If finished the last door (X < 0), then return.
P:165B1:: Go handle the next door.
P:165B4:FetchDoorAddrsFaceTilesSrcAndPlayAreaDst: Params:\n A: direction index\n Y: face index\n\n Returns:\n X: direction index\n [$00:01]: address of door inside play area tile map\n [$02:03]: address of door tiles for direction and face\n
P:165C9:: Add ($C * (face - 1)) to [$02:03].
P:165D5-165E2:HorizontalDoorFaceIndexes
P:165E3-165E6:HorizontalDoorFaceIndexesBaseOffsets
P:165E7-165EA:DoorVramAddrsHi
P:165EB-165EE:DoorVramAddrsLo
P:165EF-165F2:DoorNextRoomIdOffsets
P:165F3:UpdateDoors: If mode = $12, or door timer <> 0, or door command = 0,\n then return.\n
P:16601:: Turn the door command into the desired open or closed state\n to store in [08].\n\n cmd:  7 6 3 2 \n [08]: 2 0 0 0\n\n There are other combinations, but 2, 3, 6, and 7 are the only\n commands intended to be used.\n\n 3 is the end state of 2: close\n 7 is the end state of 6: open\n
P:16610:: Command 2 sets Link's timer to $30.\n
P:1661D:: The command to close a key door or bombable wall does not\n do anything.\n
P:16631:: TriggeredDoorCmd >= 5 or door type = 7\n\n Shutters and the commands to open a door always change\n tiles.\n
P:16634:: Copy [06] to [04] for the call to write tiles below.\n We need to remember how many tiles need to be copied\n in each transfer record.\n
P:16638:: Write the transfer record header for the door.\n\n\n VRAM address high byte of door
P:1663E:: VRAM address low byte of door
P:16644:: 2 for 2 tiles
P:1664A:: Write two tiles in a short loop indexed by [04].\n
P:1664F:: OR the low VRAM address with $20 to go down one row\n in order to work on the second row of door tiles.\n
P:16651:: [01] low VRAM address
P:16655:: Bottom of the loop.\n Loop again to write the second transfer record for the\n second pair of door tiles, if [05] has not reached 0.\n
P:16659:: Write the end marker, and update buffer length.\n
P:16662:: Increment the command.\n
P:16664:: If (new command AND 3) = 0, go update door flags and masks,\n and resetting the door command.\n This ends up catching original states 3 and 7.\n\n Else set door timer to 8 and return.\n
P:1666F:: If the door command = 4 after incrementing it, then\n it was 3 (close door). So:\n 1. reset this door's flag\n 2. remove it from the opened door mask\n 3. reset the door command\n 4. go lay out doors in the play area map\n
P:16675:: [09] door direction index
P:1667A:: Remove the triggered door from opened door mask.
P:16680:_L_SetOpenedDoorMaskAndResetCmdAndLayOutDoors
P:16682:_L_ResetDoorCmdAndLayOutDoors: Reset door command
P:16689:: Door command <> 4.\n It must be 8, which means it was 7: open door.\n\n If the door is a shutter (7), then go add the door to the\n opened door mask, reset door command, and lay out doors.\n
P:16694:: Else the door is not a shutter.\n\n\n [09] door direction index
P:16699:: Get the next room's ID.\n
P:1669F:: Flip the door direction index.\n
P:166A3:: Set the door flag for the opposite door in the next room.\n
P:166AA:: Add the door to the opened door mask, reset door command,\n and lay out doors.\n
P:166B1:_PrepareWriteHorizontalDoorTransferRecords: Params:\n [08]: 0 if closed\n\n Returns:\n X: current length of dynamic transfer buf\n [00]: door VRAM address high byte\n [01]: door VRAM address low byte\n [02:03]: address of door tiles for direction and face\n [05]: 2, the number of transfer records to write\n [06]: 2, the number of tiles in each record\n [07]: 0, the first index of a tile to transfer\n [09]: door direction index\n\n Note that this routine is called with triggered doors:\n doors that can change state. Their door type numbers are >= 4.\n\n If this routine were ever called with a fixed door\n ("open", "wall", or "false"), then it would produce non-sensical\n values for the door face.\n\n\n If triggered door type >= 5 (keys and shutter), play door sound.\n
P:166C3:: Calculate the door face index in three parts.\n\n First, turn door type 4 into 8, and 1 into 4\n (provisional face index in Y register).\n
P:166CF:: Second, subtract 3 from provisional face index.\n
P:166D3:: Lastly, if the door is closed ([08] = 0) and provisional\n face index >= 3, then subtract 1 from it.\n\n But if open ([08] <> 0) and provisional face index <> 5,\n then make it 1.\n
P:166E2:: The routine that returned the door type also returned its\n reverse direction index in [03].\n\n We want a forward direction index. So, subtract [03] from 3.\n
P:166E7:: Call this to put the address of door face tiles in [02:03].\n
P:166EA:: Return the address of the door in the nametable in [01:00].\n Note the order is reversed, as usual with VRAM addresses.\n
P:166F4:: Return the direction of the door in [09], and the dynamic\n transfer buf length in X register.\n
P:166F9:: Return some hardcoded values in [05], [06], [07]. See the comments above.\n
P:16704-16717:ColumnDirectoryUW
P:16718-1671F:PrimarySquaresUW
P:16720:LayoutUWFloor
P:16723:: Save unique room ID.
P:16724:: Load the address of room column directory in [$02:03].
P:1672C:: Restore unique room ID.
P:1672D:: Add ((unique room ID) * $C) to address in [$02:03]. Each unique room has $C columns.
P:1673E:: Load the address of top-left tile in floor of play area in [$00:01].
P:16746:: For each column in room, indexed by [06]:\n
P:1674C:: Get a column descriptor.
P:1674E:: Put column table number * 2 in X.
P:16754:: Load the column table address for this descriptor in [$04:05].
P:1675E:: Get the column descriptor again.
P:16760:: Put column index in X.
P:16765:: Get a square descriptor.
P:16767:: If high bit is set,
P:16769:: then we've found the beginning of a column;
P:1676A:: If this is the column we want, then go handle it.
P:1676C:: Increment the square descriptor offset.
P:1676D:: Go get the next square descriptor.
P:16770:: We found the column.\n
P:16771:: Advance the square descriptor pointer by the offset, so we don't have to keep the offset in Y.
P:16776:: Reset processed row count.
P:16778:: Reset repeat count.
P:1677A:: Write and repeat squares from the column.\n
P:1677C:: Get the square descriptor.
P:1677E:: Get the square index from the descriptor.
P:16789:: Point to next square in column in play area.
P:16790:: Get the square descriptor.
P:16792:: Isolate the count.
P:1679A:: If we haven't repeated this square as specified,
P:1679C:: then increment the processed repeat count;
P:1679E:: and go increment the row, and check if we're done in this column.
P:167A1:: Reset repeat count.
P:167A5:: Point to the next square descriptor.
P:167A8:: Increment the processed row count.
P:167AC:: There are 7 square rows in UW floor.
P:167AE:: If we haven't written 7 rows, then go process a square.
P:167B0:: Move 2 columns right and to the top of the floor area.
P:167B5:: Increment column index.
P:167BB:: If we haven't processed all columns,
P:167BD:: then go process the next one.
P:167C1:WriteSquareUW: Params:\n A: primary square\n Y: offset from [$00:01]\n [$00:01]: pointer to play area\n
P:167C9:: Type 1 square.\n Primary is the first tile. Next 3 tiles in CHR form the rest of the square.\n Primary >= $70 and < $F3.\n
P:167CA:: Write tile+0 to (col, row).
P:167CF:: Write tile+1 to (col, row+1).
P:167D8:: Write tile+2 to (col+1, row).
P:167DD:: Write last tile to (col+1, row+1).
P:167E0:: Type 2 square.\n Primary is a tile used for the whole square.\n Primary < $70 or >= $F3.\n\n\n Write tile to (col, row).
P:167E3:: Write tile to (col, row+1).
P:167EC:: Write tile to (col+1, row).
P:167EE:: Go write tile to (col+1, row+1).
P:167F1:FindAndCreatePushBlockObject: Reset block state and direction.\n
P:167F7:: If the unique room ID is $21, then\n put the push block object at ($40, $80), and go set the type.\n\n TODO: Where is room layout $21 used?\n
P:16805:: Go set the object type and return.
P:16808:: Look for a block tile in row $A of play area, starting in column 4.\n
P:16824:: The block was found in a column with an address at\n offset %X in column table. So the column number would\n be (%X/2), and X coordinate ((%X/2)*8). That means\n multiplying %X by 4.
P:16829:: Row $A is at $90 from the top of the screen.
P:1682D:: Block object type
P:16833:InitMode12: Play "End Level" song.
P:16838:: Set decreasing column for UpdateWorldCurtainEffect.
P:1683C:: Set increasing column for UpdateWorldCurtainEffect.
P:16840:: Set to delay $2F ($30-1) frames when updating mode.
P:16844:: Fill tile map with blanks.
P:16850:: Triforce item type.
P:16858:UpdateMode12EndLevel_Full
P:1686D:UpdateMode12EndLevel_Sub0
P:1686F:: Delay (return) until timer expires.
P:16871:: Set to run next submode for $2F ($30-1) frames.
P:16877:UpdateMode12EndLevel_Sub1: Flash the screen.\n\n $18 is LevelPaletteTransferBuf.
P:1687D:: Every 4 frames, switch palettes.
P:16883:: WhitePaletteBottomHalfTransferBuf
P:16888:: Start filling hearts, and go to next submode.\n\n TODO: why 2?
P:1688F:UpdateMode12EndLevel_Sub2
P:16894:: If finished filling hearts, then go set the timer for the next submode.
P:16897:UpdateMode12EndLevel_Sub3
P:168A2:: If decreasing column hasn't reached the middle (still >= $11), then return.
P:168A4:: Set up a delay of $7F ($80-1) frames for next submode.
P:168AB:UpdateMode12EndLevel_Sub4
P:168B4:: Make sure VRAM address increment is 1.
P:168BE:: Is in OW.\n
P:168C4:LayOutRoom
P:168CB:: Is in UW.\n\n Fill PlayArea with brick tiles that are seen at the margins.
P:168DE:CopyColumnToTileBuf: Params:\n CurColumn: target column + 1\n\n Put $651A in [$00:01]; $16 before $6530 which is the tile map address.\n\n The first iteration of the loop below will add $16 to it before using it.
P:168E8:: Start with X = CurColumn - 1
P:168EA:: Fill dynamic transfer buf from last position written.
P:168ED:: Use PPU address $21xx: a tile along the first row in play area.
P:168F5:: Keep adding $16 until you point to the target column.\n
P:168FD:: $96: $16 tiles, vertically in nametable.
P:16902:: X is $FF. Use it as the end marker.
P:16906:: Move the dynamic transfer buf offset to X.
P:16908:: Reset the tile counter in [$06] and Y.
P:1690C:: Load source tile in TileMap.
P:1690E:: Store it in dynamic transfer buf.
P:16911:: Increment the source address.
P:16914:: Increment the destination offset.
P:16915:: Increment the counter.
P:1691B:: If we haven't copied $16 tiles, then loop again.
P:16924:CopyRowToTileBuf: Put in 00:01 the address of the\n first tile of current row in play area.
P:16934:: Indicate the target VRAM address:\n $2100 + (CurRow * $20)
P:1694F:: Indicate 32 bytes to copy.
P:16954:: Put an end marker.
P:16957:: Copy a row from column map in RAM to tile buf.\n
P:1695B:: Copy a tile.
P:16962:: Advance to the tile in the same row, but next column of play area.
P:16965:: Advance to the next tile in the row in transfer buf.
P:16968:: If we haven't written $20 tiles, then go write another.
P:1696A:: The transfer buf is $23 bytes (3 for header, $20 for payload).
P:16970-16975:TileObjectTypes
P:16976-1697B:TileObjectPrimarySquaresOW
P:1697C-169B3:PrimarySquaresOW
P:169B4-169F3:SecondarySquaresOW
P:169F4:LayoutRoomOW: Load the address of room column directory in [$02:03].\n
P:169FE:: Reset [06] for use in multiplication below.
P:16A02:: Get unique room ID (OW).
P:16A04:: The low 6 bits have the unique room ID.
P:16A07:: Add ((unique room ID) * $10) to address in [$02:03]. Each unique room has $10 columns.\n
P:16A1B:LayoutRoomOrCaveOW: Params:\n [02:03]: address of room column directory\n\n Load the address of world flags in [$08:09].\n
P:16A28:: For each column in room, indexed by [06]:\n
P:16A2A:: Reset [$0C] used for tracking repeat state.
P:16A30:: Get a column descriptor.
P:16A32:: Put column table number * 2 in X.
P:16A38:: Load the column table address for this descriptor in [$04:05].\n
P:16A42:: Get the column descriptor.
P:16A44:: Put column index in X.
P:16A49:: Look for the beginning of a column.\n
P:16A4A:: Get a square descriptor.
P:16A4C:: If high bit is clear, then go read the next square descriptor.
P:16A4F:: If this isn't the column we want, then go keep looking.
P:16A51:: We found the column.\n
P:16A52:: Advance the square descriptor pointer by the offset, so we don't have to keep the offset in Y.
P:16A55:: Reset row number in [07].
P:16A5B:: Get the square descriptor.
P:16A5D:: Get square index and put it in [$0D] and X.
P:16A65:: Save primary square.
P:16A66:: Get room flags.
P:16A6C:: If the secret wasn't found in this room, then skip all this.
P:16A6E:: Restore primary square.
P:16A6F:: The secret was found in this room.\n
P:16A71:: If this is a tree, go turn it into stairs.
P:16A75:: If this is a rock wall, go turn it into a cave entrance.
P:16A79:: If this not a special armos, go leave the primary as is.
P:16A7B:: This is a tree or a special armos ($EA).\n Set the primary to stairs ($70), and square index to the\n first value ($10) for a type 1 square.\n
P:16A83:: This is a rock wall. Turn it into a cave entrance.\n
P:16A88:: Restore primary square, if it wasn't modified above.
P:16A91:: Point to next square in column in play area.
P:16A98:: Get square descriptor.
P:16A9C:: If we need to repeat this tile,
P:16A9E:: then flip [$0C].
P:16AA2:: After the second time flipping it, [$0C] = 0, and we've repeated it once. So,
P:16AA4:: Point to the next square descriptor.
P:16AA7:: Increment the processed row count.
P:16AAB:: There are $B square rows in the play area.
P:16AAD:: If we haven't written $B rows, then go process a square.
P:16AAF:: At the end of a column, we've reached the top of the next one.\n Move one more column over to get to the next square column.
P:16AB4:: Increment column index.
P:16ABA:: If we have processed all columns, then return.
P:16ABC:: Go process the next one.
P:16ABF:CheckTileObject: Params:\n A: primary square\n\n Returns:\n A: primary square corresponding to tile object, else argument\n\n\n Find the index X corresponding to the primary square: $E5  => 0; $EA => 5.\n
P:16AC7:: If we found the primary, go handle it.
P:16ACE:: If the primary isn't between $E5 to $EA, then return.
P:16AD3:: Save primary square.
P:16ADA:: Get current column in play area where we'll put a square.
P:16ADC:: Store the X coordinate of tile object (column * $10).
P:16AE3:: Get current row in play area where we'll put a square.
P:16AE5:: Store the Y coordinate of tile object ((row * $10) + $40).
P:16AEF:: Restore primary square.
P:16AF1:WriteSquareOW: Params:\n A: primary square\n Y: offset from [$00:01]\n [$0D]: square index\n [$00:01]: pointer to play area\n\n\n Get square index.
P:16AF5:: If square index < $10, go handle a secondary square.
P:16AF7:: Type 1 square.\n Primary is the first tile. Next 3 tiles in CHR form the rest of the square.\n Square index >= $10.\n
P:16AF8:: Write tile+0 to (col, row).
P:16AFD:: Write tile+1 to (col, row+1).
P:16B06:: Write tile+2 to (col+1, row).
P:16B0B:: Write last tile to (col+1, row+1).
P:16B0E:: Type 3 square.\n Square index refers to a set of 4 tile indexes in secondary squares table.\n Square index < $10.\n\n\n X := (square index * 4)
P:16B15:: Write tile+0 to (col, row).
P:16B1C:: Write tile+1 to (col, row+1).
P:16B27:: Write tile+2 to (col+1, row).
P:16B2D:: Go write tile+3 to (col+1, row+1).
P:16B30:PatchColumnDirectoryForCellar: In OW, set first address of directory to start of OW column heap, as expected.\n
P:16B3A:: In UW, set the first address of column directory to start of UW cellar column heap.\n
P:16B45-16B4C:SubroomColumnDirectoryAddrs
P:16B4D:LayoutCaveAndAvanceSubmode: Usual cave
P:16B5E:LayoutShortcutAndAdvanceSubmode: Offset of address of column directory of shortcut cave
P:16B73:CheckShortcut
P:16B77:: If the player found the secret, then return.
P:16B7D:: If the shortcut wasn't seen in this room, then return.
P:16B85:: Divide X coordinate by 4 to get offset into column address table.\n Think of it this way. Divide X by 8 to get tile column number.\n Then multiply by 2 to turn it into an offset for an address.\n
P:16B88:: Put address of column that has X coordinate into [$00:01].
P:16B92:: Subtract $40 from X coordinate to get rid of status bar.
P:16B96:: Divide new Y coordinate by 8 to get a tile row.
P:16B99:: Keep tile row (offset) in Y register.
P:16B9A:: Get the tile that's where the shortcut should be.
P:16B9E:: If it's a tree, go prepare a stairs square.
P:16BA2:: If it's a gravestone, then return.
P:16BA6:: If it's not a rock wall, then go prepare a stairs square.
P:16BAD:: If the room's tile object is a rock, go prepare a stairs square.
P:16BAF:: Else make the tile object nothing, and write a black tile.\n But this branch seems to be unused.
P:16BBC:: The first type 1 square index.
P:16BC2:: Go write a stairs square.
P:16BC4:_ChangePlayMapSquareOW: Save object index.
P:16BC6:: We're dealing with squares.\n So, align the object's X coordinate with 16 pixels.\n
P:16BCA:: Divide it by 4 to get the offset of the address of the column\n in play area map.\n\n The calculation is: address offset = (X / 8) * 2\n 8 for the width of the column; 2 for the width of the address\n
P:16BCD:: Store the address of the column in [00:01].\n
P:16BD7:: Get object index.
P:16BDA:: Align the object's Y coordinate with 16 pixels.\n
P:16BDE:: Subtract $40 for the status bar; and divide by 8 for\n the height of each row.\n
P:16BE4:: Add this row offset to the column address.\n
P:16BE7:: Assume that we'll write a type 1 square with primary square\n taken from [05]. If so, the square index doesn't matter\n as long as >= $10. See WriteSquareOW.\n
P:16BED:: If tile < $27 or >= $F3, we'll write a type 3 square.\n So, we have to look up the square index corresponding\n to primary square/tile in [05].\n\n Look in primary square table from $E to 1. If a match is found,\n then the X register will have the square index value.\n
P:16BFF:: Write the square.\n
P:16C04:: Restore object index.
P:16C07:FetchTileMapAddr: Returns:\n [$00:01]: address of room tile map
P:16C10:CopyNextRowToTransferBufAndAdvanceSubmodeWhenDone: Returns:\n C: 1 if copied the last row\n
P:16C13:: If done, then go to the next submode.
P:16C16:CopyNextRowToTransferBuf: Returns:\n C: 1 if copied the last row\n
P:16C20:LayoutRoom_SubmodeTask
P:17000:InitMode3_Sub2
P:17007:: Go cue a transfer of palettes, and go to next submode.
P:17009:InitMode3_Sub3_TransferTopHalfAttrs: Low byte of destination PPU address for NT attributes.
P:1700B:: Offset of the end of first half of play area NT attributes.
P:17010:InitMode3_Sub4_TransferBottomHalfAttrs: Low byte of destination PPU address for NT attributes.
P:17012:: Offset of the end of second half of play area NT attributes.
P:17016:InitMode3_Sub5: Cue transfer of static elements of status bar.
P:1701D:InitMode3_Sub6
P:1701F:: If in OW, skip checking the level's map.
P:17024:: If we don't have the map, go to the next submode.
P:17028:: Cue transfer of map in status bar, and go to next submode.
P:1702A:InitMode3_Sub7
P:1702D:: If level is OW, then go to next submode.
P:1702F:: Patch the level number character in "LEVEL-X" transfer buf.
P:17032:: Cue transfer of "LEVEL-X" text and go to next submode.
P:17036:InitMode3_Sub8
P:17039:: Set up columns numbers for curtain effect.\n\n Decrease from column $F ($10-1).
P:1703D:: Increase from column $10 ($11-1).
P:17040:: TODO: ?
P:17044:: Make Link face up by default.
P:17048:: Put Link in the middle horizontally by default.
P:1704C:: Put Link at StartY from level info by default.
P:17054-1705D:_AllObjRoomBounds: Two sets of 5 elements:\n * left bound for objects\n * right bound for objects\n * up bound for objects\n * down bound for objects\n * first unwalkable tile\n\n The first set is for OW. The second is for UW.\n
P:1705E:_SetupObjRoomBounds: Offset of second set of bounds.
P:17062:: If in UW, use second of bounds, and go copy them.
P:17064:: Reset DoorwayDir and use first set of bounds.\n\n\n Offset of first set of bounds.
P:17077-17079:LeavingRoomRelativePositions
P:1707A:InitMode6
P:1707D:: TODO: ?
P:17082:: If in UW,
P:17084:: TODO: then ?
P:17087:: TODO: Draw Link?
P:17091:: TODO: get door attribute in direction we're facing
P:17094:: If the door attribute is "false wall",\n then play the "found secret" tune.
P:1709B:: Play "found secret" tune.
P:170A1:: If the player is at an "open", "key", or "shutter" door,\n then the player walked all the way to the edge of the play\n area. So, use index 2 to set Link's relative position to 0.\n\n Otherwise, the player is at wall level. Link has to walk to the\n edge of the play area. So, set a relative position that\n reflects that distance: $28 or -$28.\n\n If walking in a decreasing direction (left or up), then\n Link's relative position is $28 and has to decrease to 0.\n\n If walking in an increasing direction (right or down), then\n Link's relative position is -$28 and has to increase to 0.\n
P:170B6:_ResetInvObjState: Reset LadderSlot. No ladder is active.\n
P:170BA:: Reset ObjState of all weapons.\n
P:170C3:_GetDoorPassingThruAttr: Returns door attr in direction Link's facing (mode 6),\n or opposite direction (other modes).\n\n Returns:\n A: door attribute\n Y: whether Link is facing an increasing direction (right or down)\n\n\n If Link's direction is right or down, then 1 will be returned.\n Else 0.
P:170CE:: If in mode 6, use Link's direction to get a door attribute.\n Else use the opposite direction.
P:170E1:CopyPlayAreaAttrsHalfToDynTransferBuf: Params:\n X: high PPU address\n A: low PPU address\n Y: end offset in PlayAreaAttrs to copy from\n
P:170FC:InitModeA
P:17117:_InitModeAOrB_Sub0
P:17127:_DrawDynamicElementsBetweenRoomsAndAdvanceSubmode
P:17130:_InitModeAOrB_AdvanceSubmode
P:1713C:InitModeA_Sub3And9
P:17147:InitModeA_Sub2: TODO: ?
P:1714B:InitModeA_Sub8: TODO: ?
P:1714F:_InitModeB_Sub1: Transfer the cave BG palette rows.\n
P:17153:InitModeA_Sub1
P:17157:: Transfer the OW palette again, because it was changed\n for a cave.\n
P:1715A:InitModeA_SubA
P:17166:InitModeA_Sub6_FillTileAttrsAndTransferTopHalf
P:1716B:InitModeB_Sub5_FillTileAttrsAndTransferTopHalf: An OW room that has the same NT attributes as a cave.
P:17173:InitModeAOrB_TransferBottomHalfAttrs
P:1717B:_L_DisableSprite0Check
P:17180:InitMode_WalkCave: If reached the end of the walk, then go start updating.\n
P:17185:: Move and draw facing up.\n
P:171CD:InitMode9_Sub9: Set Link's input direction to the facing direction, and\n update the player object; so that it walks down the stairs\n of the cellar. Stop when it reaches Y coordinate $5D.\n
P:171DB:: Reset player state.
P:171DF:: Remember that this is a cellar.
P:171E3:: Start updating the mode.
P:171E6:World_FillHearts
P:171E8:: If not filling hearts, then return.
P:171EA:: Play the "heart taken" tune.
P:171F4:: If HeartPartial >= $F8, go complete a heart.
P:171F6:: else add 6.
P:171FD:: Set HeartPartial to zero for the next heart.
P:17205:: If hearts <> heart containers, go increase hearts.
P:17207:: They're equal, so make HeartPartial full by\n decreasing from 0 to $FF.
P:1720A:: We reached the end. So stop filling hearts.
P:17218-17224:SubmenuTransferBufSelectorsUW
P:17225-17239:SubmenuTransferBufSelectorsOW
P:1723A:_CueTransferSubmenuRowUW: If menu scroll value is negative, then we transferred everything.\n So, return.\n
P:1723E:: Shift right. The value in A is now (menu scroll value) / 2,\n and represents the current row of the submenu being processed.\n The bottom bit tells us (1) whether to transfer a full row of\n black tiles, or (0) a row of the map or other piece of the GUI.\n\n If the bottom bit is set, go prepare the full black row.\n
P:17242:: Submenu rows $D to $15 are parts of the map.\n Submenu rows 0 to $C are fixed text and boxes.\n\n If submenu row < $D, cue a transfer of the static transfer\n buffer for this row.\n
P:1724C:: If map row = $15, go cue the transfer of the bottom edge\n of the big map sheet.\n
P:17255:: Else row is between $D and $14. Prepare a map row.\n
P:17258:: Decrease the counter for the next frame.\n
P:1725B:: Prepare the dynamic transfer buf with a row of blank ($24) tiles\n to transfer to row (7 + Y).\n\n Calculate PPU address ($28E0 + Y*$20).\n
P:17267:: High PPU address
P:1726D:: Low PPU address
P:17272:: Repeating 1 byte $20 times
P:17277:: Blank tile
P:1727C:: End marker
P:17282:_CueTransferSubmenuRowOW:\n\n If menu scroll value is negative, then we transferred everything.\n So, return.\n
P:17286:: Shift right. The value in A is now (menu scroll value) / 2,\n and represents the current row of the submenu being processed.\n The bottom bit tells us (1) whether to transfer a full row of\n black tiles, or (0) a row of the triforce or other piece of the GUI.\n\n If the bottom bit is set, go prepare the full black row.\n
P:1728A:: There's nothing to do for row $15.\n If submenu row < $15, cue a transfer of a triforce or other\n transfer buffer for this row.\n
P:17293:: Decrease the counter for the next frame.\n
P:17296-17299:AxisMasks:Indexed by reverse direction index.\n\nIs used in mapping a direction to a mask for its axis.\nFor example:\n- right masks off up and down\n- up masks off left and right\n
P:1729A:Link_HandleInput: If state = 0, handle A and B buttons.\n
P:172A1:: If the sword is not blocked, then handle the sword if A is pressed.\n\n\n SwordBlockedTimer
P:172B1:: If B is pressed, handle the item.\n
P:172BA:: If player was shoved, return.\n
P:172C0:: If in UW, then move correctly inside doorways.\n
P:172C7:: Change directions according to whether the player is at an intersection point\n (grid offset = 0) or between points along a line (grid offset <> 0).\n
P:172CF:Link_ModifyDirAtGridPoint: Grid offset = 0, so A = 0 here.\n Reset some variables.\n\n\n [0B] holds input direction count.\n
P:172D1:: [0C] holds walkable direction count.
P:172D3:: Reset this. We'll figure out if needs to be set again.
P:172D5:: Look for walkable directions that are components of the\n input directions.\n\n Keep track of how many and which directions were input\n directions and walkable.\n
P:172DD:: If this direction doesn't match, skip it.
P:172DF:: [0F] holds the last input direction found.
P:172E1:: Save the reverse direction index.
P:172E3:: Increment the input dir count in [0B].
P:172EB:: If this is unwalkable, skip it.
P:172EF:: [0D] holds the last walkable direction found.
P:172F1:: Increase the walkable direction count in [0C].
P:172F3:: Restore the reverse direction index.
P:172F8:: If there were no input directions, then return.\n
P:172FD:: There were input directions.\n\n If there was only one input direction, go set object direction\n to input direction, and set Link's speed.\n\n Also, *RESET* Link_GoStraightWhenDiagInput\n (X is still 0, because it's Link's object index).\n
P:17303:: There were more than one input directions.\n\n If none were walkable, go set input direction to 0, and return.\n
P:1730A:: Two input directions, and at least one of them is walkable.\n\n Make Link go straight in one direction on the next grid line.\n
P:1730D:: If in OW or only one direction of the two is walkable, then go set\n object direction and input direction to last walkable direction\n found, and set Link's speed.\n\n Also, *RESET* Link_GoStraightWhenDiagInput.\n
P:1730F:: [0D] holds last walkable direction found.
P:17319:: In UW. There are two input directions, and they're both walkable.\n\n Normally, turn to the direction that's perpendicular to object\n direction. But keep going straight after that, while diagonal\n input is held.\n\n Handle special cases for doors.\n\n\n 1. Link at horizontal doors.\n\n If Link's X = $20 or $D0 then\n   If Link's Y = $85 and facing down then\n     Go set object direction and input direction to object\n     direction, and set Link's speed. Also, *RESET*\n     Link_GoStraightWhenDiagInput.\n   Else\n     Go turn to the perpendicular direction\n
P:17333:: If allowed to turn when input is diagonal (2 directions), then\n go take the direction perpendicular to object direction.\n
P:17339:: At this point, Link_GoStraightWhenDiagInput is true.\n\n\n 2. Link at top door.\n\n If Link's X <> $78 or Link's Y <> $5D then\n   Go set object direction and input direction to object\n   direction, and set Link's speed. Also, *SET*\n   Link_GoStraightWhenDiagInput.\n
P:1733B:: Also do it if in OW. But if in OW, we returned already.
P:17349:: If object direction is vertical then\n   Go set object direction and input direction to object\n   direction, and set Link's speed. Also, *SET*\n   Link_GoStraightWhenDiagInput.\n
P:1734D:: Find the input direction that's perpendicular to the\n object's direction.\n
P:1734F:: Make sure to set Link_GoStraightWhenDiagInput.
P:17350:: Do this to get reverse index of object direction.
P:17356:: Save input directions.
P:17357:: Mask input directions with the mask for the object's direction's axis.
P:1735C:: Restore input directions.
P:1735F:: Set object and input direction to value in A.\n Set Link_GoStraightWhenDiagInput to value X.\n
P:17366:_InitLinkSpeed: Link gets a quarter speed (QSpeed) of $60 by default (1.5 pixels a frame).
P:1736C:: If in OW, go use this speed.
P:1736E:: In OW. If standing on mountain stairs, then\n use a lower quarter speed of $30.
P:17380:: If Link's speed is not this lower speed,
P:17382:: then reset the position fraction.
P:1738D:Link_ModifyDirOnGridLine:\n If not moving, then return.\n
P:17392:: If there's more than one component in the input direction,\n then take only one of them.\n\n After this point, Y holds the reverse index of this single direction.\n
P:17398:: If the single input direction matches object direction,\n then keep going in this direction.\n
P:1739C:: If the single input direction is the opposite of object direction, then\n change to the single input direction.\n
P:1739E:: Combined opposite horizontals (1 OR 2).
P:173A2:: Combined opposite verticals (4 OR 8).
P:173A4:: If the directions are perpendicular, go handle this case.
P:173A9:SetObjDirAndInputDir: Params:\n A: direction\n
P:173AF:: The directions are perpendicular.\n\n Keep going in facing direction, if that's what Link's been told to do.\n
P:173B3:: Link's movement grid cell size is 8. If he's moved half that\n length or more, then return.\n
P:173BF:: [01] holds the opposite of facing direction.
P:173C6:: If Link had turned back and is facing a grid point that he\n had started walking from, then return.\n
P:173D8:: Reverse Link's direction.\n
P:173DC:: Reverse the grid offset. Yield an offset for the same position\n in the line, but in the opposite direction. For example,\n -1 => 7\n 3 => -5\n\n Positive offset: -8 - -offset\n Negative offset:  8 - -offset\n
P:173F4:CheckWarps: If just came out of a cave, dungeon, or cellar; or if grid offset <> 0;\n then return.\n
P:173FB:: If in OW room $22 and Link's X is not a multiple of 8, then return.\n This is a special case, because Level 6's entrance is wide.\n
P:1740D:: In other OW rooms and in UW, make sure X is a multiple of $10.\n
P:17413:: If Link's Y is not at ((multiple of $10) + $D), then return.\n
P:1741B:: Check tile collision standing still.\n
P:1741E:: If in OW, go handle the tile separately.\n
P:17425:: In UW.\n\n If tile is not part of stairs square (tiles $70 to $74), return.\n
P:1742D:: Prepare to leave this room.\n
P:17432:: Remember what room we were in.
P:17435:: Look for a room in cellar array that has the current room as\n destination room A or B.\n
P:17448:: Make the cellar found the current room, and the target mode 9.\n
P:1744E:: TODO:\n If the target mode is not 9, restart the OW song?\n
P:17458:: Reset the flute timer.\n
P:1745A:: Go to mode $10.\n
P:17464:SaveKillCount
P:1746F:HandleWarpOW: Save the tile that Link is standing on; so that we know how\n to go underground.\n
P:17471:: If (tile < $70 or >= $74) except for $24 and $88; then return.\n
P:17481:: If Link touched a stairs tile ($70 to $74), then\n use $70 to represent them all.\n
P:17489:: Get the cave index attribute.\n
P:1748E:: Cave index
P:17490:: If < $40, go deal with a level.\n $40 means cave index $10. Levels have cave indexes 1 to 9.\n
P:17494:: If attribute <> $50, go to mode $B for a regular cave.\n
P:1749A:: Attribute = $50 meaning cave index $14 (shortcuts).\n Go to mode $C for a shortcut cave.\n
P:1749F:: Load a level.\n\n Shift right by two to get the level number.\n
P:174A5:: Remember where we came from.
P:174A8:: Target mode is 2 to load a level.
P:174AC:InitSaveRam: If already cleared, then return false.
P:174BA:: Since we're clearing save RAM, treat file B as committed.
P:174C5:: TODO: Clear from $6530 to the end of Save RAM.
P:174E4:: Return C=1.
P:174E6:: Return C=0.
P:174E8:ClearRam
P:174EA:: It doesn't touch [$07FF].
P:174EF:: Clear a few individual variables that are left.
P:174FB:: Clear RAM from 0 to $EF.
P:17503:: The first time looking for an edge cell to spawn a monster\n from, look here first.\n
P:1750A:: These are part of the IsSaveFileActive array.\n\n Mode 1 Menu checks 5 elements of the array to see\n if the option can be chosen. The first 3 are the save\n slots. The last two are the register and eliminate options.\n\n So, theses two should always be set.
P:17513-17516:NextRoomIdOffsets
P:1751C:: Shift single-bit mask.
P:1751F:: Go test next bit.
P:17522:CalculateNextRoomForDoor: Params:\n [E7]: direction\n\n\n Map door bit/direction to an index as follows:\n 1: 3\n 2: 2\n 4: 1\n 8: 0\n\n Note that this is the opposite of the usual mapping.
P:17524:: [00] holds a single-bit mask to compare
P:17526:: Index
P:17528:: Compare argument to single-bit mask.
P:1752C:: If they don't match, go try the next one.
P:17531:: TODO: [$04E4] holds unique room ID.
P:17534:: Look up offset used to calculate next room ID from current one.
P:1753A:: Adding the offset to RoomId yields the room ID in the desired direction.
P:17545:: If the next room ID is invalid, then fall thru, and reload OW.
P:17547:EndGameMode12
P:1754A:: TODO: ?
P:1754C:: Set OW (level 0).
P:17552:: Set to type 2: dungeon level.
P:17554:: TODO: ?
P:17559:MaskCurPpuMaskGrayscale
P:17560:CalcNextRoomByDir: Params:\n A: direction\n\n Returns:\n A: next room ID\n
P:17562:: Set up the single-bit mask.
P:17564:: For each direction in [00]  indexed by X:\n
P:17566:: Compare the direction argument with the single-bit mask [00].
P:17568:: If they match, go use this index.
P:1756D:: Go check the next direction.
P:17573:: Adding offset and room ID yields next room ID.
P:17577-1757E:_MapRowMasks
P:1757F:_WriteSheetMapRowTransferRecord: The row is $10 tiles and bytes long.
P:17581:: Get the submenu row by dividing (current menu scrolling value) by 2.\n
P:17585:: Write an end marker at the end of the row data.\n
P:1758A:: We'll transfer $10 bytes.
P:1758F:: Calculate PPU address ($290C + X*$20).\n
P:175A4:: Write a map mark in the dynamic transfer buf for each room\n in the range currently being scanned.\n
P:175A6:: Save the current scanned room index before writing any marks.
P:175A7:: Y register is $10.
P:175AF:: Restore the current scanned room index and subtract $10.\n
P:175B5:: If the level info indicates that the submenu map should be\n rotated horizontally, then loop to rotate right the number of\n bytes indicated.\n
P:175D1:: Exclude rooms that are not part of this level, and certain rooms\n that should never be marked visited in the submenu map.\n\n First calculate the map row:\n ((current menu scrolling value) / 2) - $D\n
P:175DA:: For each element ($10) in the row, starting from $F:\n If the current row is set in the submenu map mask,\n then replace the tile with $F5, a blank map tile.\n
P:175EB:HasCompass: Returns:\n A: 0 if compass of current level is missing.\n\n\n Check compasses.
P:175EF:HasMap: Returns:\n A: 0 if map of current level is missing.\n\n\n Check maps.
P:175F3:: If in OW, then return.
P:175F6:: Base the level number on zero.
P:175FA:: If in level 9,
P:175FC:: then check the level 9 variables.
P:175FE:: Sanitize the zero-based level number.
P:17604:: Return the item value for the current level.
P:17608:_WriteScanningMapRoomMark: Params:\n Y: offset from the third element in dynamic transfer buf\n    to write at (between 1 and $10)\n\n\n Save dynamic transfer buf offset.
P:1760A:: Call this to load the address of level block world flags.
P:1760D:: Save current room ID.
P:17610:: Temporarily set current room ID to the room ID we're scanning,\n in order to look up its information.\n
P:17614:: Set OpenDoorMask to $13, in case the room has not been\n visited. $E2 will be added, yielding $F5, which is the blank\n map mark tile.\n
P:17619:: Get the currently scanned room's visit state.\n
P:1761D:: Visit state
P:1761F:: If it's been visited, then check each of the 4 doors,\n and build an open door mask.\n\n Start with direction up and direction index 3.\n
P:17623:: [02] holds door direction
P:17632:: Restore current room ID and dynamic buffer offset.\n
P:17637:: The map marks are arranged in the same order as all the\n possible values of OpenDoorMask.\n\n Add $E2 for the first map mark tile, and store it in the\n dynamic transfer buf at the current offset.\n
P:17641:CalcOpenDoorwayMask: Call for each direction index (3 to 0) to build an open doorway mask\n based on doorway type and room flags. Each call will shift the next\n doorway state bit into OpenDoorwayMask.\n\n Params:\n A: door attribute\n X: direction index\n\n Returns:\n A: untouched\n
P:17643:: Save door attribute.
P:17646:: If door attribute < 4 (open or any wall), go shift the appropriate bit.
P:17648:: Else we have to find out the walkability from the room flags.\n
P:17649:: Save direction index.
P:1764B:: TODO: Save Y=0?
P:1764F:: Clear carry to anticipate a zero AND result, meaning not walkable.
P:17650:: AND room flags with single-bit mask for direction.
P:17653:: If result is not zero, then door hasn been opened,
P:17655:: and set carry, so that a 1 will be shifted into the mask.
P:17657:: TODO: Restore Y=0.
P:17659:: Restore direction index in X.
P:17663:: Restore door attribute.
P:17665:: The door attribute indicates the walkability.\n
P:17667:: If door attribute is "open", carry is set, and go shift a 1 into the mask.
P:1766A:: Door attribute is a wall, carry is clear, and go shift a 0 into the mask.
P:1766C:AddDoorFlagsToCurOpenedDoors
P:1768D:IsDarkRoom_Bank5: Params:\n Y: room ID\n\n Returns:\n A: $80 if dark, else 0\n
P:17697-176A6:SubmenuItemXs
P:176A7:DrawSubmenuItems: Look for a magic boomerang, then a wooden boomerang.\n If you find one, then draw it.\n
P:176B3:: If don't find either, skip drawing a boomerang.
P:176B7:: [01] Y
P:176BB:: [00] X
P:176BE:: Copy the item slot.
P:176C2:: Look at the rest of the items, starting at index 1.\n
P:176C7:: If at the compass item slot, check this level's compass.\n
P:176CE:: Set compass item slot $10 again.
P:176D0:: If at the map item slot, check this level's map.\n
P:176D7:: Set map item slot $11 again.
P:176D9:: If there are none of this item, then go advance the index and loop again.\n
P:176DD:: If at the letter item slot, look at what's in the potion slot.\n If there is a potion, then go advance the index and loop again.\n That's because we already prepared sprites for the potion.\n
P:176E6:: Save the item slot.
P:176E8:: Save item slot to Y register. Maybe this was in anticipation of calling E735?
P:176E9:: Look up and set the X coordinate of this item.\n
P:176EC:: [00] X
P:176EE:: If the item goes in the first selectable row (item slot < 5),\n then go set Y coordinate to $36 and draw.\n
P:176F4:: If the item goes in the second selectable row (item slot < 9 or = $F),\n then go set Y coordinate to $46 and draw.\n
P:176FE:: If the item goes in the unselectable row at the top (item slot < $10),\n then go set Y coordinate to $1E and draw.\n
P:17704:: The Y coordinate of the compass is $9E; and the map's is $76.\n The X coordinate for both is $2C.\n
P:17710:: [01] Y
P:17715:: Restore the item slot.
P:17717:: Loop until item slot = $12.\n
P:1771D-17725:SubmenuCursorXs
P:17726:UpdateSubmenuSelection: Pseudo-item slot 0 is for boomerangs.\n If its not the currently selected item slot, then skip this.\n
P:1772B:: Look for a magic boomerang, then a wooden boomerang.\n If you find one, then use its item slot.\n
P:17739:: Draw the item in the box for the currently selected item,\n if we have it.\n\n There's also the special case for the letter. If the selected item\n is the letter, but we have a potion, then skip this.\n\n If the letter is selected and there's no potion, then make\n the item value 1 in [04]. Except that, the call to 05:B81C\n below will overwrite [04].\n
P:17747:: Special case for letter selected and no potion.
P:17749:: [04] holds the item value.
P:1774D:: [01] Y
P:17751:: [00] X
P:17756:: If the selected item slot is the letter's and we have potions,\n then select the potion item slot.\n
P:17767:: Look up the X coordinate for the selected item slot.\n Set it for the left cursor sprite.\n Then add 8 to set the right cursor sprite's X.\n
P:17773:: The Y coordinate is $36 for item slots < 5, else $46.\n
P:17781:: $1E is the cursor tile.\n
P:17789:: Flash the cursor.\n Use palette rows 5 and 6 for 8 frames each.\n
P:17795:: Flip the right sprite horizontally.\n
P:1779A:: TODO:\n If input direction = [EF] item search direction in the previous frame, return.\n
P:177A1:: Copy input direction to X register.
P:177A2:: If input direction = 0, up, or down; then we won't change\n the change the selected item slot forward or backward.\n\n Instead, jump to this routine to make sure an occupied slot\n is selected, then return.\n
P:177A8:: Cue the "selection changed" tune.\n
P:177AD:: Move the selection in the input direction.\n\n\n Save the input direction.
P:177AE:: Save selected item slot.
P:177B2:: Restore the input direction.
P:177B6:: If the new item slot = old item slot, go cancel the\n "selection changed" tune.\n\n\n Pop selected item slot.
P:177BC:: Else the selection changed. The new slot should have an item.\n If it does not, then cancel the "selection changed" tune.\n
P:177C8:FindAndSelectOccupiedItemSlot: Params:\n A: direction to search: 0=none, 1=forward, 2=backward\n Y: starting item slot\n\n Returns:\n [EF]: direction to search\n
P:177CA:: Check 9 slots.
P:177D1:: If this is the boomerang pseudo-slot. Go check boomerangs.
P:177D5:: If it's the bow slot, then skip it. You can't select it.
P:177DA:: Found an item. Go see if the slot is OK.
P:177DE:: This is the potion slot, but not potion. Go check the letter.
P:177E1:: If there are more slots, then check the next one.
P:177E3:: We found no items. Set CurItemIndex to zero.
P:177E7:: If not the arrow, go set CurItemIndex.
P:177EC:: If we don't have the bow, then keep looking for a slot.
P:177EE:: Set CurItemIndex to the slot we found.
P:177F2:: Check the boomerangs.\n\n Start with the magical boomerang.
P:177F7:: We have one of the boomerangs. Go use the boomerang pseudo-slot 0.
P:177FE:: There are no boomerangs. So continue searching where we left off.
P:17803:: Go finish up with pseudo-slot 0 for boomerangs found.
P:17808:: Check the letter.\n
P:1780D:: If there's a letter, go see if there's a potion.
P:17811:: There's no letter, so continue searching where we left off.
P:17816:: If there's no potion, then go set CurItemIndex to the letter slot.
P:1781C:DrawItemInInventoryWithX: [$00]: X\n [$01]: Y\n X: item slot\n
P:17821:Cycle9InDirection: Params:\n [$EF]: direction to search: 0=none, 1=forward, 2=backward\n Y: value to cycle\n\n If A = 0, does nothing.\n If A = 1, Y := (Y + 1) mod 9\n If A = 2, Y := (Y - 1) mod 9\n
P:1783A:CreateRoomObjects: Reset ObjState[$13] to activate room item object.\n
P:1783E:: If in OW, go create heart container in room 5F.\n
P:17842:: If the player got the room item already, go deactivate\n the room item object.\n
P:17847:: Look up the item for this room, and store it.\n If it's item ID 3, then deactivate the object.\n\n Item ID 3 normally means the master sword. But because the\n usual value meaning "no item" ($3F) can't fit in the level\n block attribute for a room item (up to $1F); use 3 to\n stand in for it.\n
P:1784C:: Room item
P:17856:: If secret trigger is 3 "last boss" or 7 "foes for item",\n then deactivate room item object. They'll be activated by\n the secret action.\n
P:17859:: Secret trigger
P:17863:: Deactivate room item object by setting ObjState[$13] to $FF.
P:17865:: If there's a push block in the room, then look for where\n it goes, and activate it.\n
P:17868:: Push block
P:1786F:: Set the X and Y for the room item object.\n
P:17876:: If the room item is a triforce piece,\n the move it left 8 pixels.
P:1787B:: Room item
P:1787D:: Triforce piece
P:17889:: Try to make the heart container in OW.\n\n\n Heart container
P:1788D:: Load the coordinates of the heart container in\n OW room $5F.\n
P:17891:: If in mode 5, and in room $5F, then go store the coordinates\n in the object slot.\n
P:1789D:: Else deactivate the object.\n
P:17F98:SetMMC1Control_Local5
P:17FAC:SwitchBank_Local5
P:18000-18013:LevelBlockAddrsQ1
P:18014-18027:LevelInfoAddrs
P:18028:CommonDataBlockAddr_Bank6
P:1802A-1803D:LevelBlockAddrsQ2
P:1803E:InitMode2_Submodes
P:18047:InitMode2_Sub0: Copy level block for level.\n
P:18052:: First quest.\n
P:1805E:: Second quest.\n
P:18070:InitMode2_Sub1: Copy level info.\n
P:1808C:CopyCommonDataToRam: Get the source address of common data block in ROM.
P:180A4:FetchLevelBlockDestInfo: Returns:\n [$02:03]: destination address\n [$04:05]: end address\n\n Destination address $687E.
P:180AC:: End address $6B7D.
P:180B5:FetchLevelInfoDestInfo: Returns:\n [$02:03]: destination address\n [$04:05]: end address\n\n Destination address $6B7E.
P:180BD:: End address $6C7D.
P:180C6:FetchDestAddrForCommonDataBlock: 67F0 to 687D (inclusive)
P:180D7:CopyBlock: Params:\n [$00:01]: source address\n [$02:03]: destination address\n [$04:05]: end address\n\n Also increments submode.\n
P:18109:UpdateMode2Load_Full: Make replacements for the second quest.\n
P:1810E:: If not second quest, then return.
P:18112:: If OW, then go patch rooms.
P:18117:: TODO:\n Get an address for the current level that points\n to an array of replacement bytes for Q2 UW level info.\n\n This address array doesn't access the OW element (0).\n So, it overlaps the last two bytes of LevelInfoUWQ2Replacements9.
P:18121:: TODO:\n Get the number of replacement bytes for Q2 UW level info.\n\n This address array doesn't access the OW element (0).\n So, it overlaps the last byte of the address array at [$83A2].
P:18124:: Copy bytes from Q2 replacement array to level info\n starting at offset $29 (shortcut position array).
P:1812D:: Replace attributes of several rooms in OW in second quest.\n
P:1815F-18166:LevelBlockAttrsBQ2ReplacementOffsets
P:18167-1816E:LevelBlockAttrsBQ2ReplacementValues
P:1816F-181A7:LevelInfoUWQ2Replacements1
P:181A8-181DE:LevelInfoUWQ2Replacements2
P:181DF-1821B:LevelInfoUWQ2Replacements3
P:1821C-18254:LevelInfoUWQ2Replacements4
P:18255-18297:LevelInfoUWQ2Replacements5
P:18298-182D7:LevelInfoUWQ2Replacements6
P:182D8-18316:LevelInfoUWQ2Replacements7
P:18317-18359:LevelInfoUWQ2Replacements8
P:1835A-183A3:LevelInfoUWQ2Replacements9
P:183B5-183BE:LevelInfoUWQ2ReplacementSizesMinusOne
P:18400-186FF:LevelBlockOW
P:18700-189FF:LevelBLockUW1Q1
P:18A00-18CFF:LevelBLockUW2Q1
P:18D00-18FFF:LevelBLockUW1Q2
P:19000-192FF:LevelBLockUW2Q2
P:19300-193FB:LevelInfoOW
P:193FC-194F7:LevelInfoUW1
P:194F8-195F3:LevelInfoUW2
P:195F4-196EF:LevelInfoUW3
P:196F0-197EB:LevelInfoUW4
P:197EC-198E7:LevelInfoUW5
P:198E8-199E3:LevelInfoUW6
P:199E4-19ADF:LevelInfoUW7
P:19AE0-19BDB:LevelInfoUW8
P:19BDC-19CD7:LevelInfoUW9
P:19CD8-19D65:CommonDataBlock_Bank6
P:1A000-1A07F:TransferBufAddrs
P:1A080:TransferCurTileBuf
P:1A08F:: TODO: Why put $3F in [$0300]? Is it the maximum size of dynamic transfer buf?
P:1A09E:: Empty the tile buffer.
P:1A0A2:ContinueTransferTileBuf:\n\n Save VRAM address high byte.
P:1A0A7:: Read low byte of VRAM address.
P:1A0AD:: Read count and attribute byte.
P:1A0B5:: If high bit is set, then auto-increment VRAM address by 32.
P:1A0C1:: If bit 6 is set, then repeat one tile.
P:1A0C5:: increment Y index to point to first byte of text.
P:1A0C7:: If the count was 0 (bottom 6 bits),\n then make it 64.
P:1A0CD:: We pulled the flags out, and we're left with a count in A.\n Move it to X.
P:1A0CE:: If the original bit 6 is clear,
P:1A0D0:: then increment Y index (not repeating).
P:1A0D9:: Restore VRAM address high byte.
P:1A0DA:: If we wrote to $3Fxx, then set PPUADDR to $3F00, then $0000.\n
P:1A0EA:: Advance the source address to one after the last byte read.\n
P:1A0F6:TransferTileBuf
P:1A0FB:: Read high byte of VRAM address.
P:1A0FD:: End when we read a negative VRAM address.
P:1A100-1A180:Mode1TileTransferBuf
P:1A183-1A201:ModeFCharsTransferBuf
P:1A202-1A209:GanonPaletteRow7TransferBuf
P:1A21D-1A225:BlankTextBoxLines
P:1A226-1A22E:BlankPersonWares
P:1A22F-1A234:SubmenuTriforceApexTransferBuf
P:1A235-1A244:SubmenuTriforceBottomTransferBuf
P:1A245-1A24C:GhostPaletteRow7TransferBuf
P:1A24D-1A254:GreenBgPaletteRow7TransferBuf
P:1A255-1A25C:BrownBgPaletteRow7TransferBuf
P:1A272-1A27D:WhitePaletteBottomHalfTransferBuf
P:1A27E-1A285:RedArmosPaletteRow7TransferBuf
P:1A286-1A28D:GleeokPaletteRow7TransferBuf
P:1A28E-1A295:AquamentusPaletteRow7TransferBuf
P:1A296-1A29D:OrangeBossPaletteRow7TransferBuf
P:1A29E-1A2A5:BombCapacityPriceTextTransferBuf
P:1A2A6-1A2B3:LifeOrMoneyCostTextTransferBuf
P:1A2B4-1A2D2:Mode8TextTileBuffer
P:1A2D3-1A315:StatusBarStaticsTransferBuf
P:1A316-1A322:InventoryTextTransferBuf
P:1A323-1A336:SubmenuBoxesTopsTransferBuf
P:1A337-1A347:SubmenuBoxesSidesTransferBuf
P:1A348-1A34F:SelectedItemBoxBottomTransferBuf
P:1A350-1A35F:UseBButtonTextTransferBuf
P:1A360-1A377:InventoryBoxBottomTransferBuf
P:1A378-1A39B:SubmenuMapRemainderTransferBuf
P:1A39C-1A3AF:SheetMapBottomEdgeTransferBuf
P:1A3B0-1A3B8:SubmenuAttrs1TransferBuf
P:1A3B9-1A3BD:SubmenuAttrs2TransferBuf
P:1A3BE-1A3C2:BlankBottomRowNT2TransferBuf
P:1A3C3-1A3C7:BlankRowTransferBuf
P:1A3C8-1A3CF:Mode11DeadLinkPalette
P:1A3D0-1A3E7:GameOverTransferBuf
P:1A3E8-1A3F3:Mode11BackgroundPaletteBottomHalfTransferBuf
P:1A3F4-1A3F8:Mode11PlayAreaAttrsTopHalfTransferBuf
P:1A3F9-1A3FD:Mode11PlayAreaAttrsBottomHalfTransferBuf
P:1A3FE-1A868:StoryTileAttrTransferBuf
P:1E400-1E43F:PlayAreaColumnAddrs
P:1E440:RunGame
P:1E452:: Enable NMI.
P:1E45B:LoopForever
P:1E45E:ClearAllAudioAndVideo
P:1E463:: Turn on audio except DMC.
P:1E468:: Turn off video.\n TODO: except clipping is explicitly disabled. Why?
P:1E46D:TurnOffVideoAndClearArtifacts
P:1E47D:ClearNameTableWithHiAddr
P:1E484:IsrNmi
P:1E488:: If need to switch name tables,
P:1E48A:: Switch to the other name table ($2000 <-> $2800).
P:1E48C:: Disable NMI.
P:1E490:: Make sure table is 0 or 2.
P:1E495:: Set PPUMASK.\n Start with curren mask value, but ...
P:1E497:: If checking for sprite 0,
P:1E49B:: TODO: or TileBufSelector = 0 and [$17] = 0,
P:1E4A3:: then make sure all video is on.
P:1E4AA:: Copy all our sprites to OAM.\n
P:1E4B4:: Reset scroll register.\n
P:1E4C4:: Reset PPUADDR.\n I believe that the write of $3F00 is unneeded.
P:1E4D4:: If Sprite 0 Hit is set,\n then wait for it to be cleared by the ending of VBLANK.\n
P:1E4DB:: Clear shift register.
P:1E4DE:: TODO: ?\n
P:1E4EA:: If updating a game mode instead of initializing one,\n then simply scroll for game modes 0, 5, 9, $B, $C, $13.
P:1E518:: If paused or in menu,\n then don't decrement timers.
P:1E51E:: Advance the stun cycle.
P:1E52F:: Decrement timers (object and optionally stun timers).
P:1E53B::abc\ndef
P:1E53D:: TODO: ?
P:1E542:: Scramble the random array.
P:1E573:: Enable NMI.
P:1E580:ResetPpuRegisters
P:1E594:ClearNameTable: A : Hi byte of starting VRAM address\n X : Tile number\n Y : Tile attribute byte
P:1E59D:: Make sure to auto-increment VRAM by 1.
P:1E5B0:: Fill one nametable with the tile.
P:1E5B6:: TODO: ???
P:1E5C5:: Fill the related attributes with the attribute byte.
P:1E5DF:: Set X to the passed in value.\n Y was already its passed in value.
P:1E5E2:TableJump
P:1E5F7:HideAllSprites
P:1E608:ClearRam0300UpTo: Params:\n A: high byte of high address to reset\n Y: low byte of high address to reset\n\n Resets all bytes from $300 to byte Y of page A.\n
P:1E61F:: We overwrote the dynamic transfer buf with zeroes.\n But the cleared state of the tile buf has the end marker at\n the beginning. Write the end marker.
P:1E625:TurnOffAllVideo
P:1E62D:ReadInputs: Signal the controllers to poll.
P:1E632:: Finish polling.
P:1E640:ReadOneController: Read over and over until you get \n two of the same readings in a row\n (three from the very beginning).\n [02] : previous reading in this loop\n [03]/2 : successive matching readings (for each controller)\n
P:1E642:: TODO: Why poll again?
P:1E652:: Roll the button bits in. Here ButtonsPressed means "down now".
P:1E655:: The expansion port reading will be in [$00].
P:1E65E:: If we didn't get the same reading, then try again.
P:1E666:: If we didn't get at least two of the same readings, then try again.
P:1E668:: Combine the controller and expansion inputs.
P:1E673:: Now ButtonsPressed means "down now instead of before".
P:1E679:TryUpdateTriforcePositionMarker
P:1E67B:: If in OW, then return.
P:1E685:: If player hasn't gotten the compass, then return.
P:1E68F:CalculateNextRoom
P:1E691:: If in OW, all directions are open.
P:1E693:: Look up door attribute for player's direction.\n
P:1E69F:: The same as [02].
P:1E6A1:: TODO: Set [E7] to a door bit/direction bit.
P:1E6A3:: A holds the door attribute.
P:1E6B8:: Use player's direction bit.
P:1E6BA:: Use "open" door attribute.
P:1E6BD-1E6C5:LevelMasks
P:1E6C6:MarkRoomVisited
P:1E6C9:: Visit state (UW)
P:1E6CE:GetRoomFlags: Returns:\n A: flags for the room in level block world flags\n Y: room ID\n [$00:01]: address of level block world flags\n
P:1E6DD:: Put room item object where the first monster is.\n
P:1E6E5:: Go draw the item at this position.
P:1E6E8:: Pop and return.\n
P:1E6EA:MoveAndDrawRoomItem: If the item was taken, or it wasn't active, then return.\n
P:1E6EF:: Room item object state
P:1E6F3:: If the item type is "none" ($3F), then return.\n
P:1E6F9:: If there's a room item, and object 1 is a like-like, stalfos, or gibdo;\n then move the item along with the monster.\n
P:1E6FE:: Like-Like
P:1E702:: Stalfos
P:1E706:: Gibdo
P:1E70A:: A monster is not carrying the item. So draw the item as usual.\n\n\n Room item is in object slot $13.
P:1E70C:: Pass item type to AnimateItemObject.
P:1E70E:AnimateItemObject: Params:\n A: item type\n X: object index\n\n\n Save the item ID.
P:1E70F:: If the lifetime timer of the item >= $F0 and even, then\n return without drawing. This makes it flash at first.\n\n\n MULTI: ObjPosFrac [03A8][X] is used to count down the life of the item.
P:1E717:: Pop and return, if timer >= $F0 and even.
P:1E719:: Copy room item object position to sprite descriptor.\n
P:1E71C:: Look up the item description for this item ID.\n Store the item value part of it in [04].\n\n\n Restore the item ID.
P:1E71D:: X now has item ID.
P:1E723:: If item descriptor is $30, go set item value to $FF.
P:1E725:: only take the item value part of the descriptor.
P:1E727:: [04] holds the item value.
P:1E729:: Get item slot for the item ID, and draw the item.\n
P:1E72D:: Now X and Y have the item slot.
P:1E731:: Use item value $FF.
P:1E735:DrawItemInInventory: Params:\n X: item slot\n Y: item slot\n [00]: X\n [01]: Y\n
P:1E738:: The item inventory value can also serve as a palette row attribute.
P:1E73A:DrawItemBySlot: Params:\n X: item slot\n Y: item slot\n [00]: X\n [01]: Y\n [04]: item value / sprite palette row attribute\n
P:1E73D:: (A) If the item flashes (slots $16, $19, $1A, $1B),
P:1E74D::  then every 4 frames,
P:1E754:: Switch between palettes 5 and 6.
P:1E756:: (B) If the item varies by color (slots 0, 2, 4, 7, $B),
P:1E768:: Go add the palette offset we looked up and sprite palette row attribute.
P:1E76A:: We got here in one of three ways:\n\n A. The item flashes. Attribute value 1 or 2 was chosen\n    explicitly.\n B. The item color varies. ItemSlotToPaletteOffsetsOrValues\n    held an offset that was added to base palette attribute\n    passed in [$04]. This corresponds to class 2 items.\n C. Item doesn't change color. ItemSlotToPaletteOffsetsOrValues\n    held absolute attributes.\n\n At this point, A holds the final sprite attributes.
P:1E76C:: [0C] refers to frame 0.
P:1E770:: Write sprites.\n A holds the calculated sprite attributes.\n Y holds the item slot.
P:1E773:: Calculate sprite attributes by adding item value / sprite palette\n row attribute and the element from ItemSlotToPaletteOffsetsOrValues,\n which here represents an offset from the palette row.\n
P:1E774:: Add palette offset to item value / sprite attribute we started with.
P:1E776:: If item slot is 0 and palette is 6,
P:1E77E:: then make the item slot $20, a special slot to differentiate the image of the master sword.
P:1E780:: Go write the sprites.
P:1E783:: We have a potion to draw.\n\n\n Potion item slot.
P:1E788:: Go draw the potion.
P:1E78A:DrawStatusBarItemsAndEnsureItemSelected: Draws the selected item and the sword in the status bar.\n Before drawing the item, it ensures that CurItemIndex\n refers to an occupied, equippable item slot.\n\n This accounts for the fallback behavior between potions\n and letters and the two boomerangs.\n\n Start at slot zero. Normally, it would be used to\n check swords. When it's used as the selected item index;\n it's a pseudo-slot used for checking boomerangs.\n
P:1E78D:: If pseudo-slot zero is chosen, then go check boomerangs.
P:1E792:: If there's no item in the current item slot, then go check for potions and letters.
P:1E794:: We have an item. See if it's in the letter slot.
P:1E796:: If it's not the letter slot, then go draw it.
P:1E798:: It's in the letter slot. See if we have a potion.
P:1E79B:: If we have a potion, then go set CurItemIndex to its slot, and draw it.
P:1E79D:: Otherwise, we only have a letter.
P:1E79E:: Use only 1 as the palette attribute.
P:1E7A0:: Set palette attribute to inventory value.
P:1E7A2:: Set X and Y coordinates for "B" item in status bar: ($7C, $1F).
P:1E7B2:: Go handle the sword.
P:1E7B5:: Check the magic boomerang first.
P:1E7BA:: If we have one of the boomerangs, then go draw it.
P:1E7BF:: Go check the next boomerang.
P:1E7C3:: No boomerangs. Go search for an occupied slot starting at 0.
P:1E7C9:: If there's an item in this slot, then CurItemIndex was already\n set. Go handle the sword instead of drawing the item.\n Next frame, we'll draw this item.
P:1E7CB:: Not found. Search for an occupied slot.
P:1E7D2:: Go backwards from current slot.
P:1E7D7:: Handle the sword.\n
P:1E7DC:: If there's no sword, then return.
P:1E7DE:: Set X and Y coordinates for "A" item in status bar: ($94, $1F).
P:1E7EE:: No item in slot.\n
P:1E7F0:: If the current item slot isn't for potions, then go handle the slot almost as usual.
P:1E7F2:: This slot is for potions but don't have one. Check the letter.
P:1E7F5:: If we don't have a letter, then go look for an occupied slot.
P:1E7F7:: We have a letter. Set CurItemIndex to its slot.
P:1E7FC:: Go handle the sword (indirectly).
P:1E7FE:CheckLiftItem
P:1E801:: If there's no item to lift, then return.
P:1E806:: If the item lift timer has expired, go return to normal.
P:1E808:: Set player state to halted.\n
P:1E80C:SetUpAndDrawLinkLiftingItem: Params:\n [0505]: item type\n\n\n Set item X the same as Link's.
P:1E810:: Set item's Y $10 pixels above Link's.
P:1E817:DrawLinkLiftingItem: Params:\n [0505]: item type\n\n\n We're dealing with Link object.
P:1E81C:: Set 0 sprite attributes. 0 was returned above.
P:1E81F:: Set frame 0.
P:1E821:: Point to Link's sprites.
P:1E830:: Temporarily set left alignment.
P:1E836:: Now deal with item object.
P:1E840:: If this item is half-width,
P:1E842:: Then lift with one hand.\n Change the right side to a tile without the arm raised.
P:1E848:EndLinkLiftingItem: Make Link idle, and reset the item type.\n
P:1E84F:: If in UW, play the level's song again.\n
P:1E85A:GetUniqueRoomId: Returns:\n A: unique room ID\n Y: room ID\n
P:1E85F:: Unique room ID in both OW and UW.
P:1E862:_ChangeTileObjTiles: Params:\n A: first tile\n X: object index\n [F7]: not 0 to switch to bank 4 before returning\n\n\n First, cue the transfer of the 4 tiles to nametable 0.\n\n [05] holds the first tile.
P:1E864:: Save object index.
P:1E868:: [03] holds the X coordinate.
P:1E86C:: [02] holds the Y coordinate.
P:1E871:: Start writing from where we left off last time.
P:1E874:: Two transfer records will be written to the buffer and an end marker.\n\n Each record is 5 bytes and will transfer 2 tiles arranged vertically.\n In total, 11 bytes will be written.\n\n First, write the high byte of PPU address in each record.\n
P:1E87C:: Write the low address in the first record. In the second record,\n write (low address + 1).\n
P:1E887:: Write the first tile twice in each record. Patch them later.\n
P:1E895:: If tile >= $46 and < $F3, add 2 to the tile bytes in the second record.\n Add 1 more to the second byte in each record.\n Here is an example result of this manipulation:\n   record 1: $70, $71\n   record 2: $72, $73\n
P:1E8AC:: Set the count byte in each record to $82:\n 2 tiles arranged vertically\n
P:1E8B4:: Write the end marker.\n
P:1E8B9:: Update dynamic buffer length with 10 new bytes.\n
P:1E8C0:: Restore object index.
P:1E8C7:: Change the tiles in the play area map.\n
P:1E8CA:: TODO: ?\n If [F7] is set, switch to bank 4, and reset [F7].\n
P:1E8D8:FillTileMap: Params:\n [$0A]: tile
P:1E8F8:InitializeGameOrMode
P:1E90C:: Mark Save RAM initialized, so we can check after reset.
P:1E919:InitMode
P:1E94B:InitMode0
P:1E96F:InitMode1
P:1E977:InitMode2
P:1E97E:: Submode 0.\n First step, transfer level pattern blocks and copy common code.\n\n\n TODO: ?
P:1E981:: Clear level kill counts.\n
P:1E9A1:InitMode7
P:1E9AB:: If not checking sprite 0, return.
P:1E9AD:: After the last submode (5 or 6), sprite-0 check was enabled.\n So, set the appropriate mirroring for scrolling during mode update.\n\n\n TODO: [$F3] ?
P:1E9B3:: If player is facing horizontally, then enable vertical mirroring;\n else horizontal mirroring.
P:1E9B9:: horizontal mirroring
P:1E9BD:: vertical mirroring
P:1E9C3:InitModeEandF
P:1E9CB:InitMode13
P:1E9D8:InitMode3
P:1E9F7:InitMode3_Sub0
P:1E9F9:: TODO: [17] ?
P:1EA00:_ClearRoomHistory: Returns:\n A: 0\n\n TODO: Also resets [0529].\n
P:1EA04:: TODO: [$0529]?\n From Loz/ItemObj.cpp:\n                // The original game skips checking hearts, and shoots, if [$529] is set.\n                // But, I haven't found any code that sets it.\n
P:1EA07:: Clear the room history.\n
P:1EA0E-1EA10:SaveSlotToPaletteRowOffset: Each element is the offset of a palette row starting from\n row 4. Index by save slot number.
P:1EA11:InitMode3_Sub1
P:1EA13:: If in UW, then go set room ID to StartRoomId.
P:1EA1A:: If it's set to a valid room ID, then start there.
P:1EA24:: If CaveEnteredRoomId was valid,
P:1EA26:: then keep CaveEnteredRoomId invalid by default.
P:1EA2B:PatchAndCueLevelPalettesTransferAndAdvanceSubmode
P:1EA30:: Get the color at byte 1 of row 4, 5, or 6 of menu palettes,\n according to save slot. This holds Link's color in that\n save slot.
P:1EA33:: Put the value in byte 1 of row 4 of level palettes that will\n be transferred.
P:1EA36:: Cue transfer of level palettes.
P:1EA3D:_DrawDynamicElementsBetweenRooms
P:1EA51:_ResetPlayer
P:1EA59-1EA61:SpecialBossPaletteTransferBufSelectors
P:1EA62-1EA6A:SpecialBossPaletteObjTypes
P:1EA6B:InitMode5Play
P:1EA6E:: TODO: draw Link?
P:1EA75:: In UW.\n\n Certain bosses and boss-like monsters need\n their own palettes. If we're dealing with one, then get\n the matching transfer buffer selector.\n
P:1EA7D:: If the object type doesn't match, go check the next one.
P:1EA82:: Go cue the transfer of this palette row. The selector is in X.
P:1EA87:: If it doesn't match any boss type, go copy and transfer level palette row 7.
P:1EA89:: In OW.\n\n If the room is 0F and we just walked in instead of\n coming out of underground; then play "secret found" tune.\n
P:1EA98:: Choose a palette transfer buf for a tile object that has sprites.\n Rock, gravestone, Armos1, Armos2\n\n\n Ghost palette row
P:1EA9F:: If tile object type is gravestone ($65), go cue transfer buf $20.
P:1EAA3:: If tile object type is Armos1 ($66), go see if the room's attributes should override transfer buf $20.
P:1EAA7:: If type is not rock ($62) (so Armos2), go set the right selector.
P:1EAA9:: It's a rock tile object.\n Choose palette based on inner palette attribute to match it.\n\n\n Brown palette row
P:1EAB2:: If the room's inner palette attribute is odd, go cue transfer buf chosen above ($20 if Armos1, else $24).
P:1EAB4:: Green palette row
P:1EAB6:: Else it's even, so go cue transfer buf $22.
P:1EAB8:: Tile object is Armos2. Use red Armos palette row.\n
P:1EABA:: Go cue this transfer buf.
P:1EABC:: Patch and cue palette row 7 transfer buf (6) with row 7\n of level palette.\n
P:1EACB:_RunCrossRoomTasksAndBeginUpdateMode_PlayModesNoCellar: Called in modes 5, $B, $C.\n
P:1EAD3:_RunCrossRoomTasksAndBeginUpdateMode_EnterPlayModes: Called in modes 4, 5, 9, $B, $C.\n
P:1EADD:_RunCrossRoomTasksAndBeginUpdateMode: Called in modes 4, 5, 6, 9, $B, $C.\n
P:1EAE5:: Look for the current room in room history.\n
P:1EAF4:: If it's not found, then store at the cycling history index.\n
P:1EB0D:: If not in mode 5, go start updating the mode.\n
P:1EB11:: If not in mode 5, go start updating.
P:1EB13:: Run cross-room tasks that apply only to mode 5.\n
P:1EB30:UpdateMode
P:1EB62:UpdateMode7Scroll
P:1EB6C:: If still checking sprite 0, return.
P:1EB6E:: TODO: Reset [$F3].
P:1EB70:: Set horizontal mirroring and our normal PRG ROM bank mode.
P:1EB76:UpdateMode8ContinueQuestion
P:1EB7E:UpdateMode10Stairs
P:1EB86:UpdateMode11Death
P:1EB8E:UpdateMode12EndLevel
P:1EB96:UpdateMode2Load
P:1EBA1:GoToNextMode: Returns:\n A: zero\n
P:1EBA3:EndGameMode: Sets IsUpdatingMode to 0.\n Sets submode to 0.\n\n Returns:\n A: 0\n
P:1EBAA:UpdateMode3Unfurl
P:1EBAF:: If the left column hasn't reached the left edge, then return.
P:1EBB1:: Set horizontal mirroring.
P:1EBB8:: If underground exit type <> 0, then in OW and ...
P:1EBBA:: go to next mode, and reset Link's relative position.
P:1EBBD:: Else go play level song, next mode, and reset Link's relative position.
P:1EBC0:UpdateMode4and6EnterLeave
P:1EBC2:: If UndergroundExitType is set, go step out of underground (or cellar).
P:1EBC4:: We're walking from room to room:\n * entering in mode 4 (method 2)\n * leaving in mode 6\n\n\n If relative position reaches 0, 8, or -8; then go to the next mode.
P:1EBD6:: Pass direction in [0F] to MoveObject.
P:1EBD8:: Link object index.
P:1EBE0-1EBE9:LevelSongIds
P:1EBEF:: Play the song for the level.
P:1EBF9:: We're stepping out of underground or cellar.\n\n\n If in UW, then go finish the mode.\n
P:1EBFD:: If the player stepped on stairs instead of an opening, then\n go finish the mode.\n
P:1EC03:: We're entering the OW room from a cave or dungeon.\n
P:1EC08:: TODO: ?
P:1EC0B:: Every 4 frames, move Link up 1 pixel.\n
P:1EC15:: MULTI: TargetY
P:1EC18:: If Link has reached the target position, go finish the mode.
P:1EC1B:UpdateMode5Play: While the flute timer has not expired, return.\n
P:1EC1F:: If brightening the room, then animate it.\n
P:1EC2C:: Check menu and pause.\n
P:1EC2E:: If the submenu is active, go update it.
P:1EC34:: If involuntarily paused, skip checking Select button here. But go do pause actions.
P:1EC36:: Not paused or paused voluntarily.\n Check Select button.\n
P:1EC3A:: If pressed Select,
P:1EC3C:: then toggle pause.
P:1EC42:: If not paused,
P:1EC44:: then enable sound.
P:1EC49:: If paused, then make sure to use NT 0,\n update hearts and rupees, and return.\n
P:1EC4B:: If not paused, go update the submenu or world.
P:1EC58:: Not paused.\n
P:1EC5B:: Save current direction from input buttons.
P:1EC64:: If not in the submenu, go check Start or update the world.
P:1EC66:: In submenu.\n
P:1EC71:: Not in submenu.\n
P:1EC75:: If Start not pressed, go update the world.
P:1EC77:: Else set menu state 1 to start scrolling.
P:1EC7A:BeginUpdateWorld: If we have the clock, then\n force the player's invincibility.
P:1EC88:: Update the player.\n
P:1EC8D:: If not updating anymore,
P:1EC8F:: then we changed the mode, so don't update anything else.
P:1EC92:: If Link can be chased, then set his coordinates as the target.\n
P:1EC9E:: Update weapons and items.\n
P:1ECBC:: If it's not time to change the chase target, then\n skip this and go update objects.\n\n\n TODO: name
P:1ECC0:: Set the chase long-timer to a random value between 0 and 7.\n
P:1ECC6:: Switch the flag indicating whether Link is the target.\n If the value is 0 (Link *is* the target), then\n skip this and go update objects.\n
P:1ECCE:: If Link's X has not changed since the last frame\n (when Link was the target), then XOR the chase target\n coordinates (which were Link's coordinates last frame).\n\n This ends up reflecting Link's coordinates across the room;\n so that monsters chase away from him.\n\n But if Link's X has changed since the last frame, then\n leave the chase target coordinates with his old coordinates.\n
P:1ECDE:: Update objects from $B to 1.\n
P:1ECEF:: TODO:\n If the object is autonomous and not checking collisions itself,\n then see about checking collisions and drawing on its behalf.\n\n Else go loop again.\n
P:1ECFA:: TODO: Self checks collisions and draws
P:1ECFE:: TODO:\n If attribute = 0, then it indicates not to skip drawing. So, animate and draw.\n
P:1ED01:: TODO: Skip drawing or self-draw?
P:1ED08:: Either way, we'll check collisions.\n
P:1ED0E:: Bottom of the object update loop.\n
P:1ED13:: Set the current object slot to what it should be when we\n begin updating objects again next frame: $B\n the last object slot for monsters and tile objects\n\n Before the first frame of mode 5, the current object slot variable\n was set to $B in 05:87B9 (InitMode_EnterRoom).\n\n TODO:\n Can you call this the last slot for dynamically allocated objects?\n
P:1ED18:: If full hearts = 0, then only a partial heart is left.\n So, turn on the "heart warning".\n
P:1ED27:: If in UW, check statues, doors, secrets, and the power triforce.\n
P:1ED30:: Update statues.
P:1ED49:: Check triforce fanfare.
P:1ED4F:: In OW.\n If game mode = 5, turn on sea sound effect if the room's\n attributes call for it.\n
P:1ED5A:: Sea sound effect
P:1ED62:: In OW, make a zora, if applicable.\n
P:1ED67:: Check zora.
P:1ED6A:: If there are tiles or palettes in the dynamic transfer buf, then\n do not handle the status bar map trigger.\n
P:1ED6F:: Transfer the level's status bar map, if we got the signal.\n
P:1ED79:: Cue the transfer of the level's status bar map.
P:1ED7D:: These actions are done after Link is updated, regardless\n of whether other objects were updated.\n
P:1ED89:UpdateHeartsAndRupees
P:1EDA0:UpdatePlayer
P:1EDA5:: If Link is halted, then return.\n
P:1EDAD:: TODO:\n\n If Link is paralyzed (by a like-like), then\n reset input direction.\n\n As far as I can tell, ObjInputDir could have been set to 0,\n instead of masking with $F0 for the same effect.\n
P:1EDC5:Link_EndMoveAndAnimateInRoom
P:1EDC9:: If in mode $A, then return.
P:1EDD0:: If in UW, then show link behind doors.
P:1EDD7:EnsureObjectAligned: Params:\n X: 0\n\n Ensure that, if grid offset = 0, then X is a multiple of 8,\n and Y is (multiple of 8) OR 5. For example, ($30, $7D) or ($58, $B5).\n
P:1EDEB-1EDF3:WalkableTiles
P:1EDF4:GetCollidableTileStill: Params:\n X: object index\n\n Returns:\n A: tile\n [049E][X]: tile\n
P:1EDFA:GetCollidingTileMoving: Params:\n X: object index\n [0F]: direction\n\n Returns:\n A: tile\n [049E][X]: tile\n\n\n Use -8 ($F8) for the hotspot offset, if it's Link.
P:1EDFE:: If it's not Link,
P:1EE00:: then use -$10 ($F0) for the hotspot offset.
P:1EE02:: If direction is up, left, or 0,\n then use the offset we determined above.
P:1EE08:: Else if it's down,\n then use offset 8.
P:1EE0E:: For right, use offset $10.\n
P:1EE10:GetCollidableTile: Params:\n X: object index\n Y: offset from hotspot\n [0F]: direction or 0\n\n Returns:\n A: tile\n [049E][X]: tile\n
P:1EE12:: Start with a Y coordinate $B pixels down from top of object.
P:1EE18:: Save this first adjusted Y coordinate.
P:1EE1D:: If direction is horizontal or 0, go adjust X coordinate.
P:1EE1F:: If direction is down and Y coordinate < $DD,
P:1EE27:: then pop Y coordinate,
P:1EE28:: and add [04] offset from hotspot.
P:1EE2B:: Save adjusted Y coordinate.
P:1EE2C:: Take the X coordinate as is.\n
P:1EE31:: Adjust the X coordinate.\n
P:1EE33:: If direction is left and X coordinate >= $10\n or direction is right and X coordinate < $F0,
P:1EE43:: then add [04] offset from hotspot.
P:1EE49:: Mask to make X coordinate a multiple of 8, the column size.
P:1EE4B:: Divide this multiple by 4 to get the offset of the 2-byte address.\n
P:1EE4E:: Put the address of the column in [00:01].
P:1EE58:: Restore adjusted Y coordinate.
P:1EE59:: Subtract status bar height $40 from Y coordinate.
P:1EE5C:: Divide Y coordinate by 8 to get the row it sits inside.
P:1EE60:: Get the tile at this column and row.
P:1EE62:: Store the tile in the object's tile slot.
P:1EE69:: If direction in [0F] is horizontal or 0, skip checking another column.
P:1EE6B:: The direction in [0F] is vertical. Check the tile in the next column.\n It might be a blocking tile. Blocking tiles are arranged after\n walkable tiles.\n
P:1EE75:: If second tile number >= first tile number,
P:1EE77:: Use the second one, because it might be blocking.
P:1EE7A:: Get the tile to return, if needed.
P:1EE7F:: If in UW, then return.
P:1EE81:: Look for the tile in a list of walkable tiles. If it's found,\n then turn it into $26 to simplify walkability tests.
P:1EE87:: If the tile wasn't found, quit the loop.
P:1EE8C:: If the tile doesn't match this element, go check the next one.
P:1EE8E:: The tile was found in the list. Substitute $26 for it.\n
P:1EE95:: If the object is not Link, then return without changing anything else.
P:1EE9B:: If not in special OW room $1F, return. There's a false wall.
P:1EEA1:: If direction is horizontal or 0, then return.
P:1EEA3:: If Link is at X=$80, Y<$56; then set the tile to walkable tile $26.\n
P:1EEB8:Obj_Shove: If this is not the first call to this routine for this instance of shoving (high bit is clear),\n then go handle it separately.\n
P:1EEBD:: Clear the high bit, so we don't repeat this initialization.\n
P:1EEC0:: If the object faces horizontally, go check which axis shove\n direction is on.\n
P:1EEC6:: The object faces vertically.\n\n If the shove direction is vertical, return. We're OK to shove.\n
P:1EECA:: Allow a perpendicular shove, if grid offset = 0.\n
P:1EECF:: Else change the shove direction.\n\n If the object is not Link, then reset it.\n
P:1EED3:: If it's Link, then shove in the opposite direction that he's facing.\n
P:1EEDB:: If shove direction is horizontal, return. We're OK to shove.\n Else go check the object's grid offset.\n
P:1EEE0:: If shove distance hasn't gone down to 0, go move some more.\n Else reset shove info.\n
P:1EEE4:_ResetShoveInfo: Returns:\n A: 0\n
P:1EEE6:_SetShoveInfo: TODO:\n\n Params:\n A: \n\n Returns:\n A: 0\n
P:1EEEB:: Try to move 4 pixels. [03] is the counter.\n
P:1EEEF:: If the object's grid offset = 0, make sure it's aligned to the grid.\n Then, stop shoving if the object hits a tile.\n
P:1EF05:: Regardless of the grid offset, if the object runs into the\n bounds of the room, then stop shoving.\n
P:1EF0E:: If there is a grumble moblin or person in the room (regardless\n of which object is being shoved), then see if it's blocked by\n the person. Stop shoving if it is blocked.\n
P:1EF24:: If the direction is right or down, store 1 in [02], else -1.\n This is the amount to change the relevant coordinate by.\n
P:1EF30:: We're OK to change the position. So, decrease the distance\n that's left to move.\n
P:1EF32:: Change the grid offset by the amount in [02] (1, -1).\n
P:1EF3B:: If grid offset is a multiple of $10, or the object is Link and grid offset\n is a multiple of 8, then reset grid offset.\n
P:1EF4A:: If the direction is horizontal, add the amount in [02] to X.\n
P:1EF5A:: Else add the amount to Y coordinate.\n
P:1EF61:: Loop again if [03] is not going down to 0.\n
P:1EF66-1EF70:FluteRoomSecretsOW
P:1EF71:WieldFlute: Play the flute's tune.\n
P:1EF76:: Set the flute timer for $98 frames.\n
P:1EF7A:: In UW, go flag that we used the flute, and return.\n
P:1EF7E:: If not in mode 5, return.\n
P:1EF84:: Get and save the quest number.\n
P:1EF8A:: Look for the current room in this list of $A that have a flute secret.\n
P:1EF98:: Found.\n\n If it was the first room in the list, handle it specially.\n This room is the only one in Q1 with a flute secret. It's also\n the only one in the list without a flute secret in Q2.\n\n In Q2, go summon the whirlwind. In Q1, continue to reveal\n the secret.\n
P:1EFA1:: For other rooms in the list:\n In Q1, go summon the whirlwind. In Q2, continue to reveal\n the secret.\n
P:1EFA4:: If the cycle of colors is complete or in progress, then return. The secret is already revealed.\n
P:1EFA9:: TODO:\n Look for an empty slot from 8 to 0 (?!).\n\n TODO:\n Does it ever get to 0? Would it work? Would an object in that\n slot be updated?\n
P:1EFB3:: If we find one, set up a flute secret object there.\n It will handle the rest.\n
P:1EFB9:: Not found.\n\n\n Pop and throw away the quest number.\n
P:1EFBA:: Summon the whirlwind.\n
P:1EFC2:: Restore the bank at the beginning of the routine.
P:1EFC7:: Flag that we used the flute.\n
P:1EFD0:Walker_Move: If the object is being shoved, then go shove it.\n
P:1EFD7:: Summary: Choose object direction or input direction for movement as appropriate.\n\n Player: If there's input, then use input direction when grid offset = 0,\n         or object direction when <> 0.\n\n Other objects: Move in input direction, unless stunned or magic clock is active.\n\n if slot = 0 and grid offset <> 0 then\n   if input dir = 0 then\n     use 0\n   else\n     use object direction\n else\n   if slot <> 0 and (has clock or stunned) then\n     return\n   else\n     if input dir = 0\n       use 0\n     else\n       use input direction\n
P:1EFF9:: Use this to take only one input direction, in case there are 2 (diagonal).
P:1F001:: Mask off everything but directions.\n (I don't think there's anything else)\n
P:1F005:: [0F] holds the movement direction.
P:1F007:: [0E]: $FF, if blocked by a door\n       else will hold the reverse index of the direction of a doorway if found\n 
P:1F00B:: If object is Link and using or catching an item then\n reset movement direction.\n
P:1F01B:: [0F] movement direction
P:1F01D:: If object is not Link, then skip the code below.\n
P:1F021:: Check if tile objects block the player.\n
P:1F029:: Check whether a person blocks the player.\n\n TODO:\n Is the first object grumble moblin or one of 8 people?\n
P:1F02C:: Grumble moblin
P:1F030:: Person1
P:1F034:: Person8
P:1F03B:: If in a doorway, then go check doorways instead of subrooms.\n
P:1F03F:: Check subrooms (caves and cellars) in modes 9, $B, $C.\n
P:1F055:: If game mode = 9, or in OW, or in a doorway, then skip\n checking room boundaries.\n
P:1F063:: This code applies to all objects.\n\n Prevents movement outside the walls or border of a room,\n even Link in front of a doorway.\n
P:1F066:: If object is Link, and level is in UW, and mode <> 9,\n then check doorways.\n
P:1F07C:: Restore Link's object index.
P:1F07E:: This code applies to all objects.\n
P:1F081:: The player will check for the ladder.\n
P:1F08A:: CheckLadder
P:1F08D:MoveObject: Params:\n X: object index\n [0F]: direction\n\n\n Positive limit is 8 for Link.
P:1F08F:: Negative limit is -8 for Link.
P:1F093:: If the object isn't Link,
P:1F095:: then use $10 and -$10.
P:1F099:: Store the limits that we determined.
P:1F0A1:: If direction is none, then return.
P:1F0A3:: To allow a wide speed range, we keep the quarter speed.\n Here, apply it 4 times to get the full speed.
P:1F0AC:ApplyQSpeedToPosition: Check the direction variable for each direction bit.
P:1F0B7:: Up\n
P:1F0C1:: Down\n
P:1F0CB:: Right\n
P:1F0D5:: Left\n
P:1F0DF-1F0E2:PlayerScreenEdgeBounds:Up, down, left, right.\n
P:1F0E3:Walker_CheckTileCollision: Params:\n [0E]: $FF, if blocked by a door\n [0F]: movement direction\n\n Returns:\n [0F]: untouched, or changed if blocked or need to change\n\n Summary:\n\n For the player: if at a doorway or walkable tile, check the screen edge.\n Then allow movement or go to the next room. Otherwise,\n check passive tile objects and stop moving.\n\n For other objects: First, if moving, test the colliding tile for\n walkability. Otherwise search for a walkable direction starting\n from input direction.\n\n When you find a walkable direction, see if it makes the object\n cross a boundary. If it doesn't, then make this direction\n the objection direction. Otherwise, keep looping.\n\n If no walkable direction is found, then stop moving.\n\n\n if is player\n   if at doorway\n     go handle a walkable direction\n   if blocked by door\n     return\n
P:1F0F2:: If grid offset <> 0, return.\n
P:1F0F7:: Grid offset = 0.\n The object is at a point between cells in the grid.\n So, we can check tiles for collision.\n\n Reset [0E] alternate direction search step.\n
P:1F0F9:: If there's a movement direction, go check tile collision.\n
P:1F0FD:: Moving direction = 0.\n If object is the player, return.\n
P:1F101:: Moving direction = 0.\n The object is not the player.\n\n If object does not have attribute $10, then\n set movement direction to input direction,\n and go try to turn to an unblocked direction in order to move.\n
P:1F104:: TODO: Unknown object attribute
P:1F110:: TODO:\n This seems to be unused code triggered by object attribute $10.\n But $10 is not used in the object attribute array at 07:FAEF.\n
P:1F116:: The code below applies to Link and other objects.\n\n Test the moving direction's walkability.\n\n For the player, this is enough. For other objects, this \n becomes a loop looking for an unblocked direction to move in.\n\n If the colliding tile is walkable, go handle a walkable direction.\n
P:1F11E:: The colliding tile is unwalkable.\n\n If object is the player, then go check passive tile objects and\n the screen edge, or stop moving.\n
P:1F122:: Not the player.\n If object attribute has $10, go to the unused code.\n
P:1F129:: Get the next direction to check, and set moving direction to it.\n If not at the end of the loop, go test the new direction's walkability.\n
P:1F12C:: Set new moving direction, or 0 at the end of the loop.
P:1F133:: Tile is not walkable. Object is player.\n\n Check passive tile objects and the screen edge, and stop moving.\n\n First, if in OW, check passive tile objects (armos and regular gravestone).\n
P:1F13F:: Reset moving direction and buttons pressed.\n If in UW, we're done.\n In OW, go check the screen edge.\n
P:1F149:ResetMovingDir: Returns:\n A: 0\n [0F]: 0\n
P:1F14E:: If object is not Link, then the tile is walkable. Go see if this direction\n makes the object cross a boundary. Then go check another direction if it does,\n or else make this the object direction.\n
P:1F152:: The object is Link. We end up here regardless of walkability.\n\n If not in mode 5 or ladder is in use, return.\n
P:1F15C:: If grid offset <> 0, return.\n
P:1F161:CheckScreenEdge
P:1F163:: If not moving, then return.\n
P:1F168:: If the single moving direction is vertical, use Y.\n Else use X coordinate.\n\n\n Call this to get a single moving direction.
P:1F176:: If Link's coordinate does not match the screen edge coordinate\n in the single moving direction, then return.\n
P:1F17D:: We're moving to the next screen.\n Make sure Link faces the single moving direction.\n
P:1F182:GoToNextModeFromPlay: Returns:\n X: 0 (Link's object slot)\n
P:1F198:: If object crossed a boundary, then go check object\n attribute $10 and another direction.\n Else set object direction to moving direction [0F] and return.\n
P:1F1A0:Walker_GetNextAltDir: Description:\n Calculates the next alternate direction to move in while\n searching for an unblocked direction.\n\n Params:\n [0E]: the current step\n\n Returns:\n A: a direction for the current step, or 0 at the end of the loop\n [0E]: the next step, or 0 to end the loop\n ObjDir: might be modified\n
P:1F1AF:Walker_AltDir_GetRandomObjPerpendicularDir
P:1F1C3:Walker_AltDir_GetMovingOppositeDir
P:1F1D0:ReverseObjDir: Note:\n Also reverses movement direction in [0F].\n
P:1F1DA:Walker_AltDir_EndLoop
P:1F1DF:_FaceUnblockedDir: Description:\n Search for an unblocked direction. Set facing direction to it,\n if one is found.\n\n If not at a square boundary, then return.\n
P:1F1E4:: Else reset [0E] to start the search for an unblocked direction.\n
P:1F1E9:: Set the moving direction [0F] to the direction returned.\n
P:1F1EB:: But quit if none was found.\n
P:1F1ED:: If blocked in this direction by a tile or the room boundary,\n then loop again.\n
P:1F1FA:: Set the facing direction to the one found.\n
P:1F1FD-1F200:LinkToLadderOffsetsX
P:1F201-1F204:LinkToLadderOffsetsY
P:1F205-1F208:LinkHeadTiles
P:1F209-1F20C:LinkHeadMagicShieldTiles
P:1F20D-1F212:LadderRoomsOW
P:1F213:Link_EndMoveAndAnimate_Bank4
P:1F21B:_Link_EndMoveAndDraw_Bank1
P:1F223:Link_EndMoveAndAnimate_Bank1
P:1F229:_Link_EndMoveAndDraw_Bank4
P:1F231:_Link_EndMoveAndDraw
P:1F238:Link_EndMoveAndAnimateBetweenRooms
P:1F23A:: If in UW, then return.
P:1F23C:Link_EndMoveAndAnimate: Switches bank:\n 5\n\n If teleporting by whirlwind, then return.\n
P:1F241:: If mode 4 or 6 (not a playing mode), then go check warps and animate.\n
P:1F24C:: If Link's grid offset = 0, go see whether we need to wield the ladder.\n If Link's grid offset is not a multiple of 8, go check warps and animate.\n
P:1F258:: Grid offset is a multiple of 8. So set it to 0.\n If not in mode 5, go check warps and animate.\n
P:1F263:: Grid offset was a multiple of 8. So, we've stepped a whole tile,\n and need to reset the subroom indicator.\n\n That way, we know not to go into a subroom that we just came out of.\n
P:1F265:: If not in mode 5, go check warps and animate.\n
P:1F26B:: If in OW and we're not in this list of 6 rooms, go check warps and animate.\n
P:1F27D:: If in a doorway or missing the ladder, go check warps and animate.\n
P:1F286:: If Link is halted or using the ladder, go check warps and animate.\n
P:1F292:: Get the colliding tile in moving direction.\n
P:1F29B:: If in OW and tile is water (< $8D or >= $99), then\n go check warps and animate.\n If in UW, and tile = $F4, go check warps and animate.\n
P:1F2AD:: Look for an empty monster slot.\n If none found, or input dir = 0, or input direction <> facing direction,\n then go check warps and animate.\n
P:1F2BD:: X register now holds the ladder's slot.\n Set ladder slot to empty slot found.\n Set ladder's direction to input direction.\n
P:1F2C1:: Add appropriate offset to player's position to set the ladder's position.\n\n\n Call this for the reverse direction index.
P:1F2D4:: Set the ladder object's type. Reset shove params and invincibility timer.\n\n\n Ladder
P:1F2DF:: Set the initial state of the ladder.\n
P:1F2E3:: If in mode 5, check warps.\n\n\n Set X to 0 to refer to Link object.
P:1F2EB:: Save the last collided tile.
P:1F2F7:: Set X to 0 to refer to Link object.
P:1F2FA:: Restore the last collided tile.
P:1F2FD:: Animate Link.\n
P:1F304:: If in mode 9, go draw Link 2 pixels down.
P:1F306:: In OW, draw Link 2 pixels down.
P:1F30E:: Now change Link's look for specific states and items.\n\n If Link is attacking or using an item,\n then add 4 to frame to use the "attack/use item" frames.
P:1F31F:: Now frame is in A.
P:1F320:: Use Link's animation.
P:1F325:: See if there's special processing needed for the shield.\n
P:1F32A:: No magic shield.\n
P:1F32E:: If not facing down, then return.
P:1F330:: Get the sprite's tile.
P:1F335:: The tiles for shieldless Link are 8 and $A.
P:1F337:: If it already has a shield, then return.
P:1F339:: Save the sprite's original tile.
P:1F33B:: Add $50 to change 8 to $58 for one frame, and $A to $5A for the other frame.
P:1F33D:: Go apply the change.
P:1F340:: Magic shield.\n\n\n Look at the left tile.
P:1F345:: If facing right,
P:1F347:: then look at the right tile instead.
P:1F34B:: Get the sprite's tile.
P:1F34E:: Save the sprite's original tile.
P:1F34F:: Compare the sprite's tile with 4 tiles: 1 for each direction.\n
P:1F350:: Quit the loop if we haven't found it.
P:1F355:: If it didn't match, go check the next one.
P:1F357:: Get the replacement tile.
P:1F35A:: Apply the sprite's modification for the shield.\n
P:1F35D:: Restore the sprite's original tile to A.
P:1F360:: If it's not a down facing tile, then return. No attributes to change.
P:1F362:: It's a down facing tile. Make sure it's not flipped,\n because there's only 1 frame of downward shield tile.
P:1F36B-1F36E:SwordShotSpreadBaseAttr: Sprite attributes that flip each corner of the spread shot\n differently: H, H-V, V, 0\n
P:1F36F:UpdateSwordShotOrMagicShot: If the shot is not active, return.\n
P:1F373:: If low bit is set, go handle shot spreading out.\n
P:1F379:: Move the shot.\n
P:1F383:: If movement was blocked, go handle the situation.\n
P:1F387:: If grid offset is a multiple of 8, reset it.\n
P:1F391:DrawSwordShotOrMagicShot: Prepare the sprite position.\n
P:1F394:: If the direction is horizontal, move the sprites down 3 pixels.\n
P:1F3A3:: Set the sprite attributes to (base attribute OR (frame counter AND 3)).\n This makes the shot flash by cycling all the palettes, one each frame.\n\n\n Call this only to get reverse direction index.
P:1F3B0:: Set [0C] to the correct frame for the direction: horizontal or vertical.\n
P:1F3B5:: If the direction is left, flip the right facing image by setting [0F] to 1.\n
P:1F3BB:: If this a monster's shot, choose the item slot for drawing based on object type.\n   $57 (sword shot) => $22\n   other (presumably $58 or $59, magic shot) => $23\n
P:1F3CA:: But if the player shot it, the choice depends on the shot's state.\n   high bit set (magic)   => $23\n   high bit clear (sword) => $22\n
P:1F3D4:HandleShotBlocked: Params:\n X: shot object index\n\n If the object is a sword shot, go spread out the shot.\n
P:1F3D9:: This is a magic shot.\n\n If missing the magic book, go deactivate the shot object.\n
P:1F3DE:: Try to activate a fire object. Temporarily mark the candle\n unused, so it only has to depend on having an empty slot.\n\n If successful, Link's state will have been changed to "using item".\n But we don't want that in this case.\n\n For both these reasons, save state and restore it afterward.\n
P:1F3F4:: State $21 means that a moving fire was just made.\n\n If it's any another value, then we didn't find an empty slot\n to make a fire. In this case, all that's left to do is to go\n deactivate the shot object.\n
P:1F3FA:: Make state $22 for a standing fire.\n
P:1F3FC:: Copy the shot's position and direction to the fire.\n
P:1F40D:: The fire lasts $4F frames.\n Deactivate the shot.\n
P:1F416:: MULTI: ObjDir -> ObjSwordShotNegativeOffset\n\n Set the state to spreading out (low bit is set).\n\n Set [98][X] to base negative offset -2. This is how far the left\n corners will be shown relative to the center point at object X, Y.\n The right corners will be shown 2 pixels in the opposite direction\n of the center point.\n
P:1F41D:: MULTI: ObjDir -> ObjSwordShotNegativeOffset\n\n The shot is spreading out.\n\n Copy base negative offset in [98][X] to [02] and [03].\n These will be negated appropriately for each corner.\n
P:1F423:: Reset [0F] to not flip horizontally.\n
P:1F427:: Loop 4 times to draw each corner of the spreading sword shot.\n The corners are: top-left, bottom-left, bottom-right, top-right\n
P:1F429:: Save the loop index.
P:1F42B:: Save offset X [02] and Y offset [03].\n
P:1F431:: Calculate and set sprite attributes for this corner:\n   base attribute OR (frame counter AND 3)\n\n The base attribute defines how to flip the sprite.\n The frame counter makes the shot flash by cycling each\n palette row.\n
P:1F43B:: Add the object's X (the center of the spread) and the\n current offset in [02] to set sprite X in [00].\n
P:1F442:: If sprite X >= object X and sprite X >= $FC, skip this corner.\n Else calculate the distance from object X to sprite X.\n
P:1F455:: If distance >= $20, skip this corner.\n
P:1F459:: Add the object's Y (the center of the spread) and the\n current offset in [03] to set sprite Y in [01].\n
P:1F460:: If in UW, and (sprite Y < $3E or >= $E8), then skip this corner.\n
P:1F46C:: Draw the corner.\n Pass [0C] = frame 2 (spread shot), Y = $23 (sword 2).\n
P:1F475:: Prepare to process the next corner.\n\n First, restore X offset [02] and Y offset [03].\n
P:1F47B:: Take turns negating X offset or Y offset for the next round.\n - First turn:  loop index = 3, negate Y offset [03]\n - Second turn: loop index = 2, negate X offset [02]\n - Third turn:  loop index = 1, negate Y offset [03]\n - Fourth turn: doesn't matter\n\n\n Get the loop index.
P:1F47E:: The first two loop indexes coincide with offset from address 0.
P:1F480:: But for loop index 1,
P:1F482:: make the offset 3 to negate the Y offset.
P:1F48F:: Restore the loop index, decrement it, and loop again if >= 0.\n
P:1F494:: MULTI: ObjDir -> ObjSwordShotNegativeOffset\n\n Decrease the base negative offset to get farther away from\n the center point.\n
P:1F496:: MULTI: ObjDir -> ObjSwordShotNegativeOffset\n\n Once the base negative offset reaches $E8, go deactivate the object.\n
P:1F4A0:UpdateBoomerangOrFood: If state = 0, then not active. So, return.\n
P:1F4A4:: If the high bit of state is clear, then go update the boomerang.\n
P:1F4A7:: The object is food.\n\n Once the timer has expired, increment the state and set timer to $FF.\n If we reach state $83, then go deactivate the object.\n\n Nothing changes between the states. So, they are used as\n a way to extend the timer. $2FD screen frames in total.\n
P:1F4B9:: If the template object type in the room is one of:\n moblin, goriya, octorock, vire, keese\n then attract these monsters to the food.\n\n They will chase the food instead of Link when given a chance.\n
P:1F4BC:: Blue moblin
P:1F4C0:: Red darknut
P:1F4C4:: Vire
P:1F4C8:: Blue keese
P:1F4CC:: Red keese
P:1F4D8:: Draw the food.\n
P:1F4DB:: Red sprite palette
P:1F4DD:: Food item slot
P:1F4E5-1F4EC:BoomerangFrameCycle
P:1F4EE-1F4F5:BoomerangBaseSpriteAttrCycle
P:1F4F7-1F4FF:BoomerangQSpeedFracsY
P:1F500-1F508:BoomerangQSpeedFracsX
P:1F509-1F50C:RDirectionToWeaponFrame
P:1F50D-1F510:RDirectionToWeaponBaseAttribute: The base sprite attribute for weapon sprites, 1 for each\n direction in reverse direction order: up, down, left, right\n\n All of them are 0, except for the element for "down".\n That one flips the vertical sword or rod image so that it points down.\n
P:1F511-1F514:RDirectionToOffsetsX
P:1F515-1F518:RDirectionToOffsetsY
P:1F519:UpdateArrowOrBoomerang: If not active (state = 0), then return.\n
P:1F51D:: TODO: _GetDirectionsAndDistancesToTarget\n Reset [00], which will hold the number of axes where the distance <= 8\n when calculating the angle to return to thrower.\n See states $40 and $50 and _GetDirectionsAndDistancesToTarget.\n
P:1F521:: If not in major state $10, go check other states.\n
P:1F52C:: State $1x. Fly away from the thrower.\n\n Reset [0E], which will indicate:\n - into MoveShot:   0 update grid offset, else don't\n - out of MoveShot: $80 if blocked\n
P:1F530:: If the object's direction has a horizontal component, then\n move it horizontally.\n
P:1F539:: If MoveShot were called again, then don't update grid offset.
P:1F53B:: If the object was blocked, go handle it.\n
P:1F540:: If the object's direction has a vertical component, then\n move it vertically.\n
P:1F549:: If the object was blocked, go handle it.\n
P:1F54E:: If the object is an arrow (Link's or a monster's), go set up sprite parameters.\n
P:1F55D:: For boomerangs, get the absolute value of the weapon's grid offset:\n the distance traveled.\n
P:1F567:: For boomerangs, compare it to the movement limit.\n If it reached the limit, set state $20 and a new movement\n limit of $10, and go handle the rest as if blocked.\n State $20 will become $30 below in HandleArrowOrBoomerangBlocked.\n\n Otherwise, only animate and check collision as usual.\n\n In major state $30, ObjMovingLimit is a timer to change the state to $40.\n
P:1F57B:DrawArrow: This is an arrow. Set up sprite parameters.\n\n If facing left, set horizontal flipping in [0F].\n
P:1F587:: Get the reverse direction index that the weapon is facing.
P:1F58A:: Store the weapon's frame (up or right) in [0C].\n
P:1F58F:: Store the base sprite attribute in [04].\n
P:1F594:: If this is a monster's arrow, add 2 to sprite attributes in [04].\n This chooses palette row 6.\n\n Otherwise, add the arrow item value less 1. This chooses\n palette row 4 if the arrow is wooden, otherwise 5 for silver.\n
P:1F5AF:: Copy the attribute to [05], and go draw.\n
P:1F5B6:: If major state <> $20, go check other states.\n
P:1F5BA:: State $2x. Spark.\n\n Change the state to $28, and decrement animation counter.\n If it hasn't reached 0, then go draw and check for collision\n (with Link, if this is a monster's boomerang).\n\n TODO: Why state $28?\n I thought that it was set to $28, so that the animation frame cycle will\n start over again when spinning.\n But when animation counter reaches 0, state will be set to $40.\n If the counter hasn't reached 0, then I don't *think* that\n any drawing code depends on the minor state.\n
P:1F5C3:: Animation counter = 0.\n\n Set state to $40. It will become $50 below in\n HandleArrowOrBoomerangBlocked.\n
P:1F5C7:: If this is an arrow (monster's or player's), then deactivate it.\n Else go handle the boomerang being blocked.\n
P:1F5D9:: If it's a monster's arrow, then destroy it in the monster slot,\n including clearing object type.\n
P:1F5E1:HandleArrowOrBoomerangBlocked: Use animation counter to count down 3 screen frames in case the state is $20 (spark).\n
P:1F5E6:: Add $10 to the state to make it $2x.\n
P:1F5ED:: If the weapon is a boomerang (not a monster arrow nor player arrow),\n then go draw it and check for a collision.\n
P:1F5FF:: Start preparing to draw an arrow.\n\n Set arrow slot frame 2 (spark) in [0C],\n and no horizontal flipping in [0F].\n
P:1F607:: Get reverse index of weapon's direction, and base sprite attribute 0,\n and go draw.\n
P:1F611:: If major state <> $30, go check other states.\n
P:1F615:: State $3x. Slow down.\n\n Reset grid offset for movement.\n
P:1F61A:: Go slow at q-speed fraction $40 (1 pixel a frame).\n
P:1F61F:: If facing left and X < 2, then go change state to $40. The\n boomerang is too close to the left edge of the screen.\n Another move might make it wrap around.\n
P:1F62D:: Move the boomerang.\n
P:1F630:: Decrement timer ObjMovingLimit. Once it reaches 0, change\n state to $40.\n
P:1F635:: Set state $40, and a time to move of $20 frames.\n\n In major state $40, ObjMovingLimit is a timer to change the state to $50.\n\n Also, animate, draw, and handle any collision (with Link, if a monster's boomerang).\n
P:1F641:: State $40 or $50. Return to thrower: $40 slow, $50 fast.\n\n The boomerang will now return. Reset the grid offset.\n
P:1F646:: Get the horizontal and vertical directions and distances to the thrower.\n
P:1F64A:: Monster thrower object index
P:1F650:: If the boomerang hasn't reached the thrower ([00] < 2),\n then go move towards the thrower, draw, and check collisions.\n
P:1F656:: The boomerang has reached the thrower.\n\n Reset the distance to move.\n If this is a monster's boomerang, go handle the monster catching it.\n
P:1F65F:: Link has caught the boomerang.\n\n Combine Link's state with $20 for having caught the boomerang.\n\n If Link catches it some time after throwing it,\n his state will become $20, and he will show the catch animation.\n\n But if he catches it right after throwing it, the state becomes\n $30 ($10 OR $20), which is the end state of using an item.\n
P:1F665:: Make to set Link's animation counter to 1, so that he picks\n up the new state.\n
P:1F66A:: Deactivate the boomerang.\n
P:1F672:: A monster caught the boomerang that it threw.\n\n Set a timer for the thrower based on a random value:\n < $30: $30\n < $70: $50\n Else:  $70\n
P:1F689:: Reset the thrower's state to make it idle or restart its state machine.\n Destroy the monster's boomerang.\n
P:1F691:: Move towards the thrower.\n\n Middle speed index 4 goes equally fast in X and Y axes.\n
P:1F696:: Move vertically towards the thrower.\n
P:1F69C:: [0A] vertical direction
P:1F6A2:: Save speed index.
P:1F6A7:: Move horizontally towards the thrower.\n
P:1F6A8:: Restore speed index.
P:1F6AF:: [0B] horizontal direction
P:1F6B8:AnimateBoomerangAndCheckCollision: TODO: is the sound effect part right?\n\n Decrement animation counter; and when it reaches 0:\n 1. arm it again for 2 frames\n 2. advance the minor state within a cycle of 8\n 3. see if it's time to play the sound effect, if the boomerang belongs to Link\n
P:1F6CE:: TODO: ?
P:1F6D0:: TODO: is this right?
P:1F6D3:DrawBoomerangAndCheckCollision: If the boomerang belongs to a monster, then check for\n collision with Link.\n\n If they collide, then set state $20 and animation counter 3.\n
P:1F6E8:: The minor state (low 3 bits of state) is used to\n set the right frame in [0C] for this point in the spinning cycle.\n\n Reset [00] and [01]. These are the offsets for boomerang's position.\n In other words, don't offset the coordinate below.\n
P:1F6FA:: Store the base sprite attribute for this point in the cycle in [04].\n
P:1F700:: TODO: ?\n If base sprite attribute in [04] = 8, then leave [04] as it is.\n Else add the item value of the magic boomerang.\n\n But none of the values in the base sprite attributes array is 8.\n\n As far I can tell, the magic boomerang's item value (0 or 1) in\n the inventory will always be added to the base sprite attribute.\n\n So, palette row 4 or 5 will be chosen.\n
P:1F70F:: Boomerang item slot
P:1F714:_DrawArrow: Params:\n Y: reverse direction index that the weapon is facing\n\n\n [00] and [01] will hold sprite X and Y.\n Begin with the horizontal and vertical offsets.\n
P:1F71E:: Arrow item slot
P:1F720:_DrawArrowOrBoomerang: Add the weapon's true coordinates to offsets in [00] and [01].\n
P:1F72E:: If state = $2x (spark), use palette row 5 to write sprites.\n Otherwise, use the sprite attributes we already calculated.\n
P:1F73E:UpdateRodOrArrow: The rod uses states $3x. Arrow uses $1x and $2x.\n
P:1F749-1F758:_PlayerToWeaponOffsetsX: 4 sets of horizontal offsets, one for each state of weapon.\n Each set contains 4 offsets in reverse direction index order:\n up, down, left, right\n\n These offsets are added to player X to get weapon X.\n
P:1F759-1F768:_PlayerToWeaponOffsetsY: 4 sets of vertical offsets, one for each state of weapon.\n Each set contains 4 offsets in reverse direction index order:\n up, down, left, right\n\n These offsets are added to player Y to get weapon Y.\n
P:1F769:UpdateSwordOrRod: If state = 0, the object is not active. So, return.\n
P:1F76F:: Decrement the state timer.\n If it hasn't expired, go move the sword or rod.\n
P:1F774:: State 2 will last 8 frames. The higher ones last 1.\n
P:1F780:: Set both the player's animation counter and the sword's\n animation counter/timer to this value.\n
P:1F786:: Go to the next state.\n
P:1F788:: Once we reach state 6, deactivate the object.\n Otherwise, go draw it.\n
P:1F794:: Reset horizontal flipping in [0F].\n
P:1F798:: If state = 5, return without drawing.\n
P:1F7A3:: Set [00] to (state - 1) * 4:\n the byte offset of the beginning of a set of pixel offsets.\n
P:1F7AB:: Set object's direction to player's. It might have changed\n since the last frame.\n
P:1F7AF:: Add [00] and the reverse index of the direction to get\n the byte offset of the pixel offset.\n
P:1F7B7:: Set object's X to player's X + offset for state and direction.\n Copy the result to [00].\n
P:1F7C1:: Set object's Y to player's Y + offset for state and direction.\n Copy the result to [01].\n
P:1F7CB:: If state = 1, use up direction.\n Else use object direction.\n
P:1F7D7:: Store the weapon's frame (horizontal or vertical)\n for the direction chosen above in [0C].\n
P:1F7DF:: Calculate sprite attributes.\n\n If the weapon is the rod, calculate its sprite attributes:\n   base attribute OR 1\n So, it uses palette row 5.\n
P:1F7EB:: The weapon is the sword.\n To calculate the sprite attributes: (item value - 1) + base attribute\n
P:1F7F2:: Set sprite attributes to the calculated value above.\n
P:1F7F5:: If the direction is left, set [0F] to flip horizontally.\n
P:1F7FB:: If state = 1, return. Don't show the weapon.\n
P:1F803:: Set Y to the right item slot to pass to the routine to write sprites:\n sword or rod\n\n\n Sword slot
P:1F809:: Rod slot
P:1F80E:: If state <> 3, return.\n
P:1F816:: State = 3. Time to instantiate a shot.\n\n If object slot is not the rod's, go instantiate the sword shot separately.\n
P:1F81A:: Instantiate a magic shot (rod shot).\n Switch to the shot slot $E.\n
P:1F81C:: If high bit of state is set, return. It's already active.\n
P:1F823:: Play "magic shot" tune.\n
P:1F828:: Activate the shot object (state $80).\n
P:1F831:: If the direction is horizontal, and X < $14 or >= $EC, then\n deactivate the shot object.\n
P:1F841:: If high bit of state is set, use $A0 else $C0 for the q-speed fraction.\n\n The high bit is set for magic shot, and reset for sword shot.\n
P:1F84E:: Set the shot object's grid offset the same as the player's.\n
P:1F855:_ResetObjState: Returns:\n A: 0\n\n If it's the room item, then deactivates it.\n
P:1F85A:: Try to activate a sword shot.\n\n Switch to shot slot $E.\n
P:1F85C:: If state <> 0, return. It's already activated.\n
P:1F860:: If [0529] is set, go activate a sword shot regardless of hearts.\n\n TODO: But is this used?\n
P:1F865:: If full hearts <> (heart containers - 1), return.\n
P:1F876:: If partial heart is less than half full, return.\n
P:1F87D:: TODO: sound effect?\n
P:1F882:: Go finish setting up a sword shot in initial state $10.\n
P:1F886:UpdateFire: If this is not a walking fire (state $21), skip moving it.\n
P:1F88C:: Move as if grid offset were 0.\n
P:1F89D:: Add grid offset after the move to the original.\n This makes it continuous, and useful as a distance traveled.\n
P:1F8A4:: If the absolute value of grid offset < $10, go draw.\n \n Once the absolute value of grid offset = $10,\n make the fire stand instead of move.\n Set state $22 and last $3F frames.\n
P:1F8B1:: Check a standing fire.\n\n If time has run out, deactivate the item and return.\n
P:1F8B5:: If in UW, update the candle to brighten the room if needed.\n
P:1F8C5:: Advance the animation counter, and draw.\n\n\n 4 frames in every animation cycle.
P:1F8D0:: A: frame 0
P:1F8D2:: [0C]: not mirrored
P:1F8D4:: Y: animation index $40 (but will use $41)
P:1F8D9:: Now check for a collision with the player.\n\n First, if the player is invincible, return.\n
P:1F8DE:: Save the object index in [00].\n
P:1F8E0:: Store the player's center point coordinates in [04] and [05].\n
P:1F8E7:: Store the fire's center point coordinates in [02] and [03].\n
P:1F8EE:: If the objects don't collide (< $E pixels in X and Y), then return.\n
P:1F8F9:: The player and the fire collide.\n\n Make the fire shove the player.\n
P:1F902:: Harm the player $80 points.\n
P:1F90D:GetWideObjectMiddle: Params:\n X: object index\n Y: offset from [02] and [03] to store center X and Y\n\n Returns:\n [02 + Y]: center X\n [03 + Y]: center Y\n
P:1F91D-1F921:BombTimes
P:1F922-1F925:BombableWallHotspotsX
P:1F926-1F929:BombableWallHotspotsY
P:1F92A:UpdateBombOrFire: If the object's not active, return.\n
P:1F92E:: Bomb major state = $10. Fire major state = $20.\n
P:1F937:: This is a bomb.\n\n If the timer has not expired, then go draw.\n
P:1F93B:: The timer has expired. Set another based on the minor state.\n Advance the state.\n
P:1F947:: TODO:\n If the minor state = 3, play the sound effect?\n
P:1F956:: If minor state = 5, then deactivate the bomb, and return.\n
P:1F960:: If minor state <> 4, go draw.\n
P:1F964:: Minor state = 4. Try to break a wall.\n\n If in OW, go draw. Rock walls have a tile object that checks for bombs.\n
P:1F968:: Bombs don't blast walls in cellars (mode 9). Go draw.\n
P:1F96E:: We're in UW. See if the bomb is near a bombable wall.\n
P:1F971:: If none is found, then go draw.
P:1F973:: If the bomb's X is not within $18 pixels of the hotspot, then\n go check the next hotspot.\n
P:1F980:: If the bomb's Y is not within $18 pixels of the hotspot, then\n go check the next hotspot.\n
P:1F98D:: Store in [02] the direction corresponding to the hotspot's index.\n
P:1F992:: If it was already opened or triggered, then go draw.\n
P:1F99A:: If it's not a bombable wall, go draw.\n
P:1F9A6:: Trigger this bombable wall to open.\n
P:1F9AE:: Draw the bomb or dust cloud.\n
P:1F9B4:: If minor state = 2, we drew a bomb. So, return.\n
P:1F9BC:: Otherwise, we drew one dust cloud. Go draw the others.\n
P:1F9BF:DrawBombOrCloud: Params:\n X: object index\n [00]: X\n [01]: Y\n
P:1F9C2:DrawBombOrCloudNoFlashing: Params:\n X: object index\n [00]: X\n [01]: Y\n\n\n Set frame image = minor state - 2.\n
P:1F9C9:DrawCloud: Params:\n A: frame image (1 to 3)\n X: object index\n [00]: X\n [01]: Y\n\n\n [0C] frame image
P:1F9CD:: [0F] no horizontal flipping
P:1F9CF:: Write sprites with blue sprite palette row and bomb item slot.\n
P:1F9D4:: Bomb item slot
P:1F9D9-1F9DB:BombCloudOffsetsY1
P:1F9DC-1F9DE:BombCloudOffsetsX1
P:1F9DF-1F9E1:BombCloudOffsetsY2
P:1F9E2-1F9E4:BombCloudOffsetsX2
P:1F9E5:: For each of 3 clouds, indexed by Y register:\n
P:1F9E7:: Save cloud index.
P:1F9E9:: Every other screen frame, add 6 to the index to point inside\n the second set of coordinates.\n
P:1F9F3:: Set [01] to cloud position (object Y + Y offset).\n
P:1F9FB:: Set [00] to cloud position (object X + X offset).\n
P:1FA03:: Draw the cloud at this position.\n
P:1FA06:: Restore cloud index.
P:1FA08:: Loop while >= 0.\n
P:1FA0C:_AnimateAndDrawMetaObject
P:1FA0F:: If the metastate >= $10, go animate and draw the death sparkle.\n
P:1FA16:: Animate and draw the spawning cloud.\n
P:1FA1B:_L_CheckMetaObjTimer: If the object's timer has expire, then go to the next metastate\n and last 6 frames.\n
P:1FA27:: If metastate = $10, then go incremenet metastate and set\n object timer without drawing.\n
P:1FA2B:: Set the frame image in [0C] (1, 0, 1) for the metastate.\n
P:1FA2F:: Normal sprite, palette 5 (blue)
P:1FA34:: Death spark
P:1FA3C:AnimateLinkBase: Returns:\n Y: animation frame\n [00]: object X\n [01]: object Y\n [0F]: flip horizontally\n
P:1FA3E:: If Link isn't idle, go animate object.
P:1FA44:: If in mode 4, go animate object.
P:1FA48:: If in mode $10, go animate object.
P:1FA4D:: If there was no direction input button, skip animating Link.
P:1FA4F:_AnimateObjectWalking: Params:\n X: object index\n\n Returns:\n Y: animation frame\n [00]: object X\n [01]: object Y\n [0F]: flip horizontal\n\n As the object walks, the animation counter rolls down.\n
P:1FA54:: Once the counter reaches 0, and if object is the player,\n animate Link's object state.\n
P:1FA5B:: Roll over the counter (6 frames).\n
P:1FA62:: Set up sprite position in the descriptors.\n
P:1FA65:: Set up horizontal flipping.\n
P:1FA6B:: Facing up or down.\n\n\n Assume animation frame 3 (up).
P:1FA71:: If down, then use animation frame 2 (down).
P:1FA72:_SetObjFlipHorizontalForSpriteDescriptor: Use the movement frame as the value for horizontal flipping.\n\n Params:\n X: object index\n\n Returns:\n [0F]: flip horizontal, based on ObjMovementFrame\n
P:1FA78:: Facing left or right.\n\n\n Assume animation frame 0 (legs apart).
P:1FA7F:: If walking frame 1, then animation frame 1 (legs together).
P:1FA86:: Facing left. Flip horizontally.
P:1FA89:Anim_AdvanceAnimCounterAndSetObjPosForSpriteDescriptor: Params:\n A: new value for animation counter, in case it rolls over\n X: object index\n\n Returns:\n A: 0\n [00]: X\n [01]: Y\n [0F]: 0 for no horizontal flipping\n
P:1FA93:Anim_FetchObjPosForSpriteDescriptor: Params:\n X: object index\n\n Returns:\n A: 0\n [00]: X\n [01]: Y\n [0F]: 0 for no horizontal flipping\n
P:1FA9B:: Don't flip horizontally
P:1FAA0:RollOverAnimCounter: Roll over the animation counter, and switch the movement frame.\n\n Params:\n [00]: new counter value\n
P:1FAAE:AnimateLinkObjState: If major state = $10\n   if minor state = 0, make it 1\n   else OR state with $30\n   go set movement frame to 1\n
P:1FABE:: If major state = $20\n   if minor state = 0, make it 1\n   else OR state with $30\n   go set movement frame to 1\n
P:1FAD3:: To animate the state, the animation counter had to have\n reached 0. Right after this routine, the counter will be\n rolled over, and the movement frame will be switched.\n\n So, set movement frame to 1 (legs together) at the end of\n the animation here, in order to immediately change it to\n 0 (legs apart) after this.\n
P:1FAD9:: If in state $30, then make Link idle, except for halting.\n
P:1FAEF-1FB4D:ObjectTypeToAttributes
P:1FB4E-1FB73:ObjectTypeToHpPairs
P:1FB74:UpdateObject: Params:\n A: object type\n
P:1FB7B:: If the object was initialized, go update it.\n
P:1FB7E:: [0F] holds the original value of "uninitialized" flag.
P:1FB82:: If the object type starts with a spawning cloud\n (type < $53, except armos and flying ghini),\n then set object timer to 7.\n\n But this will be overridden during initialization.\n
P:1FB85:: Armos
P:1FB89:: Flying Ghini
P:1FB8D:: Flying Rock
P:1FB95:: Flag the object initialized, and go initialize it.\n
P:1FB9D:: The object was already initialized.\n\n If meta-state <> 0, go update the meta-object\n (spawning cloud or dying sparkle).\n
P:1FBA5:: This is a normal update.\n\n If object type >= $6A, then switch to bank 1,\n and go update a cave.\n
P:1FBB1:: Else call the object update routine.\n
P:1FC88:_UpdateMetaObject
P:1FC8B:: Go handle end metastates (4 and $14) specially.\n
P:1FC94:DoNothing
P:1FC95:: Metastate = 4 or $14.\n\n If it's 4, go reset the metastate. The object is ready to update\n on its own.\n
P:1FC9C:: Metastate = $14\n\n Copy the object type, so that it can be used in setting up\n a dropped item.\n
P:1FCA2:: Certain objects don't advance the world kill cycle.\n
P:1FCA6:: Child Gel
P:1FCAA:: Red Keese
P:1FCAE:: Advance the world kill cycle (0 to 9).\n
P:1FCBD:: If the object is not a zora, then increase room kill count.\n\n\n MULTI: RoomKillCount
P:1FCC0:: Zora
P:1FCC7:: Turn this object into a dropped item.\n
P:1FCCC:: Flag it uninitialized.
P:1FCCF:: TODO: ?
P:1FCDA:_InitObject
P:1FCDD:: We want to handle "enemies from the edges of the screen".\n\n So, if not in UW, or "enemies from edges" attribute is clear,\n or the object is (zora, fire, armos, whirlwind), or any object\n that does not spawn with a cloud (type >= $53);\n \n then go initialize the object.\n
P:1FCE4:: Enemies from edges
P:1FCEB:: Zora
P:1FCEF:: Fire
P:1FCF3:: Armos
P:1FCF7:: Whirlwind
P:1FCFB:: Flying rock
P:1FCFF:: If the "monsters from edges" long timer expired, then\n go bring the monster in.\n Else revert the flag, so this monster becomes uninitialized.\n
P:1FD07:_L_InitMonsterFromEdge
P:1FD12:: Extract and set the monster's location.\n
P:1FD15:: Square column in low nibble. Multiply by 16 to get X.\n
P:1FD1C:: Square row in high nibble. Subtract 3, for the usual offset, to get Y.\n
P:1FD24:: Set the monsters-from-edges long timer to a random value\n between 2 and 5. So, it will last 20 to 50 frames.\n
P:1FD2D:: If the distance to Link is too close to Link, then\n go flag the monster uninitialized again, so we can\n try to spawn it again next time.\n
P:1FD37:: OK to spawn.\n In this situation, monsters don't spawn from a cloud.\n
P:1FD3C:_L_InitObject
P:1FD41:: For monsters that spawn in a cloud, set their start time to\n the same value as the object slot; so that they all start\n moving at different times.\n
P:1FD47:: Armos
P:1FD4B:: Flying Ghini
P:1FD4F:: Flying rock
P:1FD56:: Store the object attributes for fast access.\n
P:1FD5D:: [00] holds object type.
P:1FD5F:: Hit points are packed two values to a byte.\n Divide the object type in half in order to index\n into the hit points table.\n
P:1FD6A:: If the object is a cave, go initialize it.\n
P:1FD6C:: Cave 1
P:1FD75:: Init cave
P:1FD78:: If object is a cave or tile object (type >= $5F),\n go assign object attribute $81, and get\n it ready to behave autonomously and updating.\n
P:1FD7F:: Else run the object initialization routine.\n
P:1FE40:UpdateWhirlwind
P:1FE48:InitRupeeStash
P:1FE50:UpdateRupeeStash
P:1FE58:InitTrap
P:1FE60:UpdateTrap
P:1FE68:InitUnderworldPerson
P:1FE70:InitUnderworldPersonLifeOrMoney
P:1FE78:InitGrumble
P:1FE80:UpdateUnderworldPerson
P:1FE88:UpdateUnderworldPersonLifeOrMoney
P:1FE90:UpdateGrumble
P:1FE98:DecrementInvincibilityTimer: Params:\n X: object index\n
P:1FE9B:: If the timer is already zero, then return.
P:1FE9D:: Every two frames, decrease the timer.
P:1FEA6:UpdateDeadDummy: Monster died sound effect
P:1FEAB:: First metastate of death spark
P:1FEB1:DestroyMonster: Params:\n X: object index\n
P:1FEB3:SetTypeAndClearObject: Params:\n A: object type\n X: object index\n
P:1FEBB:FindEmptyMonsterSlot: Look for an empty object slot for a monster from $B to 1.\n\n Returns:\n A: 0 if found an empty slot\n Y: an empty slot, if found\n Z: 0 if found an empty slot\n [59]: an empty slot, if found\n
P:1FECA:_InitTileObjOrItem: TODO: Describe attribute $81. 1 is self-check collisions and draw.\n\n Set object attribute to $81, and go reset metastate and timer;\n so that the object is ready to start updating itself.\n
P:1FED1:InitFluteSecret: Summary:\n The flute secret object manages the secret color cycle.\n\n The flute secret object is initialized in the same frame that\n the flute was wielded. But this object won't update until\n the flute timer expires.\n
P:1FED6:_ResetObjMetastateAndTimer
P:1FEDA:_ResetObjMetastate: Reset the object metastate so that it's ready to start\n behaving autonomously (updating on its own).\n This is the normal state outside of the spawning cloud and\n the death sparkle.\n
P:1FEE0-1FEE7:WaterPaletteTransferBufTemplate
P:1FEE8-1FEF3:PondCycleColors
P:1FEF4:UpdateFluteSecret: If secret color cycle >= $C, return.\n
P:1FEFB:: 7 of every 8 frames, return.\n
P:1FF03:: So, every 8 frames:\n 1. Increment the secret color cycle count.\n 2. Change the water palette.\n\n But when the count = $B, go reveal the stairs.\n
P:1FF0A:CueTransferPondPaletteRow: Params:\n Y: a point in the cycle (0 to $B)\n\n\n Copy water palette (palette row 3) transfer buf to dynamic\n transfer buf.
P:1FF19:: Patch byte 3 of palette row with the right color in the cycle.
P:1FF21:: If the index is $A,
P:1FF23:: then make most water tiles (< $99) walkable.
P:1FF29:: Set X and Y in this slot for the stairs in the pond.\n Go reveal the stairs as a secret.\n
P:1FF34:AnimatePond: Take turns between:\n * 4 frames stepping the cycle\n * 4 frames delaying
P:1FF50:IsrReset: Disable interrupts.
P:1FF51:: Clear decimal mode.
P:1FF54:: Set the PPU to a base state with no NMI.
P:1FF59:: Set the stack to $01FF.
P:1FF5A:: Wait for one VBLANK.
P:1FF61:: Wait for another VBLANK.
P:1FF64::   in case the first was left over from a previous run.
P:1FF6A:: Reset all MMC1 shift registers.
P:1FF76:: Set our normal mirroring and PRG ROM bank mode.
P:1FF7B:: Use CHR RAM bank 0 for PPU address $00000.
P:1FF98:SetMMC1Control
P:1FFAC:SwitchBank
S:0001:SaveRamBegin
S:051E-0520:SaveFileOpenMarkers
S:0521-0523:SaveFileCloseMarkers
S:0524-0526:FileAChecksums
S:052A-052C:IsSaveFileBCommitted
S:0530-07EF:PlayAreaTiles: Tile map arranged by columns.
S:07F0-0813:MenuPalettesTransferBuf
S:0814-081B:LevelPaletteRow7TransferBuf
S:081C-0826:LevelNumberTransferBuf
S:0827-0846:ColumnDirectoryOW
S:0847-084E:TriforceRow0TransferBuf
S:084F-0858:TriforceRow1TransferBuf
S:0859-0864:TriforceRow2TransferBuf
S:0865-0872:TriforceRow3TransferBuf
S:0873-087D:TriforceTextTransferBuf
S:087E-08FD:LevelBlockAttrsA: OW:\n bits 0-1: palette selector for outer tiles (border)\n bit  2:   sea sound effect\n bit  3:   zora\n bits 4-7: tile column where Link comes out of cave or level\n\n UW:\n Outer and S/N:\n bits 0-1: palette selector for outer tiles (border)\n bit  2-4: S door\n bit  5-7: N door\n In cellars: destination room ID A\n
S:08FE-097D:LevelBlockAttrsB: OW:\n Inner:\n bits 0-1: palette selector for inner tiles\n bits 2-7: cave index\n\n UW:\n Inner and E/W:\n bits 0-1: palette selector for inner tiles\n bits 2-4: E door\n bits 5-7: W door\n In cellars: destination room ID B\n
S:097E-09FD:LevelBlockAttrsC
S:09FE-0A7D:LevelBlockAttrsD
S:0A7E-0AFD:LevelBlockAttrsE
S:0AFE-0B7D:LevelBlockAttrsF
S:0B7E-0BA1:LevelInfo_PalettesTransferBuf
S:0BA2-0BA5:LevelInfo_FoeCounts
S:0BA6:LevelInfo_StartY
S:0BA7-0BAA:LevelInfo_ShortcutOrItemPosArray
S:0BAB:LevelInfo_SubmenuMapRotation
S:0BAC:LevelInfo_StatusBarMapXOffset
S:0BAD:LevelInfo_StartRoomId
S:0BAE:LevelInfo_TriforceRoomId
S:0BAF-0BB0:LevelInfo_WorldFlagsAddr
S:0BB1:LevelInfo_LevelNumber
S:0BB2-0BBB:LevelInfo_CellarRoomIdArray
S:0BBC:LevelInfo_BossRoomId
S:0BBD-0BCC:LevelInfo_SubmenuMapMask
S:0BCD-0BF9:LevelInfo_StatusBarMapTransferBuf
S:0BFA:LevelInfo_PaletteCycles
S:0C5A-0C79:LevelInfo_DeathPaletteSeries
S:0C90:BeginUpdateMode
S:0C97-0CBF:StatusBarTransferBufTemplate
S:0CC0:World_ChangeRupees
S:0CC2:: If a static transfer buf is already chosen, then return.
S:0CC7:: If the dynamic transfer buf is already used, then return.
S:0CC9:: Reset RupeesToAdd or RupeesToSubtract as appropriate,\n if reached 0 or max.\n\n Index of RupeesToSubtract item slot.\n
S:0CD0:: Index of RupeesToAdd item slot.
S:0CD4:: If 0 < rupees < $FF, don't reset anything.
S:0CD6:: Reset the slot we chose.
S:0CDE:: Every two frames, return.
S:0CE3:: If RupeesToAdd <> 0,
S:0CE5:: then add one rupee.
S:0CEB:: Play "heart taken" tune, probably because it's more\n pleasing for a continuous process than "rupee taken".
S:0CF3:: If RupeesToSubtract = 0, then skip it, and go format header text.
S:0CF8:: Subtract one rupee.
S:0CFB:: Play the tune for this.
S:0D00:FormatStatusBarText: Copy transfer buf template for status bar text to dynamic buf.
S:0D24:: Key count goes at offset $21.
S:0D29:: If don't have the magic key, then go format key count.
S:0D2D:: Put an "X" in [$01].
S:0D31:: Put an "A" in formatting buffer.
S:0D36:: TODO: ?
S:0D3B:: Have the magic key. Skip formatting key count.
S:0D50:FormatDecimalCountByteInTextBuf: Params:\n A: value\n Y: offset of first character in buffer.
S:0D55:CopyTripletToTextBuf: Params:\n [$00]: offset to first character in buffer\n
S:0D64:FormatDecimalCountByte: Formats a byte:\n 123 -> "123"\n  23 -> "X23"\n   3 -> "X3 "\n\n Params:\n A: value\n\n Returns:\n [$01]: First character\n [$02]: Second character\n [$03]: Third character\n
S:0D75:FormatCharDoublet: Params:\n A: character\n\n Returns:\n [$02]: character\n [$03]: space\n
S:0D7C:_BitOr0601WithA
S:0D80:_BitOr0603WithA
S:0D89:InitModeB_EnterCave_Bank5: Save the submode.\n
S:0D92:: Put Link at the cave entrance ($70, $DD), and facing up.\n
S:0D9C:FileBChecksums
S:0DA4:: Restore the submode.\n
S:0DA7:: Still initializing. A routine called here changed it.\n
S:0DAD:: Get Link ready to move automatically this number of pixels.\n
S:0DB2:: When coming out of the cave eventually, this has to be set.\n
S:0DB7:ResetRoomTileObjInfo: Returns:\n A: 0\n
S:0DC3-0DC6:ReverseDirections
S:0DC7-0DF0:SaveFileAAddressSets
S:0DF1:FetchFileAAddressSet: Calculate the end of the address set for current file.
S:0DFC:: Copy the save file address set (14 bytes) for the current\n save file to [$00] to make it easier to work with.
S:0E07:: Put the address of the profile's whole\n WorldFlags block in [$0E:0F].
S:0E10:_PlayBoomerangSfx
S:0E1D:HideObjectSprites: Hide all sprites $18 and on.\n Cycle the starting sprite index.
S:0E36:CycleCurSpriteIndex: From 0 to $27.
S:0E39:CycleSpriteIndexInA
S:0E40:ResetCurSpriteIndex
S:0E46:CheckPersonBlocking: Params:\n [0F]: movement direction\n\n Returns:\n [0F]: untouched, or 0\n
S:0E4A:: Return if Y coordinate >= $8E.
S:0E50:: If not moving up, then return.
S:0E55:FormatDecimalByte: Formats a decimal byte. Spaces are used for missing digits.\n\n Params:\n A: value\n\n Returns:\n Y: First character\n A: Second character\n [$01]: First character\n [$02]: Second character\n [$03]: Third character\n
S:0E6E:DivideBy10: Params:\n A: value\n\n Returns:\n Y: result\n A: remainder\n
S:0E79:FormatHeartsInTextBuf: [$0E]: hearts value\n [$0F]: heart partial\n Y: The offset of first character in buffer\n\n The end of the bottom row is $12 bytes after the\n start of the top row. We're writing to two transfer\n records. We write the top row in the first transfer\n record wherever the caller chooses. The second\n transfer record has to begin with the heart tiles.\n So, 7 (offset to end of first row) + 3 (size of transfer\n header) + 8 (length of bottom row) = 18 ($12).\n\n Store the starting offset in [$0D].
S:0E7E:: Put ($F - hearts) in [$00].
S:0E8A:: Put ($F - heart containers) in [$01].
S:0E97:: At this point,\n [$00] = $F - hearts\n [$01] = $F - heart containers\n [$0D] = Y parameter (starting offset in tile buf)\n\n Also, Y is still set to the value passed in.\n
S:0E9D:: Set [$0B] to offset of last heart in top row.
S:0E9F:: Y keeps track of index of heart in row.\n Start at the end of the first row.
S:0EA1:: For X in 0..$10 (all hearts spots):\n
S:0EA3:: If finished first row,
S:0EAA:: Set [$0B] to offset of last heart in bottom row.
S:0EAE:: If there are no hearts,\n or still processing missing heart containers;
S:0EB6:: Use a blank tile.
S:0EB8:: Go emit it.
S:0EBC:: At the boundary heart, go check the partial heart.
S:0EBE:: If no longer processing missing hearts,
S:0EC0:: Use a full heart tile.
S:0EC2:: Go emit it.
S:0EC6:: If partial heart is 0, go emit an empty heart tile.
S:0ECA:: If partial heart at least half full, go emit a full heart tile.
S:0ECE:: TODO: else, clear [$0529]
S:0ED1:: and use a half heart tile.
S:0ED5:: Use an empty heart tile.
S:0ED9:: Emit chosen tile to buf.
S:0EE9:_Unknown_MusicRoutine1
S:0EF9-0EFA:SpriteRelativeExtents
S:0EFB:ShowLinkSpritesBehindHorizontalDoors
S:0F23:: TODO: Is this ever run?
S:0F29:_BoundDirectionHorizontally: Params:\n X: object index\n [0F]: direction\n\n Returns:\n Y: direction of boundary that was crossed\n [0F]: original direction, or 0 if boundary was crossed\n\n\n Checking left direction.
S:0F2D:: [00] holds X coordinate
S:0F33:: If object slot >= $D (items and weapons) or object type = $5C (boomerang),\n then add $B to X coordinate.\n
S:0F45:: Check left boundary.\n If X coordinate crosses (<) left bound, go reset the direction.\n
S:0F4C:: If object is not the player and (slot >= $D or type = $5C),\n then subtract $17 from X coordinate in order to check the\n right bound.\n
S:0F4E:: If object is the player, skip this.
S:0F59:: If not boomerang type, skip this.
S:0F62:: Check right boundary.\n If X coordinate is within (<) right bound, return and leave direction alone.\n
S:0F6B:: If the reference direction in Y register is 0, then\n return and leave direction alone.\n Else reset the target direction.\n
S:0F73:_BoundDirectionVertically: Params:\n X: object index\n [0F]: direction\n\n Returns:\n Y: direction of boundary that was crossed\n [0F]: original direction, or 0 if boundary was crossed\n\n\n Checking up direction.
S:0F77:: [00] holds Y coordinate
S:0F7D:: If object slot >= $D (items and weapons) or object type = $5C (boomerang),\n then add $F to X coordinate.\n
S:0F8F:: Check up boundary.\n If Y coordinate crosses (<) up bound, go reset the direction.\n
S:0F96:: If object is not the player and (slot >= $D or type = $5C),\n then subtract $21 from Y coordinate in order to check the\n down bound.\n
S:0F98:: If object is the player, skip this.
S:0FA3:: If not boomerang type, skip this.
S:0FAC:: Check down boundary.\n If Y coordinate is within (<) down bound, return and leave direction alone.\n
S:0FB3:: If Y coordinate crosses (>=) right boundary, go reset target direction.
S:0FB6:_BoundByRoomWithA: Params:\n A: direction\n X: object index\n\n Returns:\n A: original direction, or 0 if boundary was crossed\n Y: direction of boundary that was crossed\n Z: 1 if boundary was crossed\n [0F]: original direction, or 0 if boundary was crossed\n
S:0FB8:BoundByRoom: Params:\n X: object index\n [0F]: direction\n\n Returns:\n A: original direction, or 0 if boundary was crossed\n Y: direction of boundary that was crossed\n Z: 1 if boundary was crossed\n [0F]: original direction, or 0 if boundary was crossed\n
S:0FC1:AddQSpeedToPositionFraction: Params:\n TODO:\n [010E]: _PositiveRelPosLimit\n [010F]: _NegativeRelPosLimit\n\n Returns:\n C: 1 if fractional position reached a whole pixel\n
S:0FCB:: Save carry flag.
S:0FCC:: Don't let positions go past the limits\n If we're at a limit, then clear carry.
S:0FD9:: Replace saved (pushed) carry flag with 0.
S:0FDC:: Restore carry flag to use in addition below.
S:0FDD:: But save it again in order to return it at the end.
S:0FDE:: TODO: Add only carry to _ObjRelPos[X].\n Carry represents whether the fractional position reached\n a whole pixel (C=1).
S:0FE6:: Return carry flag from speed addition, or 0 if we reached a limit.
S:0FE8:SubQSpeedFromPositionFraction: Params:\n TODO:\n [010E]: _PositiveRelPosLimit\n [010F]: _NegativeRelPosLimit\n\n Returns:\n C: 0 if fractional position reached a whole pixel\n
S:0FF2:: Save carry flag.
S:0FF3:: Don't let positions go past the limits\n If we're at a limit, then set carry.
S:1000:: Replace saved (pushed) carry flag with 1.
S:1003:: Restore carry flag to use in addition below.
S:1004:: But save it again in order to return it at the end.
S:1005:: TODO: Subtract only carry from _ObjRelPos[X].\n Carry represents whether the fractional position reached\n a whole pixel (C=0).
S:100D:: Return carry flag from speed subtraction, or 1 if we reached a limit.
S:100F-1012:OppositeDirs
S:1013:GetOppositeDir: Params:\n A: direction\n\n Returns:\n A: opposite direction\n Y: a reverse direction index\n\n The reverse direction index returned has this mapping:\n In Dir: 1 2 4 8\n         -------\n Index:  3 2 1 0\n
S:101F:Abs: Params:\n A: value\n\n Returns:\n A: absolute value\n
S:1021:Negate: Params:\n A: value\n\n Returns:\n A: result\n
S:1027:_MoveShot: Params:\n A: direction\n X: object index\n [0E]: 0 to change grid offset, else leave it as is\n\n Returns:\n [0E]: $80 if blocked\n [0F]: moving direction, or 0 if boundary was crossed\n\n\n If a boundary was crossed, go set [0E] to $80 instead of moving.\n
S:102C:: Move the object as if grid offset were 0.\n
S:1039:: If [0E] is set, keep the original value in grid offset,\n or else add the new amount to it.\n\n TODO:\n But I'm not clear about where [0E] was last set.\n At least with a player's shot, [0E] was last written in\n 77E7 DrawObjectWithAnim to draw Link. It was set to\n animation index 0. But is that always the case?\n
S:104A:_GetDirectionsAndDistancesToTarget: Params:\n A: object index of target\n X: object index of origin\n [00]: 0\n\n Returns:\n [00]: the number of axes where the distance <= 8\n [03]: distance X\n [04]: distance Y\n [0A]: vertical direction from origin to target\n [0B]: horizontal direction from origin to target\n\n\n Handle the horizontal.\n
S:105E:: Handle the vertical.\n
S:106F:_CalcDiagonalSpeedIndex: Params:\n Y: middle speed index (4)\n [03]: horizontal distance\n [04]: vertical distance\n [0A]: vertical direction\n [0B]: horizontal direction\n\n Returns:\n Y: speed index (0 to 8) for the angle\n\n\n TODO: call it speed index or angle?\n Store the middle speed index in [00]. It will be changed to the\n right speed index to use incrementally.\n Lower speed indexes yield faster X speeds and lower Y speeds.\n Higher speed indexes yield faster Y speeds and lower X speeds.\n
S:1071:: Assuming horizontal distance >= vertical distance, the\n index offset in [01] is negative (-1) to go towards the X axis.\n
S:1075:: TODO:\n If horizontal distance [03] < vertical distance [04], swap [03] and [04],\n and store positive speed index 1 in [01] to go towards the Y axis.\n\n The point is to put the greater value in [03] and the lesser one in [04],\n and use a speed index offset (1 or -1) that will point us in the direction\n of the farther distance faster.\n
S:1087:: TODO: call it speed index or angle?\n If the difference in distances is within 8 pixels,\n return the speed index (angle) we have.\n
S:1090:: TODO: call it speed index or angle?\n Otherwise, go to the next speed index (angle).\n
S:1097:: TODO: call it speed index or angle?\n If a speed index (angle) limit (0 or 8), we've gone all the way to an axis\n (0, 90, 180, 270 degrees). So return this speed index (angle).\n
S:109D:: Subtract the lesser distance from the greater distance.\n If they still haven't crossed, then we can turn more.\n
S:10A8:: TODO: call it speed index or angle?\n Return the speed index (angle) we found.\n
S:10AB:_SetBoomerangSpeed: Params:\n A: q-speed fraction\n
S:10AE:: If in major state $50, use this speed as is.\n
S:10B6:: Else, in major state $40, go at half the speed.\n
S:10B9:: Once we've traveled the target amount of time, set state $50 to go faster.\n In major state $40, ObjMovingLimit is a timer to change the state to $50.\n
S:10C3:_GetOneDirectionAndDistanceToTarget: Params:\n A: target coordinate\n Y: origin coordinate\n [00]: a value\n [0A]: the decreasing direction on the coordinates' axis (2 or 8)\n\n Returns:\n A: the distance from origin to target\n [00]: the original value + 1, if < 8 pixels between origin and target\n [0A]: the direction from origin to target\n\n\n If the origin coordinate already >= target coordinate, then\n the direction in [0A] is already correct. Otherwise, shift it right\n to flip it.\n\n After this, [02] will >= [01].\n
S:10D1:: If the difference between the coordinates < 9, increment [00].\n
S:10DD:WieldBomb: If there are no bombs in inventory, return.\n
S:10E2:: Look in slot $10. If it's empty or there's a fire\n (state = 0, or major state <> $10), then\n go activate a bomb.\n
S:10EE:: Else look at slot $11.\n If there's a bomb there (major state = $10), then return.\n
S:10F9:: We found a slot that's empty or has a fire. It could be $10 or $11.\n If the other slot has a bomb that's not yet detonating (state < $13),\n then return.\n
S:1106:: We're using a bomb. Decrement the count.\n
S:1109:: Play the "set a bomb" tune.\n
S:110E:: Reset the object timer.\n
S:1112:: Start in state $11.\n
S:1114:_SetUpWeaponForPlayerStateAndAnimAndWeaponState: Params:\n A: initial state\n X: object index\n
S:1116:_SetUpWeaponForPlayerStateAndAnim: Set player's animation counter to 1, so that it will roll over\n as soon as possible, causing movement frame to become 0 (legs apart),\n which is how we want to end item-use animations.\n\n Set player's state to $10 (wielding sword/item).\n
S:111B:_SetUpWeaponForPlayerState
S:111F:_SetUpWeapon: Places the weapon $10 pixels away from the player in the\n player's direction.\n\n Params:\n A: $10 for right and down\n X: object index\n\n\n Set the offset choices to:\n  $10 for right and down in [01]\n -$10 for left and up in [02]\n
S:1125:: Set object's direction to the player's.\n
S:1129:: Set object's X to player's X + offset for direction.\n
S:1130:: Set object's Y to player's Y + offset for direction.\n
S:1132:: Shift player's direction, so that it behaves like a horizontal if it's vertical.
S:113C:_ChooseOffsetForDirectionH: Params:\n A: direction\n [01]: value for right\n [02]: value for left\n\n Returns:\n A: chosen value, or 0 if not horizontal\n C: 0\n\n\n Set default value 0 in default address 0.\n
S:1142:: If vertical, go choose slot 0 (value 0).
S:1144:: Direction is horizontal. Increment index to 1.
S:1147:: If direction is right, go choose slot 1.
S:1149:: Direction is left. Increment index to 2.
S:114A:: Load the offset for the calculated index.
S:114D:: Clear carry in preparation for adding offset to another value.
S:114F:WieldCandle: Returns:\n X: last object slot tested, regardless of whether it's empty\n\n Fails if no empty slot was found, or the blue candle was already used.\n\n\n Look in slots $10 and $11. If none are empty, return.\n Otherwise, X will have the empty slot found.\n\n Note that it's possible that we fail to find an empty slot,\n but the caller might find slot X occupied by a fire made earlier.\n
S:115A:: If we have the blue candle and it was used, then return.\n
S:1166:: Set the candle used.\n
S:116B:: Reset the new fire object's movement info.\n Set quarter speed (q-speed) to $20 (half a pixel a second).\n
S:1178:: Activate the fire object. Initial state = $21 (moving fire).\n
S:117C:: TODO: sound effect?\n
S:1181:: Each animation frame lasts 4 frames.\n
S:118A:GetShortcutOrItemXY: Returns:\n A: X coordinate of shortcut (OW) or item (UW)\n Y: Y coordinate of shortcut (OW) or item (UW)\n
S:118C:GetShortcutOrItemXYForRoom: Params:\n Y: room ID\n\n Returns:\n A: X coordinate of shortcut (OW) or item (UW)\n Y: Y coordinate of shortcut (OW) or item (UW)\n
S:118F:: Isolate shortcut or item position index.
S:1196:: Get one of the 4 positions.
S:1199:: Save position.
S:11A1:: Restore position.
S:11A5:_DestroyObject_WRAM: Params:\n A: 0\n X: object index\n
S:11BB:UpdateBombFlashEffect: If state <> $13, return.\n
S:11C1:: The effect involves turning grayscale rendering on and off\n in PPUMASK.\n\n Start by setting A register to the PPU mask shifted right to\n throw away the grayscale bit.\n
S:11C4:: Then, based on the timer value, shift in a 1 or 0 in the low bit.\n
S:11C6:: At times $16 and $11, rotate carry=1 to the low bit.\n Carry will have been set, because of the comparison (CPY).\n
S:11D2:: At times $12 and $D, shift left to make the low bit 0.\n
S:11DB:: Only at times $16, $11, $12, $D do we commit the mask\n we calculated.\n
S:11DE:UpdatePlayerPositionMarker: Return if mode 9 or whirlwind teleporting.
S:11ED:UpdatePositionMarker: Params:\n A: room ID\n\n\n Push the room ID.
S:11EE:: Sanitize the row of the room ID.
S:11F0:: The rows in status bar map are 4 pixels tall.
S:11F2:: Add $17 pixels to Y coordinate.
S:11F4:: Place the position marker vertically.
S:11F7:: Map X at $11 in OW.
S:11FD:: Map X at $12 in UW.
S:11FF:: Store the appropriate status bar map left coordinate in [$00].
S:1201:: Pop the room ID.
S:1202:: Isolate the column of the room ID.
S:1208:: In UW, columns in status bar map are 8 pixels wide.
S:1209:: In OW, they are 4 pixels wide.
S:120B:: Add the status bar map left coordinate.
S:120D:: Add a horizontal offset from level info to center the map.
S:1210:: Place the position marker horizontally.
S:1215:: Use the position marker tile.
S:121C:: If we're updating the triforce marker,
S:121E:: Set up a default "inactive" palette (attribute), which means "not gotten".
S:1225:: If you're in level 9, use the "active" palette only.
S:122D:: If player hasn't gotten the piece,
S:1235:: then every 16 frames,
S:1238:: switch between two palettes.
S:1248:UpdateWorldCurtainEffect: Params:\n [$7C]/ObjX[$C]: column index that will be decreased + 1\n [$7D]/ObjX[$D]: column index that will be increased + 1\n
S:124A:: Delay until ObjTimer[0] expires.
S:124C:: Start with column index in [$7D] ObjX[$D].
S:1252:: Get current column index.
S:1254:: Set CurColumn for column copying routine to use.
S:125B:: Set vertical nametable mirroring.
S:1263:: Now reference the column with index in [$7C] ObjX[$C].
S:1265:: If we copied both columns, then quit.
S:1267:: Invalidate CurColumn
S:126B:: Set a delay of 4 frames (5-1) in ObjTimer[0].
S:126F:: Change the column indexes.
S:1274:Add1ToInt16At0: Params:\n [$00:01]: a 16-bit value to increment\n\n Returns:\n [$00:01]: sum\n A: low byte of sum\n
S:1276:AddToInt16At0: Params:\n A: value 1\n [$00:01]: value 2\n\n Returns:\n [$00:01]: sum\n A: low byte of sum\n
S:1280:Add1ToInt16At2: Params:\n [$02:03]: a 16-bit value to increment\n
S:1282:AddToInt16At2: Params:\n A: value 1\n [$02:03]: value 2\n\n Returns:\n [$02:03]: sum\n
S:128C:Add1ToInt16At4: Params:\n [$04:05]: a 16-bit value to increment
S:128E:AddToInt16At4: Params:\n A: value 1\n [$04:05]: value 2\n\n Returns:\n [$04:05]: sum\n
S:1298:Sub1FromInt16At4: Params:\n [$04:05]: a 16-bit value to decrease\n
S:12A4-12C7:ItemIdToSlot
S:12C8-12EB:ItemIdToDescriptor: Each byte describes an item. The high nibble is the type.\n The low nibble is the value. Its meaning depends on the type.\n\n 0x - individuals\n * unique: value is boolean: you have it or you don't; also value indicates palette row sprite attribute.\n * bit mask: value doesn't matter.\n\n 1x - amounts\n Value is an amount to add.\n\n 2x - grades\n Value is a grade and palette row. Picking up an item with a lower grade won't change the inventory.\n\n 3x - error?\n Produces an item value of $FF.\n
S:12EC-130B:ItemSlotToPaletteOffsetsOrValues: Maps an item slot to a value used in calculating the\n sprite palette row attribute.\n\n For most items, the value is the sprite palette row attribute\n itself.\n\n Some items will use the value as an amount to add to the\n item value in the slot.\n
S:130C:SetRoomFlagUWItemState
S:1314:GetRoomFlagUWItemState: Returns:\n A: $10 if item was taken, else 0\n
S:1325-1327:LinkColors_CommonCode
S:1328:TryTakeRoomItem: If Link is halted, then return.\n
S:1330:: If player took the room item, then return.\n
S:1335:: Switch to room item object slot $13.\n
S:1337:: If room item object wasn't activated, then return.\n
S:133B:: Pass RoomItemId, also known as [98][$13] and ObjDir[$13],\n to try to take the item.\n
S:133D:: [04] holds the item type.
S:133F:TryTakeItem: Params:\n X: object index\n [04]: item type\n\n\n If the lifetime timer of the item >= $F0, then return;\n so that the player can't pick it up right away.\n\n MULTI: ObjPosFrac [03A8][X] is used to count down the life of the item.
S:1346:: If Y distance between Link and the item >= 9, return.\n
S:1355:: If X distance between Link and the item >= 9, return.\n
S:1361:: In case this is the room item, set state to $FF to deactivate it.\n
S:1367:: If it is the room item that is taken, then\n mark it taken in room flags.\n
S:136E:: Get the item type.
S:1370:TakeItem: Params:\n A: item ID\n\n By default, we'll play the "item taken" tune.\n
S:1375:: Unless it's the Triforce of Power; in which case\n play the "item appears" tune.\n
S:137E:: If we're in a cave or cellar, then\n prepare to lift the item.\n
S:1384:: Lift for $80 frames.
S:1389:: Play the "item" song.
S:138E:: Set the item type for lifting.
S:1391:: Look up the item slot and sprite attributes by the item type.\n
S:1399:: [0A] holds the item value from the low nibble of descriptor.\n
S:139F:: Check the high nibble which specifies the item's class.\n\n A: item class\n X: item type\n Y: item slot\n
S:13A1:: Go check classes 1 and 2.
S:13A3:: Class 0. We have an item of a type that's unique or complex.\n\n First, check the exceptions. If the item is a map, compass, or triforce; then go handle them.\n\n\n Map item slot
S:13A7:: Compass item slot
S:13AB:: Triforce pieces item slot
S:13AF:: Triforce of Power item slot
S:13B3:: Finally, this is a simple item. Put the item value in the item slot.\n
S:13B9:: For 5 Rupees, perform the action for 1 rupee 5 times.\n
S:13C2:: A: item class\n X: item type\n Y: item slot\n
S:13C4:: Go check class 2 items.
S:13C6:: Class 1. We have a type of item with an amount.\n Item value is the amount to add.\n\n\n Heart container item slot
S:13CA:: 5 Rupees item slot
S:13CE:: Rupee item slot
S:13D2:: Heart item slot
S:13D6:: For key item slot, play the tune here.\n Add to the amount below.\n
S:13DD:: For fairy item slot, go handle it where hearts are increased.\n
S:13E1:: Keys and other items.\n Add item value and value in item slot.\n
S:13E7:: If the sum overflowed,
S:13E9:: then cap it at $FF.
S:13EB:: For potion item slot, cap it at 2.\n
S:13F5:: For bomb item slot, cap it at MaxBombs.\n
S:1401:: Go set the item value and return.
S:1404:: For heart containers, cap at $10.\n Add a heart container and a heart.\n
S:1409:: If we already have max hearts, return.
S:140D:: Go set the item value and return.
S:1413:: Make sure this is an item of a type ordered by grade.\n Then go handle it.\n
S:1415:: If the class is $30, go set item value to $FF.
S:1419:: We're taking a class 0 complex item found in UW.\n\n A: item class\n X: item type\n Y: item slot\n
S:141B:: If in OW, return.
S:141D:: Triforce of Power item slot
S:1421:: Map item slot
S:1423:: If it's the map item slot,
S:1425:: then signal the main loop to draw the status bar map.
S:142A:: Choose the right slot for the level. (map/map9, compass/compass9)\n
S:142B:: Subtract one from level number to base it on 0.
S:142F:: If the result >= 8, we're in level 9,
S:1431:: So add 2 to the item slot to use the one for level 9.
S:1433:: Make sure the level index is in the range 0 to 8.
S:1436:: Combine the mask for this level with the mask in the item slot.\n
S:143F:: If the item taken was a triforce piece, then go to mode $12.\n
S:1441:: If it's not a triforce piece, then return.
S:144B:TakeHearts: Params:\n [0A]: item value/amount\n
S:144E:: Move item value in [0A] to [01].
S:1450:: [01] holds the number of hearts to add minus 1.
S:1452:: For that many hearts, add them one by one.\n
S:1455:: If there's room to add a whole heart, go add it.
S:1457:: If partial heart is not full, then fill it and return.\n
S:145E:: Add a whole heart.\n
S:1463:: If there are more hearts to add, go compare them to heart containers again.
S:146C:CompareHeartsToContainers: Returns:\n Z: 1 if hearts = containers\n
S:147C:L_TakePowerTriforce
S:1484:: Class 2. We have a type of item that is ordered by grade.\n Item value is the grade.\n\n A: item class\n X: item type\n Y: item slot\n [0A]: item value\n
S:1489:: If we have a higher grade of this kind of item, return.
S:148B:: Set the new item grade.
S:148E:: Ring item slot
S:1490:: If the item is not a ring, return.
S:1492:: We took a ring. Change Link's color.\n
S:1494:: Get ring in inventory.
S:1497:: Get the color for this ring value.
S:149A:: Get the offset of row 4, 5, or 6, depending on save slot.
S:149D:: Patch the color into the menu palette.
S:14A0:: Then patch the color into the level's palette.
S:14A3:TakeOneRupee: Play "rupee taken" tune.
S:14AC:PlayKeyTakenTune: Stop playing tune 2.
S:14B1:: Play "key taken" tune.
S:14B7:AnimateWorldFading: Params:\n [$051C]: cycle number\n\n Returns:\n Z: 1 if done updating\n\n ObjTimer[12] is the world fade timer. Every 10 frames,\n we step to the next half palette. There are 4 steps to fading.\n
S:14B9:: If the timer hasn't expired, then only delay (return).
S:14BE:: If the cycle number is negative, then this is a reverse fade.
S:14C2:: Map cycle value with hex digits XY to offset (X0 + Y*8).
S:14CD:: Start writing in dynamic transfer buf from the next position\n available. X holds this offset.
S:14D0:: Write PPU address $3F08, bottom half of background palette.
S:14DB:: %A holds 8. Write that as the length of the record.
S:14DF:: Copy 8 bytes of half palette into transfer buf.\n
S:14EE:: Write the end marker.
S:14F3:: Store the new position into the dynamic transfer buf as the length.
S:1502:: Update every 10 frames.
S:150A-1511:_BlankSpriteTemplates
S:1512:_Write16BlankSprites: TODO: Why? And why are their Y coordinates $3D and $DD? Those values are the highest and lowest that Link can normally take.\n\n Repeat two sprites in the first $10 records. They have\n transparent tile $1C, priority 1 (behind BG), and X=0.\n The first of the pair has Y=$3D, and the second one has Y=$DD.\n
S:1527-152A:ForestMazeDirs
S:152B-152E:MountainMazeDirs
S:152F:CheckMazes: Params:\n Y: room ID\n
S:1538:: If not in forest maze, go check mountain maze.
S:153D:: If direction doesn't match current step, go handle it.
S:153F:: The direction matches the step.\n
S:1541:: If the last step matches, go let the player pass.
S:1543:: Haven't passed the last step. So increment the step,\n but repeat this room.
S:1549:ResetMazeStep
S:1551:: If going right in the forest, allow exit.
S:1553:: Else you have to start over.
S:1556:: Go set the next room to the current one, and return.
S:155A:: If not in the mountain maze either, go reset the maze step and leave room alone.
S:155F:: If the direction matches the current step, go see if it's the last one.
S:1563:: If not going left in the mountain, go start over.
S:1565:: Else allow exit.
S:1568:: If this isn't the last step, then go advance the step, but repeat the room.
S:156A:: Play secret tune, and let the player leave the maze.\n
S:1570:_MapScreenPosToPpuAddr: Params:\n [02]: Y\n [03]: X\n\n Returns:\n [00]: high byte of PPU address\n [01]: low byte of PPU address\n\n\n Turn the 16-bit value 08YY into the PPU address\n ($2000 + (YY * 4)) by multiplying it by 4.\n\n Each row of tiles is 32 tiles (and bytes) long, and 8 pixels tall.\n This is why the Y coordinate is multiplied by 4 (= 32 / 8).\n
S:1580:: Now divide X coordinate by 8, because each tile is 8 pixels wide.\n
S:1585:: Combine the low address of the row with the column to get\n the final low byte of PPU address.\n
S:1594-1612:ObjAnimations
S:1613-16DE:ObjAnimFrameHeap
S:16DF-17AA:ObjAnimAttrHeap
S:17AB-17D3:SpriteOffsets
S:17D4:_AnimateAndDrawObjectWalking
S:17DB:DrawObjectMirrored: Params:\n A: frame image\n X: object index\n [00]: object X\n [01]: object Y\n\n\n Set [0C] mirrored.
S:17DF:DrawObjectNotMirrored: Params:\n A: frame image\n X: object index\n [00]: object X\n [01]: object Y\n [0F]: flip horizontally\n
S:17E1:: Set [0C] not mirrored.
S:17E3:: Set animation index = object type + 1.\n
S:17E6:DrawObjectWithType: Params:\n A: frame\n X: object index/cycle sprite index\n Y: object type\n [00]: object X\n [01]: object Y\n [0C]: mirrored\n [0F]: flip horizontally\n\n Note:\n If the object is not mirrored, then it's horizontally flippable.\n\n The animation index of most objects is (object type + 1),\n to make up for the fact that Link uses two animation indexes.\n
S:17E7:_DrawObjectWithAnim: Params:\n A: frame\n X: object index/cycle sprite index\n Y: animation index\n [00]: object X\n [01]: object Y\n [0C]: mirrored\n [0F]: flip horizontally\n\n Note:\n If the object is not mirrored, then it's horizontally flippable.\n But Link uses [0F] for flipping without checking [0C].\n\n\n [0D] holds frame.
S:17E9:: [0E] holds animation index.
S:17EB:: [08] holds object index/cycle sprite index
S:17ED:: Set the left and right sprite record offsets for CurSpriteIndex.\n
S:17F9:: But if it's Link, then hardcode them to sprites $12 and $13.\n
S:17FD:: Link's left sprite record offset
S:1802:: Link's right sprite record offset
S:1804:_DrawObjectWithAnimAndSpecificSprites
S:1809:: This object has 2 sides.
S:180D:: The right side is 8 pixels away from the left.
S:1815:: Add frame number.
S:1818:: Look up the tile.
S:181B:: Set the left tile.
S:1820:: The right tile is two tiles over.
S:1822:: If object is Link, or object index/slot >= $D (weapons, room item),\n then go set attributes and write sprites.\n
S:182A:: If the object has a "half-width draw" attribute, then\n go draw half-width.\n
S:182D:: "Half-width draw" object attribute
S:1831:: If the object has the "Ignore sprite attribute table" attribute,\n then don't look up sprite attributes.\n
S:1834:: "Ignore sprite attribute table" object attribute
S:1838:: Look up the sprite attribute.
S:183E:: If it's Link, write the sprites. He's never mirrored.\n
S:1842:: For other objects, the caller controls mirroring and flipping.\n\n If mirrored [0C], then draw it mirrored.\n Else draw it horizontally flippable, controlled by [0F].\n
S:1849:: Mark the object narrow (half-width).
S:184E:Anim_WriteHorizontallyFlippableSpritePair: Params:\n [00]: Object X\n [01]: Object Y\n [02]: Left tile\n [03]: Right tile\n [04]: Left attributes\n [05]: Right attributes\n [07]: Has two sides\n [08]: Cycle sprite index\n [0A]: X separation\n [0F]: Flip horizontally\n [0343]: LeftSpriteOffset\n [0344]: RightSpriteOffset\n\n If [0F] = 0, write the sprite pair with no further processing.\n
S:1852:: Otherwise, reverse the two sides.\n
S:185C:: Set the horizontal flip sprite attributes.\n
S:1868:Anim_WriteSpritePair: Params:\n [00]: Object X\n [01]: Object Y\n [02]: Left tile\n [03]: Right tile\n [04]: Left attributes\n [05]: Right attributes\n [07]: Has two sides\n [08]: Cycle sprite index\n [0A]: X separation\n [0343]: LeftSpriteOffset\n [0344]: RightSpriteOffset\n\n If not currently invincible, then leave the attributes alone.\n
S:186D:: For both left and right sprites, indexed by Y register:\n
S:186F:: Toss out the palette bits of the sprite attributes.
S:1877:: Patch the bottom 2 bits of the invincibility timer.
S:187F:: This gives us the flashing effect.
S:1885:Anim_WriteSpritePairNotFlashing: Access the first sprite.
S:188A:: Write the sprite tile.
S:1890:: Write the sprite Y.
S:1895:: Write the sprite X.
S:189A:: Separate the second sprite appropriately from the first.
S:189F:: Write the sprite attributes.
S:18A5:: Now point to the other sprite.
S:18A8:: Cycle the current sprite index, if needed.
S:18AF:: Increase the index to access the second sprite's properties.
S:18B2:: If there is a right sprite, then go process it.
S:18B4:: Put the object index in X again.
S:18B7-18DB:Anim_ItemFrameOffsets: Maps an item slot to the offset of its first frame in ItemFrameTiles heap.
S:18DC-190B:Anim_ItemFrameTiles
S:190C:_Anim_WriteStaticItemSpritesWithAttributes: A: sprite attributes\n X: cycle sprite index / object index\n Y: item slot\n [00]: X\n [01]: Y\n
S:1911:: Reset horizontal flipping.
S:1913:: Reset frame.
S:1915:Anim_WriteItemSprites: Params:\n X: cycle sprite index / object index\n Y: item slot\n [00]: X\n [01]: Y\n [04]: left sprite attributes\n [05]: right sprite attributes\n [0C]: frame image\n [0F]: flip horizontally\n\n Returns:\n [52]: ProcessedNarrowObj\n\n\n Save the item slot passed in Y.
S:191B:: Determine the left and right sprite offsets for current sprite index.
S:192A:: Restore the item slot passed in.
S:192C:Anim_WriteSpecificItemSprites: Params:\n X: cycle sprite index / object index\n Y: item slot\n [00]: X\n [01]: Y\n [04]: left sprite attributes\n [05]: right sprite attributes\n [0C]: frame\n [0F]: flip horizontally\n [0343]: LeftSpriteOffset\n [0344]: RightSpriteOffset\n\n Returns:\n [52]: ProcessedNarrowObj\n\n\n Store the object index in [08].
S:192E:: Assume the object has two sides.
S:1932:: Both sides are usually separated by 8 pixels.
S:193A:: Get the frame.
S:1940:: [02] gets the tile we just looked up.
S:1943:: The second tile must be two tiles farther in CHR.
S:1945:: Put it in [03].
S:1947:: If left tile is $F3 or in [$20, $62),\n then this is a narrow / half-width object.
S:1958:: If not left-aligning a half-width object,
S:195A:: Then add 4 to X to center it.
S:1961:: Record that this is a half-width object.
S:1963:: And mark it as such.
S:1967:: Finished. Go write sprites.
S:196C:: If tile < $6C, go mark this a slim object.
S:1972:: Tile >= $7C. Can flip horizontally.
S:1977:: Both sides of slim objects overlap one pixel.
S:1979:Anim_WriteMirroredSpritePair: Params:\n X: cycle sprite index / object index\n [00]: X\n [01]: Y\n [02]: left tile\n [03]: right tile\n [04]: left sprite attributes\n [05]: right sprite attributes\n [0343]: LeftSpriteOffset\n [0344]: RightSpriteOffset\n\n\n All wide items that we process have mirrored sides.
S:197B:: Make the right side the same as the left.
S:197D:: Flip the right side horizontally.
S:1986:Anim_SetSpriteDescriptorRedPaletteRow: Returns:\n A: 2\n [04]: left sprite attributes\n [05]: right sprite attributes\n
S:1988:Anim_SetSpriteDescriptorAttributes: Params:\n A: sprite attributes for both sides\n\n Returns:\n [04]: left side sprite attributes\n [05]: right side sprite attributes\n\n Doesn't change A.\n
S:198D:Anim_WriteLevelPaletteSprite: Params:\n A: tile number\n X: object index\n
S:1991:Anim_WriteSprite: Params:\n A: tile number\n X: object index\n [03]: sprite attributes\n
S:19A5:Anim_WriteSpecificSprite: Params:\n A: tile number\n X: object index\n Y: sprite record offset\n [03]: sprite attributes\n
S:19AF:_Anim_EndWriteSprite: Params:\n A: Y coordinate\n Y: sprite record offset\n [03]: sprite attributes\n
S:19BA:Person_DrawAndCheckCollisions_Common
S:19BD:: If the person is flagged dead, then\n enable fireballs from the two flames, and reset the metastate.\n
S:19CA:Person_Draw: Either way, draw the object.\n
S:19D0:CheckMonsterCollisions: Params:\n X: object index\n\n Note:\n This routine might modify the facing direction.\n
S:19D3:: If the object is invincible, skip checking collisions with Link's weapons.\n But go check for a collision with Link.\n
S:19D6:: Invincible
S:19DA:: If temporarily invincible, return.\n
S:19DF:: Check for collisions with each weapon.\n
S:1A00:: If the monster is not dying, then go see about monsters\n that capture Link.\n
S:1A08:: This monster is dying.\n\n If it's a goriya that threw a boomerang, then destroy the boomerang.\n
S:1A0C:: Red Goriya
S:1A14:: Get the object slot of this goriya's boomerang.
S:1A1D:: If the monster is a wallmaster or like-like and there's a hit\n (using [0C] flag), then set the monster's capture flag.\n\n Wallmaster object type
S:1A21:: LikeLike object type
S:1A2D:GetObjectMiddle: Params:\n X: object index\n\n Returns:\n [02]: center X\n [03]: center Y\n\n\n Start with offset 8 for X and Y in [02] and [03].\n
S:1A33:: If object attribute $40 is set, make X offset 4.\n
S:1A36:: Half width (for collision detection)
S:1A3A:: Cut the X offset [02] in half.
S:1A3C:: Add object's X coordinate to [02].\n
S:1A43:: Add object's Y coordinate to [03].\n
S:1A4A-1AA6:ObjTypeToDamagePoints
S:1AA7:CheckLinkCollision: Params:\n X: monster object index\n\n Returns:\n [00]: 0 for Link slot\n [06]: 1 if objects collide\n [09]: 0 for Link damage type (none)\n [0C]: 1 if objects collide\n [034B]: ShotCollidesWithLink\n\n TODO:\n Returns:\n Y: 0\n
S:1AAA:: Reset variables to return.\n
S:1AB9:: If Link is invincible, or we have the magic clock,\n or Link is stunned, or the monster is stunned;\n then return no collision.\n
S:1AC5:_CheckLinkCollisionPreInit: If Link is halted or paralyzed, then return no collision.\n
S:1AD0:: If the object is a monster's shot/projectile, and it's not in a\n state that it can do damage; then return no collision.\n
S:1ADF:: Store Link's midpoint coordinates in [04] and [05].\n
S:1AED:: If both objects are 9 pixels apart or more, then return no collision.\n
S:1AF4:: They collide. Now find out how they collide.\n\n If it's a regular monster, go harm Link.\n
S:1AFB:: Here, the attacker is a monster's shot/projectile.\n Flag this kind of collision.\n
S:1AFE:: If object type = Fireball2 ($56) or $5A, or Link is not idle;\n then go harm Link.\n
S:1B0C:: If Link and the shot are not facing opposite directions,\n then go harm Link.\n\n Note the bitwise AND in the test. It picks out one direction\n component of a monster that can move diagonally.\n
S:1B20:: Link and the shot are facing opposite directions.\n Link can parry certain weapons/shots.\n\n For flying rock, $54, arrow, and boomerang, this means\n no harmful collision; but it still counts as a shot collision.\n So, go treat this as a parry.\n
S:1B2B:: If the magic shield is missing, then the rest of the shots do damage.\n So, go harm Link.\n
S:1B30:: Else Link parries.\n\n Play the "parry" tune, and cancel the collision (reset [06]).\n
S:1B3D:: Flag collision with [0C], even though [06] was already set.\n
S:1B3F:: Unpack the damage points for the monster's type.\n The low nibble is the high byte.\n (Damage points byte AND $F0) is the low byte.\n
S:1B4F:Link_BeHarmed: Params:\n X: object index of the attacker\n [0D]: damage points high byte\n [0E]: damage points low byte\n\n\n TODO: ?\n If object type is not whirlwind, then make the "hurt" sound effect\n
S:1B5B:: For every level of ring (1 or 2), divide the 16-bit damage amount in [0E:0D] by 2.\n
S:1B67:: Reset values used in special item drops.\n
S:1B70:: If heart partial >= low damage points byte, then simply\n subtract the damage byte from heart partial.\n Else go borrow from full hearts.\n
S:1B7D:: If full hearts >= high damage points byte, then simply\n subtract the damage byte from full hearts.\n Else go handle Link dying.\n
S:1B90:: This isn't a simple case of borrowing. For example, supposing:\n   full heart=4 partial heart=$70\n The straightforward way to subtract $80 would yield $3F0.\n But the method here yields $3EF, because partial heart is\n considered full when = $FF instead of $100.\n
S:1B9D:: If we can't borrow from full hearts, then Link died.
S:1BA9:: Link died.\n\n Set full hearts, partial heart, and Link's object state to 0.\n Make Link face down.\n Go to mode $11.\n
S:1BC2:CheckMonsterBoomerangOrFoodCollision: Params:\n X: monster slot\n Y: weapon slot\n [02]: monster mid X\n [03]: monster mid Y\n\n Returns:\n [00]: weapon slot\n\n If the weapon slot holds food (high bit of state is set), then return.\n
S:1BC8:: [00] holds the weapon slot
S:1BCA:: Set boomerang damage type (2) in [09].\n
S:1BCE:: Set collision threshold $A in both axes.\n
S:1BD4:: The boomerang's middle X is 4 pixels to the right. Store in [04].\n
S:1BDC:: The boomerang's middle Y is 8 pixels down. Store in [05].\n
S:1BE2:CheckMonsterWeaponCollision: Params:\n A: weapon object mid Y\n X: monster object slot\n Y: weapon object slot\n [00]: weapon object slot\n [02]: monster object mid X\n [03]: monster object mid Y\n [04]: weapon object mid X\n [07]: damage points\n [09]: damage type\n [0D]: horizontal threshold\n [0E]: vertical threshold\n\n Returns:\n [06]: 1 if objects collide\n
S:1BE4:: Reset [06] for no collision.\n
S:1BE8:: If the weapon's not active (state = 0), then return.\n
S:1BEF:: If the objects do not collide, then return.\n
S:1BF4:: If the weapon is a boomerang ...\n
S:1BF8:: ... and the monster is invincible to it,\n then play the parry sound.\n
S:1C02:: Set the boomerang state to return fast to the thrower.\n
S:1C07:: If the monster is invincible to the boomerang, then return.\n
S:1C0E:: Still the boomerang.\n Reset [07] damage points, and set the monster's stun timer to $10 ($A0 frames).\n
S:1C16:_HandleMonsterWeaponCollision: If the monster is invincible to this damage type, then\n go play parry sound if needed, and return.\n
S:1C1D:: If the monster is Blue Gohma or Red Gohma, then\n let it handle the collision.\n
S:1C2B:: If the monster is Zol or Vire, then\n   If not hit by the boomerang, then\n     Set monster's direction to the weapon's\n   Go deal damage\n
S:1C3F:: If the monster is a red or blue darknut, and it and the weapon\n are facing opposite directions, then only play the parry sound.\n
S:1C54:DealDamage: Play the "harmed" sound.\n
S:1C59:: Subtract the damage points from HP; if damage points >= HP,\n then go handle the monster dying.\n
S:1C5C:: [07] damage points
S:1C61:: [07] damage points
S:1C69:L_PlayParrySoundForDamageType: Play the parry sound for all but fire and bomb damage types.\n
S:1C6B:: Fire damage type
S:1C6F:: Bomb damage type
S:1C76:: Handle the monster dying.\n
S:1C79:: Increase the help drop counter, if not at max ($A).\n
S:1C81:: If the help drop counter has reached the max, and damage type = bomb (8);\n then set [51] HelpDropValue in order to drop a bomb next time.\n
S:1C8F:: Set the dying metastate, and reset some object info.\n
S:1C96:_ResetShoveInfoAndInvincibilityTimer: Params:\n A: 0\n
S:1C9D:CheckMonsterSwordShotOrMagicShotCollision: Params:\n X: monster slot\n Y: weapon slot\n [02]: monster mid X\n [03]: monster mid Y\n\n Returns:\n [00]: weapon slot\n\n [00] holds the weapon slot
S:1C9F:: Set magic shot damage type ($10) in [09].\n
S:1CA3:: If the shot is a sword shot that's spreading out, then return.\n
S:1CA9:: Set horizontal collision threshold $C.\n
S:1CAD:: If the weapon is a magic shot, go use $20 damage points.\n
S:1CB5:: The weapon is a sword shot.\n\n First, change the damage type to sword (1).\n
S:1CB9:: Determine the damage points for the kind of sword.\n - wood sword:   $10\n - white sword:  $20\n - master sword: $40\n
S:1CCE:: If no collision, then return.\n
S:1CD2:: Else handle blocking the shot.\n
S:1CD4:: Shot object slot
S:1CDC:CheckMonsterBombOrFireCollision: Params:\n X: monster slot\n Y: weapon slot\n [02]: monster mid X\n [03]: monster mid Y\n\n Returns:\n [00]: weapon slot\n\n [00] holds the weapon slot
S:1CDE:: Set up parameters for a fire.\n
S:1CE0:: [09] holds fire damage type
S:1CE4:: [07] holds $10 damage points
S:1CE8:: [0D] holds collision threshold $E
S:1CEA:: If the weapon is a fire, then go set the hotspot/midpoint.\n But if the bomb is not detonating, then return.\n
S:1CF5:: Else set up parameters for a bomb.\n
S:1CF7:: [09] holds bomb damage type
S:1CFB:: [07] holds $40 damage points
S:1CFF:: [0D] holds collision threshold $18
S:1D01:: The weapon's midpoint/hotspot is at (X + 8, Y + 8).\n Pass it in [04] and [05].\n
S:1D11:: Pass collision threshold in A.
S:1D13:: If the objects do not collide, then return.\n
S:1D1B:: If the monster is weak to the damage type, then shove it.\n
S:1D25-1D28:_SwordDamagePoints: TODO:\n Overlaps the last byte of routine above.\n When this address is used as an RTS, it should have one label.\n But when it's used as an array of damage points, it should have a different name.\n
S:1D29:CheckMonsterSwordCollision: Params:\n X: monster slot\n Y: weapon slot\n [02]: monster mid X\n [03]: monster mid Y\n\n Returns:\n [00]: weapon slot\n [06]: 1 if objects collide\n\n [00] holds the weapon slot
S:1D2B::Set sword damage type (1) in [09].\n
S:1D2F:: If the sword is not fully extended, then return.\n
S:1D36:: Look up and set the damage points for the sword type.\n
S:1D3C:_CheckMonsterStabbingCollision: Params:\n A: damage points\n X: monster slot\n Y: weapon slot\n [02]: monster mid X\n [03]: monster mid Y\n [09]: damage type\n\n Returns:\n [06]: 1 if objects collide\n\n [07] damage points
S:1D3E:: If Link's direction is vertical, then set collision thresholds accordingly:\n [0D] := $C\n [0E] := $10\n
S:1D4D:: Else switch it:\n [0D] := $10\n [0E] := $C\n
S:1D58:: If no collision, then return.\n
S:1D5F:CheckMonsterArrowOrRodCollision: Params:\n X: monster slot\n Y: weapon slot\n [02]: monster mid X\n [03]: monster mid Y\n\n Returns:\n [00]: weapon slot\n [06]: 1 if objects collide\n\n [00] holds the weapon slot
S:1D64:: If the weapon is a rod, then\n go check a stabbing collision using rod parameters.\n
S:1D6A:: [09] holds sword damage type
S:1D6C:: Pass $20 damage points.
S:1D70:: We have an arrow. If it's no longer flying, then return.\n
S:1D74:: Set up arrow parameters.\n
S:1D76:: [09] holds arrow damage type
S:1D78:: Use $20 damage points for wooden arrows, and $40 for silver ones.\n
S:1D84:: [0D] holds collision threshold $B
S:1D86:CheckMonsterShotCollision: Params:\n A: damage points\n X: monster object slot\n [00]: weapon object slot\n [02]: monster object mid X\n [03]: monster object mid Y\n [09]: damage type\n [0D]: horizontal threshold\n\n Returns:\n [06]: 1 if objects collide\n
S:1D89:: If no collision, return.\n
S:1D8D:: $12 is the arrow and rod slot. But this routine will only\n be called if it's an arrow.\n\n If the weapon is an arrow and the monster is Pol's Voice;\n then set HP to 0, and deal damage, even if the collision\n checking routine above dealt some. This way it dies for sure.\n
S:1D94:: Pol's Voice
S:1DA0:: If the weapon is an arrow, set its state to spark ($20).\n
S:1DAA:_ParryOrShove: For any weapon type:\n\n If the monster is a darknut and both are facing opposite directions,\n then go parry.\n
S:1DAD:: Red Darknut
S:1DB1:: Blue Darknut
S:1DC2:: Else shove the monster.\n
S:1DC5:PlayParryTune
S:1DCB:_CheckMonsterSlenderWeaponCollision: Params:\n A: damage points\n X: monster object slot\n [00]: weapon object slot\n [02]: monster object mid X\n [03]: monster object mid Y\n [09]: damage type\n [0D]: horizontal threshold\n\n Returns:\n [06]: 1 if objects collide\n [07]: damage points\n [0E]: vertical threshold\n
S:1DD1:_CheckMonsterSlenderWeaponCollision2: Params:\n X: monster object slot\n [00]: weapon object slot\n [02]: monster object mid X\n [03]: monster object mid Y\n [07]: damage points\n [09]: damage type\n [0D]: horizontal threshold\n [0E]: vertical threshold\n\n Returns:\n [06]: 1 if objects collide\n
S:1DD3:: If Link is facing vertically, then:\n [04] := (weapon X + 6)\n A    := (weapon Y + 8)\n\n TODO: Shouldn't it be based on the weapon's direction?\n
S:1DEA:: Else Link is facing horizontally.\n [04] := (weapon X + 8)\n A    := (weapon Y + 6)\n\n TODO: Shouldn't it be based on the weapon's direction?\n
S:1DF8:: The A register will be copied to [05] and used here.\n
S:1DFB:_DoObjectsCollide: Params:\n A: collision distance threshold (objects collide if nearer in X and Y)\n [00]: weapon object slot (unused)\n [02]: object 1 mid X\n [03]: object 1 mid Y\n [04]: object 2 mid X\n [05]: object 2 mid Y\n\n Returns:\n A: 1 if objects collide\n Y: weapon object slot\n Z: 0 if objects collide\n [06]: 1 if objects collide\n [0A]: horizontal distance\n [0B]: vertical distance\n\n\n Use the same threshold value horizontally and vertically.\n Copy it to [0D] for horizontal threshold, and [0E] for vertical one.\n
S:1DFF:_DoObjectsCollideWithThresholds: Params:\n [00]: weapon or Link object slot (unused)\n [02]: object 1 mid X\n [03]: object 1 mid Y\n [04]: object 2 mid X\n [05]: object 2 mid Y\n [0D]: horizontal threshold\n [0E]: vertical threshold\n\n Returns:\n A: 1 if objects collide\n Y: weapon or Link object slot (copied from [00])\n Z: 0 if objects collide\n [06]: 1 if objects collide\n [0A]: horizontal distance\n [0B]: vertical distance\n\n\n Reset [06] to indicate no collision by default.\n
S:1E05:: Store in [0A] the horizontal distance between the two objects.\n
S:1E0F:: If distance >= horizontal threshold in [0D], return 0.\n
S:1E13:: Store in [0B] the vertical distance between the two objects.\n
S:1E1D:: If distance >= vertical threshold in [0E], return 0.\n
S:1E21:: If we get here, then the objects are close enough in both axes.\n Return 1.\n
S:1E26:BeginShove: Params:\n X: caller's object index, a monster\n    the attacker, if monster attacks Link\n    else defender, if weapon attacks monster\n [00]: 0 if monster attacks Link (defender),\n       else weapon slot (attacker)\n [09]: damage type,\n       only if a monster is defending\n TODO:\n [0B]: direction\n\n Only monsters (and fire) call this routine.\n\n When monsters attack Link, they set [00] to 0 for Link's slot.\n\n On the other hand, if a weapon attacks a monster,\n the monster sets [00] to the weapon's slot.\n\n\n If a weapon attacks a monster, and the weapon's damage\n type matches the monster's invincibility mask;\n then return without shoving.\n\n If a monster attacks Link, then damage type will be 0.\n
S:1E33:: [08], [04], and [05] are used in determining the direction to push Link,\n if he is defending. The goal is to push Link away from the monster.\n\n If instead a monster is defending, then all this calculation\n won't matter, because the shove direction will be set to the\n weapon's direction.\n\n As such, calculate a direction from the monster to the defender,\n assuming it's Link.\n\n Start with an assumption that the direction is vertical:\n Store 8 (up) in [08], monster Y in [04], and other Y in [05].\n
S:1E40:: If the defender is Link and his grid offset <> 0 then\n use his usual object direction variable to determine\n which axis to check.\n
S:1E51:: For monsters defending, or Link with grid offset = 0,\n check direction in [0B].\n\n For monsters defending, this won't matter. For Link with grid\n offset = 0, I believe the result will be arbitrary.\n\n TODO:\n Is [0B] always set if Link's grid offset = 0?\n It doesn't seem to be if candle fire attacks him.\n
S:1E57:: If the direction checked is left or right,\n set [08] to 2 (left), monster X in [04] and other X in [05].\n
S:1E64:: If the monster is down or right of the other object,\n then use the opposite direction already in [08].\n Else shift [08] right to turn it into the opposite\n direction up or down.\n\n Again assuming Link is the defender; after this, [08] points\n Link away from the monster.\n
S:1E6C:: If a monster is the defender, go handle it separately.\n
S:1E70:: Link is the defender.\n\n If Link is invincible, return without shoving.\n
S:1E75:: Store the shove direction we determined.\n\n Turn on the high bit to indicate that the next time we try to\n move by shoving, it will be the first time for this shove action.\n
S:1E7B:: Mark Link invincible $18 frames, and should move $20 pixels.\n
S:1E84:: If Link was shoved by one of his own weapons, then\n nothing else to do. Return.\n
S:1E88:: Link was shoved by a monster.\n\n TODO:\n If the monster's object attribute $80 is set, then return.\n
S:1E8F:: If the attacker is a vire, then return.\n
S:1E96:: Turn the attacker in the opposite direction.\n
S:1E9E:: A monster is the defender. A weapon is the attacker.\n\n Set the shove direction to the weapon's direction,\n instead of the direction passed in [0B].\n
S:1EA3:: TODO:\n If the monster's attribute $80 is set, the combine the\n shove direction with $40.\n
S:1EB0:: If the monster is invincible, then return without shoving.\n
S:1EB5:: TODO: ?\n If monster type = $33 or $34 (Gohma) then\n   If [0F] = 3 or 4\n     if [046B][X] <> 3; then return\n
S:1ED1:: Store the shove direction for the monster.\n\n Turn on the high bit to indicate that the next time we try to\n move by shoving, it will be the first time for this shove action.\n
S:1ED7:: Mark the monster invincible $10 frames, and should move $40 pixels.\n
S:1FFF:SaveRamEnd
G:2000:PpuControl_2000:7  bit  0\n---- ----\nVPHB SINN\n|||| ||||\n|||| ||++- Base nametable address\n|||| ||    (0 = $2000; 1 = $2400; 2 = $2800; 3 = $2C00)\n|||| |+--- VRAM address increment per CPU read/write of PPUDATA\n|||| |     (0: add 1, going across; 1: add 32, going down)\n|||| +---- Sprite pattern table address for 8x8 sprites\n||||       (0: $0000; 1: $1000; ignored in 8x16 mode)\n|||+------ Background pattern table address (0: $0000; 1: $1000)\n||+------- Sprite size (0: 8x8; 1: 8x16)\n|+-------- PPU master/slave select\n|          (0: read backdrop from EXT pins; 1: output color on EXT pins)\n+--------- Generate an NMI at the start of the\n           vertical blanking interval (0: off; 1: on)
G:2001:PpuMask_2001:7  bit  0\n---- ----\nBGRs bMmG\n|||| ||||\n|||| |||+- Display type: (0: color, 1: grayscale)\n|||| ||+-- 1: Show background in leftmost 8 pixels of screen, 0: Hide\n|||| |+--- 1: Show sprites in leftmost 8 pixels of screen, 0: Hide\n|||| +---- 1: Show background\n|||+------ 1: Show sprites\n||+------- Emphasize red\n|+-------- Emphasize green\n+--------- Emphasize blue
G:2002:PpuStatus_2002:7  bit  0\n---- ----\nVSO. ....\n|||| ||||\n|||+-++++- Least significant bits previously written into a PPU register\n|||        (due to register not being updated for this address)\n||+------- Sprite overflow. The intent was for this flag to be set\n||         whenever more than eight sprites appear on a scanline, but a\n||         hardware bug causes the actual behavior to be more complicated\n||         and generate false positives as well as false negatives; see\n||         PPU sprite evaluation. This flag is set during sprite\n||         evaluation and cleared at dot 1 (the second dot) of the\n||         pre-render line.\n|+-------- Sprite 0 Hit.  Set when a nonzero pixel of sprite 0 overlaps\n|          a nonzero background pixel; cleared at dot 1 of the pre-render\n|          line.  Used for raster timing.\n+--------- Vertical blank has started (0: not in vblank; 1: in vblank).\n           Set at dot 1 of line 241 (the line *after* the post-render\n           line, false); cleared after reading $2002 and at dot 1 of the\n           pre-render line.
G:2003:OamAddr_2003:Set OAM address - Write only
G:2004:OamData_2004:Read/Write OAM data
G:2005:PpuScroll_2005:Set PPU scroll, write twice - Write only
G:2006:PpuAddr_2006:Set PPU address, write twice - Write only
G:2007:PpuData_2007:Read/Write VRAM
G:4000:Sq0Duty_4000:DDLC VVVV\nDuty (D), envelope loop / length counter halt (L), constant volume (C), volume/envelope (V)
G:4001:Sq0Sweep_4001:EPPP NSSS\nSweep unit: enabled (E), period (P), negate (N), shift (S)
G:4002:Sq0Timer_4002:TTTT TTTT\nTimer low (T)
G:4003:Sq0Length_4003:LLLL LTTT\nLength counter load (L), timer high (T)
G:4004:Sq1Duty_4004:DDLC VVVV\nDuty (D), envelope loop / length counter halt (L), constant volume (C), volume/envelope (V)
G:4005:Sq1Sweep_4005:EPPP NSSS\nSweep unit: enabled (E), period (P), negate (N), shift (S)
G:4006:Sq1Timer_4006:TTTT TTTT\nTimer low (T)
G:4007:Sq1Length_4007:LLLL LTTT\nLength counter load (L), timer high (T)
G:4008:TrgLinear_4008:CRRR RRRR\nLength counter halt / linear counter control (C), linear counter load (R)
G:400A:TrgTimer_400A:TTTT TTTT\nTimer low (T)
G:400B:TrgLength_400B:LLLL LTTT\nLength counter load (L), timer high (T)
G:400C:NoiseVolume_400C:--LC VVVV\nEnvelope loop / length counter halt (L), constant volume (C), volume/envelope (V)
G:400E:NoisePeriod_400E:L--- PPPP\nLoop noise (L), noise period (P)
G:400F:NoiseLength_400F:LLLL L---\nLength counter load (L)
G:4010:DmcFreq_4010:IL-- RRRR\nIRQ enable (I), loop (L), frequency (R)
G:4011:DmcCounter_4011:-DDD DDDD\nLoad counter (D)
G:4012:DmcAddress_4012:AAAA AAAA\nSample address (A)
G:4013:DmcLength_4013:LLLL LLLL\nSample length (L)
G:4014:SpriteDma_4014:Writing $XX will upload 256 bytes of data from CPU page $XX00-$XXFF to the internal PPU OAM.
G:4015:ApuStatus_4015:Read:\nIF-D NT21\nDMC interrupt (I), frame interrupt (F), DMC active (D), length counter > 0 (N/T/2/1)\n\nWrite:\n---D NT21\nEnable DMC (D), noise (N), triangle (T), and pulse channels (2/1)
G:4016:Ctrl1_4016:Read (NES - input):\n---4 3210\nRead data from controller port #1.\n\nWrite:\n---- ---A\nOutput data (strobe) to both controllers.
G:4017:Ctrl2_FrameCtr_4017:Read (NES - input):\n---4 3210\nRead data from controller port #2.\n\nWrite (Frame counter): MI-- ----\nMode (M, 0 = 4-step, 1 = 5-step), IRQ inhibit flag (I)
